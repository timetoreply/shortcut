<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Timetoreply\Shortcut
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Shortcut API
 *
 * Shortcut API
 *
 * OpenAPI spec version: 3.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.43-SNAPSHOT
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Timetoreply\Shortcut\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Utils;
use GuzzleHttp\RequestOptions;
use InvalidArgumentException;
use RuntimeException;
use stdClass;
use Timetoreply\Shortcut\ApiException;
use Timetoreply\Shortcut\Configuration;
use Timetoreply\Shortcut\HeaderSelector;
use Timetoreply\Shortcut\Model\Category;
use Timetoreply\Shortcut\Model\CreateCategory;
use Timetoreply\Shortcut\Model\CreateCommentComment;
use Timetoreply\Shortcut\Model\CreateEntityTemplate;
use Timetoreply\Shortcut\Model\CreateEpic;
use Timetoreply\Shortcut\Model\CreateEpicComment;
use Timetoreply\Shortcut\Model\CreateGroup;
use Timetoreply\Shortcut\Model\CreateIteration;
use Timetoreply\Shortcut\Model\CreateLabelParams;
use Timetoreply\Shortcut\Model\CreateLinkedFile;
use Timetoreply\Shortcut\Model\CreateMilestone;
use Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction;
use Timetoreply\Shortcut\Model\CreateProject;
use Timetoreply\Shortcut\Model\CreateStories;
use Timetoreply\Shortcut\Model\CreateStoryComment;
use Timetoreply\Shortcut\Model\CreateStoryLink;
use Timetoreply\Shortcut\Model\CreateStoryParams;
use Timetoreply\Shortcut\Model\CreateTask;
use Timetoreply\Shortcut\Model\CustomField;
use Timetoreply\Shortcut\Model\DeleteStories;
use Timetoreply\Shortcut\Model\EntityTemplate;
use Timetoreply\Shortcut\Model\Epic;
use Timetoreply\Shortcut\Model\EpicSearchResults;
use Timetoreply\Shortcut\Model\EpicSlim;
use Timetoreply\Shortcut\Model\EpicWorkflow;
use Timetoreply\Shortcut\Model\GetEpicStories;
use Timetoreply\Shortcut\Model\GetExternalLinkStoriesParams;
use Timetoreply\Shortcut\Model\GetIterationStories;
use Timetoreply\Shortcut\Model\GetLabelStories;
use Timetoreply\Shortcut\Model\GetMember;
use Timetoreply\Shortcut\Model\GetProjectStories;
use Timetoreply\Shortcut\Model\Group;
use Timetoreply\Shortcut\Model\History;
use Timetoreply\Shortcut\Model\Iteration;
use Timetoreply\Shortcut\Model\IterationSearchResults;
use Timetoreply\Shortcut\Model\IterationSlim;
use Timetoreply\Shortcut\Model\Label;
use Timetoreply\Shortcut\Model\LinkedFile;
use Timetoreply\Shortcut\Model\ListEpics;
use Timetoreply\Shortcut\Model\ListGroupStories;
use Timetoreply\Shortcut\Model\ListLabels;
use Timetoreply\Shortcut\Model\ListMembers;
use Timetoreply\Shortcut\Model\Member;
use Timetoreply\Shortcut\Model\MemberInfo;
use Timetoreply\Shortcut\Model\Milestone;
use Timetoreply\Shortcut\Model\MilestoneSearchResults;
use Timetoreply\Shortcut\Model\Project;
use Timetoreply\Shortcut\Model\Repository;
use Timetoreply\Shortcut\Model\Search;
use Timetoreply\Shortcut\Model\SearchResults;
use Timetoreply\Shortcut\Model\SearchStories;
use Timetoreply\Shortcut\Model\Story;
use Timetoreply\Shortcut\Model\StoryComment;
use Timetoreply\Shortcut\Model\StoryLink;
use Timetoreply\Shortcut\Model\StoryReaction;
use Timetoreply\Shortcut\Model\StorySearchResults;
use Timetoreply\Shortcut\Model\StorySlim;
use Timetoreply\Shortcut\Model\Task;
use Timetoreply\Shortcut\Model\ThreadedComment;
use Timetoreply\Shortcut\Model\UpdateCategory;
use Timetoreply\Shortcut\Model\UpdateComment;
use Timetoreply\Shortcut\Model\UpdateCustomField;
use Timetoreply\Shortcut\Model\UpdateEntityTemplate;
use Timetoreply\Shortcut\Model\UpdateEpic;
use Timetoreply\Shortcut\Model\UpdateFile;
use Timetoreply\Shortcut\Model\UpdateGroup;
use Timetoreply\Shortcut\Model\UpdateIteration;
use Timetoreply\Shortcut\Model\UpdateLabel;
use Timetoreply\Shortcut\Model\UpdateLinkedFile;
use Timetoreply\Shortcut\Model\UpdateMilestone;
use Timetoreply\Shortcut\Model\UpdateProject;
use Timetoreply\Shortcut\Model\UpdateStories;
use Timetoreply\Shortcut\Model\UpdateStory;
use Timetoreply\Shortcut\Model\UpdateStoryComment;
use Timetoreply\Shortcut\Model\UpdateStoryLink;
use Timetoreply\Shortcut\Model\UpdateTask;
use Timetoreply\Shortcut\Model\UploadedFile;
use Timetoreply\Shortcut\Model\Workflow;
use Timetoreply\Shortcut\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Timetoreply\Shortcut
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration   $config = null,
        HeaderSelector  $selector = null
    )
    {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCategory
     *
     * Create Category
     *
     * @param CreateCategory $body body (required)
     *
     * @return Category
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createCategory($body)
    {
        list($response) = $this->createCategoryWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createCategoryWithHttpInfo
     *
     * Create Category
     *
     * @param CreateCategory $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createCategoryWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->createCategoryRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createCategory'
     *
     * @param CreateCategory $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createCategoryRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createCategory'
            );
        }

        $resourcePath = '/api/v3/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @return array of http client options
     * @throws RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    /**
     * Operation createCategoryAsync
     *
     * Create Category
     *
     * @param CreateCategory $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createCategoryAsync($body)
    {
        return $this->createCategoryAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCategoryAsyncWithHttpInfo
     *
     * Create Category
     *
     * @param CreateCategory $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createCategoryAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->createCategoryRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createEntityTemplate
     *
     * Create Entity Template
     *
     * @param CreateEntityTemplate $body Request paramaters for creating an entirely new entity template. (required)
     *
     * @return EntityTemplate
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEntityTemplate($body)
    {
        list($response) = $this->createEntityTemplateWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createEntityTemplateWithHttpInfo
     *
     * Create Entity Template
     *
     * @param CreateEntityTemplate $body Request paramaters for creating an entirely new entity template. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEntityTemplateWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->createEntityTemplateRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createEntityTemplate'
     *
     * @param CreateEntityTemplate $body Request paramaters for creating an entirely new entity template. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createEntityTemplateRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createEntityTemplate'
            );
        }

        $resourcePath = '/api/v3/entity-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEntityTemplateAsync
     *
     * Create Entity Template
     *
     * @param CreateEntityTemplate $body Request paramaters for creating an entirely new entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEntityTemplateAsync($body)
    {
        return $this->createEntityTemplateAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEntityTemplateAsyncWithHttpInfo
     *
     * Create Entity Template
     *
     * @param CreateEntityTemplate $body Request paramaters for creating an entirely new entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEntityTemplateAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->createEntityTemplateRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createEpic
     *
     * Create Epic
     *
     * @param CreateEpic $body body (required)
     *
     * @return Epic
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpic($body)
    {
        list($response) = $this->createEpicWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createEpicWithHttpInfo
     *
     * Create Epic
     *
     * @param CreateEpic $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpicWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->createEpicRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createEpic'
     *
     * @param CreateEpic $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createEpicRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createEpic'
            );
        }

        $resourcePath = '/api/v3/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicAsync
     *
     * Create Epic
     *
     * @param CreateEpic $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicAsync($body)
    {
        return $this->createEpicAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicAsyncWithHttpInfo
     *
     * Create Epic
     *
     * @param CreateEpic $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->createEpicRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createEpicComment
     *
     * Create Epic Comment
     *
     * @param CreateEpicComment $body body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     *
     * @return ThreadedComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpicComment($body, $epicPublicId)
    {
        list($response) = $this->createEpicCommentWithHttpInfo($body, $epicPublicId);
        return $response;
    }

    /**
     * Operation createEpicCommentWithHttpInfo
     *
     * Create Epic Comment
     *
     * @param CreateEpicComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpicCommentWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentRequest($body, $epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createEpicComment'
     *
     * @param CreateEpicComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createEpicCommentRequest($body, $epicPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createEpicComment'
            );
        }
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling createEpicComment'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicCommentAsync
     *
     * Create Epic Comment
     *
     * @param CreateEpicComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicCommentAsync($body, $epicPublicId)
    {
        return $this->createEpicCommentAsyncWithHttpInfo($body, $epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicCommentAsyncWithHttpInfo
     *
     * Create Epic Comment
     *
     * @param CreateEpicComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicCommentAsyncWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentRequest($body, $epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createEpicCommentComment
     *
     * Create Epic Comment Comment
     *
     * @param CreateCommentComment $body body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the parent Epic Comment. (required)
     *
     * @return ThreadedComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpicCommentComment($body, $epicPublicId, $commentPublicId)
    {
        list($response) = $this->createEpicCommentCommentWithHttpInfo($body, $epicPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation createEpicCommentCommentWithHttpInfo
     *
     * Create Epic Comment Comment
     *
     * @param CreateCommentComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the parent Epic Comment. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createEpicCommentCommentWithHttpInfo($body, $epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentCommentRequest($body, $epicPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createEpicCommentComment'
     *
     * @param CreateCommentComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the parent Epic Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createEpicCommentCommentRequest($body, $epicPublicId, $commentPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createEpicCommentComment'
            );
        }
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling createEpicCommentComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling createEpicCommentComment'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicCommentCommentAsync
     *
     * Create Epic Comment Comment
     *
     * @param CreateCommentComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the parent Epic Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicCommentCommentAsync($body, $epicPublicId, $commentPublicId)
    {
        return $this->createEpicCommentCommentAsyncWithHttpInfo($body, $epicPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicCommentCommentAsyncWithHttpInfo
     *
     * Create Epic Comment Comment
     *
     * @param CreateCommentComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the parent Epic Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createEpicCommentCommentAsyncWithHttpInfo($body, $epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentCommentRequest($body, $epicPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createGroup
     *
     * Create Group
     *
     * @param CreateGroup $body body (required)
     *
     * @return Group
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createGroup($body)
    {
        list($response) = $this->createGroupWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createGroupWithHttpInfo
     *
     * Create Group
     *
     * @param CreateGroup $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Group, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createGroupWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->createGroupRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createGroup'
     *
     * @param CreateGroup $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createGroupRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createGroup'
            );
        }

        $resourcePath = '/api/v3/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGroupAsync
     *
     * Create Group
     *
     * @param CreateGroup $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createGroupAsync($body)
    {
        return $this->createGroupAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGroupAsyncWithHttpInfo
     *
     * Create Group
     *
     * @param CreateGroup $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createGroupAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->createGroupRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createIteration
     *
     * Create Iteration
     *
     * @param CreateIteration $body body (required)
     *
     * @return Iteration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createIteration($body)
    {
        list($response) = $this->createIterationWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createIterationWithHttpInfo
     *
     * Create Iteration
     *
     * @param CreateIteration $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createIterationWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->createIterationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createIteration'
     *
     * @param CreateIteration $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createIterationRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createIteration'
            );
        }

        $resourcePath = '/api/v3/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createIterationAsync
     *
     * Create Iteration
     *
     * @param CreateIteration $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createIterationAsync($body)
    {
        return $this->createIterationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createIterationAsyncWithHttpInfo
     *
     * Create Iteration
     *
     * @param CreateIteration $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createIterationAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->createIterationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createLabel
     *
     * Create Label
     *
     * @param CreateLabelParams $body Request parameters for creating a Label on a Shortcut Story. (required)
     *
     * @return Label
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createLabel($body)
    {
        list($response) = $this->createLabelWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createLabelWithHttpInfo
     *
     * Create Label
     *
     * @param CreateLabelParams $body Request parameters for creating a Label on a Shortcut Story. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createLabelWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->createLabelRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createLabel'
     *
     * @param CreateLabelParams $body Request parameters for creating a Label on a Shortcut Story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createLabelRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createLabel'
            );
        }

        $resourcePath = '/api/v3/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createLabelAsync
     *
     * Create Label
     *
     * @param CreateLabelParams $body Request parameters for creating a Label on a Shortcut Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createLabelAsync($body)
    {
        return $this->createLabelAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLabelAsyncWithHttpInfo
     *
     * Create Label
     *
     * @param CreateLabelParams $body Request parameters for creating a Label on a Shortcut Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createLabelAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->createLabelRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createLinkedFile
     *
     * Create Linked File
     *
     * @param CreateLinkedFile $body body (required)
     *
     * @return LinkedFile
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createLinkedFile($body)
    {
        list($response) = $this->createLinkedFileWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createLinkedFileWithHttpInfo
     *
     * Create Linked File
     *
     * @param CreateLinkedFile $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createLinkedFileWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->createLinkedFileRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createLinkedFile'
     *
     * @param CreateLinkedFile $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createLinkedFileRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createLinkedFile'
            );
        }

        $resourcePath = '/api/v3/linked-files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createLinkedFileAsync
     *
     * Create Linked File
     *
     * @param CreateLinkedFile $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createLinkedFileAsync($body)
    {
        return $this->createLinkedFileAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLinkedFileAsyncWithHttpInfo
     *
     * Create Linked File
     *
     * @param CreateLinkedFile $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createLinkedFileAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->createLinkedFileRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createMilestone
     *
     * Create Milestone
     *
     * @param CreateMilestone $body body (required)
     *
     * @return Milestone
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createMilestone($body)
    {
        list($response) = $this->createMilestoneWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createMilestoneWithHttpInfo
     *
     * Create Milestone
     *
     * @param CreateMilestone $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createMilestoneWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->createMilestoneRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createMilestone'
     *
     * @param CreateMilestone $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createMilestoneRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createMilestone'
            );
        }

        $resourcePath = '/api/v3/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMilestoneAsync
     *
     * Create Milestone
     *
     * @param CreateMilestone $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createMilestoneAsync($body)
    {
        return $this->createMilestoneAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMilestoneAsyncWithHttpInfo
     *
     * Create Milestone
     *
     * @param CreateMilestone $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createMilestoneAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->createMilestoneRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createMultipleStories
     *
     * Create Multiple Stories
     *
     * @param CreateStories $body body (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createMultipleStories($body)
    {
        list($response) = $this->createMultipleStoriesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createMultipleStoriesWithHttpInfo
     *
     * Create Multiple Stories
     *
     * @param CreateStories $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createMultipleStoriesWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->createMultipleStoriesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createMultipleStories'
     *
     * @param CreateStories $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createMultipleStoriesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createMultipleStories'
            );
        }

        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMultipleStoriesAsync
     *
     * Create Multiple Stories
     *
     * @param CreateStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createMultipleStoriesAsync($body)
    {
        return $this->createMultipleStoriesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMultipleStoriesAsyncWithHttpInfo
     *
     * Create Multiple Stories
     *
     * @param CreateStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createMultipleStoriesAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->createMultipleStoriesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createProject
     *
     * Create Project
     *
     * @param CreateProject $body body (required)
     *
     * @return Project
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createProject($body)
    {
        list($response) = $this->createProjectWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createProjectWithHttpInfo
     *
     * Create Project
     *
     * @param CreateProject $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createProjectWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->createProjectRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createProject'
     *
     * @param CreateProject $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createProjectRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createProject'
            );
        }

        $resourcePath = '/api/v3/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createProjectAsync
     *
     * Create Project
     *
     * @param CreateProject $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createProjectAsync($body)
    {
        return $this->createProjectAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createProjectAsyncWithHttpInfo
     *
     * Create Project
     *
     * @param CreateProject $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createProjectAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->createProjectRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createStory
     *
     * Create Story
     *
     * @param CreateStoryParams $body Request parameters for creating a story. (required)
     *
     * @return Story
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStory($body)
    {
        list($response) = $this->createStoryWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createStoryWithHttpInfo
     *
     * Create Story
     *
     * @param CreateStoryParams $body Request parameters for creating a story. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->createStoryRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createStory'
     *
     * @param CreateStoryParams $body Request parameters for creating a story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createStoryRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createStory'
            );
        }

        $resourcePath = '/api/v3/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryAsync
     *
     * Create Story
     *
     * @param CreateStoryParams $body Request parameters for creating a story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryAsync($body)
    {
        return $this->createStoryAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryAsyncWithHttpInfo
     *
     * Create Story
     *
     * @param CreateStoryParams $body Request parameters for creating a story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->createStoryRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createStoryComment
     *
     * Create Story Comment
     *
     * @param CreateStoryComment $body body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return StoryComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryComment($body, $storyPublicId)
    {
        list($response) = $this->createStoryCommentWithHttpInfo($body, $storyPublicId);
        return $response;
    }

    /**
     * Operation createStoryCommentWithHttpInfo
     *
     * Create Story Comment
     *
     * @param CreateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryCommentWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->createStoryCommentRequest($body, $storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createStoryComment'
     *
     * @param CreateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createStoryCommentRequest($body, $storyPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createStoryComment'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createStoryComment'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryCommentAsync
     *
     * Create Story Comment
     *
     * @param CreateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryCommentAsync($body, $storyPublicId)
    {
        return $this->createStoryCommentAsyncWithHttpInfo($body, $storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryCommentAsyncWithHttpInfo
     *
     * Create Story Comment
     *
     * @param CreateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryCommentAsyncWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->createStoryCommentRequest($body, $storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createStoryLink
     *
     * Create Story Link
     *
     * @param CreateStoryLink $body body (required)
     *
     * @return StoryLink
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryLink($body)
    {
        list($response) = $this->createStoryLinkWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createStoryLinkWithHttpInfo
     *
     * Create Story Link
     *
     * @param CreateStoryLink $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryLinkWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->createStoryLinkRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createStoryLink'
     *
     * @param CreateStoryLink $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createStoryLinkRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createStoryLink'
            );
        }

        $resourcePath = '/api/v3/story-links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryLinkAsync
     *
     * Create Story Link
     *
     * @param CreateStoryLink $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryLinkAsync($body)
    {
        return $this->createStoryLinkAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryLinkAsyncWithHttpInfo
     *
     * Create Story Link
     *
     * @param CreateStoryLink $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryLinkAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->createStoryLinkRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createStoryReaction
     *
     * Create Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return StoryReaction[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryReaction($body, $storyPublicId, $commentPublicId)
    {
        list($response) = $this->createStoryReactionWithHttpInfo($body, $storyPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation createStoryReactionWithHttpInfo
     *
     * Create Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryReaction[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createStoryReactionWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryReaction[]';
        $request = $this->createStoryReactionRequest($body, $storyPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryReaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createStoryReaction'
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createStoryReactionRequest($body, $storyPublicId, $commentPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createStoryReaction'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createStoryReaction'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling createStoryReaction'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryReactionAsync
     *
     * Create Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryReactionAsync($body, $storyPublicId, $commentPublicId)
    {
        return $this->createStoryReactionAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryReactionAsyncWithHttpInfo
     *
     * Create Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createStoryReactionAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryReaction[]';
        $request = $this->createStoryReactionRequest($body, $storyPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation createTask
     *
     * Create Task
     *
     * @param CreateTask $body body (required)
     * @param int $storyPublicId The ID of the Story that the Task will be in. (required)
     *
     * @return Task
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createTask($body, $storyPublicId)
    {
        list($response) = $this->createTaskWithHttpInfo($body, $storyPublicId);
        return $response;
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * Create Task
     *
     * @param CreateTask $body (required)
     * @param int $storyPublicId The ID of the Story that the Task will be in. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function createTaskWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->createTaskRequest($body, $storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param CreateTask $body (required)
     * @param int $storyPublicId The ID of the Story that the Task will be in. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function createTaskRequest($body, $storyPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling createTask'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createTask'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaskAsync
     *
     * Create Task
     *
     * @param CreateTask $body (required)
     * @param int $storyPublicId The ID of the Story that the Task will be in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createTaskAsync($body, $storyPublicId)
    {
        return $this->createTaskAsyncWithHttpInfo($body, $storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * Create Task
     *
     * @param CreateTask $body (required)
     * @param int $storyPublicId The ID of the Story that the Task will be in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function createTaskAsyncWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->createTaskRequest($body, $storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteCategory
     *
     * Delete Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteCategory($categoryPublicId)
    {
        $this->deleteCategoryWithHttpInfo($categoryPublicId);
    }

    /**
     * Operation deleteCategoryWithHttpInfo
     *
     * Delete Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteCategoryWithHttpInfo($categoryPublicId)
    {
        $returnType = '';
        $request = $this->deleteCategoryRequest($categoryPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteCategory'
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteCategoryRequest($categoryPublicId)
    {
        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling deleteCategory'
            );
        }

        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCategoryAsync
     *
     * Delete Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteCategoryAsync($categoryPublicId)
    {
        return $this->deleteCategoryAsyncWithHttpInfo($categoryPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCategoryAsyncWithHttpInfo
     *
     * Delete Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteCategoryAsyncWithHttpInfo($categoryPublicId)
    {
        $returnType = '';
        $request = $this->deleteCategoryRequest($categoryPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteCustomField
     *
     * Delete Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteCustomField($customFieldPublicId)
    {
        $this->deleteCustomFieldWithHttpInfo($customFieldPublicId);
    }

    /**
     * Operation deleteCustomFieldWithHttpInfo
     *
     * Delete Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteCustomFieldWithHttpInfo($customFieldPublicId)
    {
        $returnType = '';
        $request = $this->deleteCustomFieldRequest($customFieldPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteCustomField'
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteCustomFieldRequest($customFieldPublicId)
    {
        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling deleteCustomField'
            );
        }

        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomFieldAsync
     *
     * Delete Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteCustomFieldAsync($customFieldPublicId)
    {
        return $this->deleteCustomFieldAsyncWithHttpInfo($customFieldPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomFieldAsyncWithHttpInfo
     *
     * Delete Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteCustomFieldAsyncWithHttpInfo($customFieldPublicId)
    {
        $returnType = '';
        $request = $this->deleteCustomFieldRequest($customFieldPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteEntityTemplate
     *
     * Delete Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEntityTemplate($entityTemplatePublicId)
    {
        $this->deleteEntityTemplateWithHttpInfo($entityTemplatePublicId);
    }

    /**
     * Operation deleteEntityTemplateWithHttpInfo
     *
     * Delete Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEntityTemplateWithHttpInfo($entityTemplatePublicId)
    {
        $returnType = '';
        $request = $this->deleteEntityTemplateRequest($entityTemplatePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteEntityTemplate'
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteEntityTemplateRequest($entityTemplatePublicId)
    {
        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling deleteEntityTemplate'
            );
        }

        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEntityTemplateAsync
     *
     * Delete Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEntityTemplateAsync($entityTemplatePublicId)
    {
        return $this->deleteEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEntityTemplateAsyncWithHttpInfo
     *
     * Delete Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId)
    {
        $returnType = '';
        $request = $this->deleteEntityTemplateRequest($entityTemplatePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteEpic
     *
     * Delete Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEpic($epicPublicId)
    {
        $this->deleteEpicWithHttpInfo($epicPublicId);
    }

    /**
     * Operation deleteEpicWithHttpInfo
     *
     * Delete Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEpicWithHttpInfo($epicPublicId)
    {
        $returnType = '';
        $request = $this->deleteEpicRequest($epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteEpic'
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteEpicRequest($epicPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling deleteEpic'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEpicAsync
     *
     * Delete Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEpicAsync($epicPublicId)
    {
        return $this->deleteEpicAsyncWithHttpInfo($epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEpicAsyncWithHttpInfo
     *
     * Delete Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEpicAsyncWithHttpInfo($epicPublicId)
    {
        $returnType = '';
        $request = $this->deleteEpicRequest($epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteEpicComment
     *
     * Delete Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEpicComment($epicPublicId, $commentPublicId)
    {
        $this->deleteEpicCommentWithHttpInfo($epicPublicId, $commentPublicId);
    }

    /**
     * Operation deleteEpicCommentWithHttpInfo
     *
     * Delete Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteEpicCommentWithHttpInfo($epicPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteEpicCommentRequest($epicPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteEpicComment'
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteEpicCommentRequest($epicPublicId, $commentPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling deleteEpicComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteEpicComment'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEpicCommentAsync
     *
     * Delete Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEpicCommentAsync($epicPublicId, $commentPublicId)
    {
        return $this->deleteEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEpicCommentAsyncWithHttpInfo
     *
     * Delete Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteEpicCommentRequest($epicPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteFile
     *
     * Delete File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteFile($filePublicId)
    {
        $this->deleteFileWithHttpInfo($filePublicId);
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Delete File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteFileWithHttpInfo($filePublicId)
    {
        $returnType = '';
        $request = $this->deleteFileRequest($filePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteFileRequest($filePublicId)
    {
        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling deleteFile'
            );
        }

        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFileAsync
     *
     * Delete File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteFileAsync($filePublicId)
    {
        return $this->deleteFileAsyncWithHttpInfo($filePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Delete File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteFileAsyncWithHttpInfo($filePublicId)
    {
        $returnType = '';
        $request = $this->deleteFileRequest($filePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteIteration
     *
     * Delete Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteIteration($iterationPublicId)
    {
        $this->deleteIterationWithHttpInfo($iterationPublicId);
    }

    /**
     * Operation deleteIterationWithHttpInfo
     *
     * Delete Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteIterationWithHttpInfo($iterationPublicId)
    {
        $returnType = '';
        $request = $this->deleteIterationRequest($iterationPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteIteration'
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteIterationRequest($iterationPublicId)
    {
        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling deleteIteration'
            );
        }

        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteIterationAsync
     *
     * Delete Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteIterationAsync($iterationPublicId)
    {
        return $this->deleteIterationAsyncWithHttpInfo($iterationPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteIterationAsyncWithHttpInfo
     *
     * Delete Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteIterationAsyncWithHttpInfo($iterationPublicId)
    {
        $returnType = '';
        $request = $this->deleteIterationRequest($iterationPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteLabel
     *
     * Delete Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteLabel($labelPublicId)
    {
        $this->deleteLabelWithHttpInfo($labelPublicId);
    }

    /**
     * Operation deleteLabelWithHttpInfo
     *
     * Delete Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteLabelWithHttpInfo($labelPublicId)
    {
        $returnType = '';
        $request = $this->deleteLabelRequest($labelPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteLabel'
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteLabelRequest($labelPublicId)
    {
        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling deleteLabel'
            );
        }

        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLabelAsync
     *
     * Delete Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteLabelAsync($labelPublicId)
    {
        return $this->deleteLabelAsyncWithHttpInfo($labelPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLabelAsyncWithHttpInfo
     *
     * Delete Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteLabelAsyncWithHttpInfo($labelPublicId)
    {
        $returnType = '';
        $request = $this->deleteLabelRequest($labelPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteLinkedFile
     *
     * Delete Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteLinkedFile($linkedFilePublicId)
    {
        $this->deleteLinkedFileWithHttpInfo($linkedFilePublicId);
    }

    /**
     * Operation deleteLinkedFileWithHttpInfo
     *
     * Delete Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteLinkedFileWithHttpInfo($linkedFilePublicId)
    {
        $returnType = '';
        $request = $this->deleteLinkedFileRequest($linkedFilePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteLinkedFile'
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteLinkedFileRequest($linkedFilePublicId)
    {
        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling deleteLinkedFile'
            );
        }

        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLinkedFileAsync
     *
     * Delete Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteLinkedFileAsync($linkedFilePublicId)
    {
        return $this->deleteLinkedFileAsyncWithHttpInfo($linkedFilePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLinkedFileAsyncWithHttpInfo
     *
     * Delete Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteLinkedFileAsyncWithHttpInfo($linkedFilePublicId)
    {
        $returnType = '';
        $request = $this->deleteLinkedFileRequest($linkedFilePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteMilestone
     *
     * Delete Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteMilestone($milestonePublicId)
    {
        $this->deleteMilestoneWithHttpInfo($milestonePublicId);
    }

    /**
     * Operation deleteMilestoneWithHttpInfo
     *
     * Delete Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteMilestoneWithHttpInfo($milestonePublicId)
    {
        $returnType = '';
        $request = $this->deleteMilestoneRequest($milestonePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteMilestone'
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteMilestoneRequest($milestonePublicId)
    {
        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling deleteMilestone'
            );
        }

        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMilestoneAsync
     *
     * Delete Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteMilestoneAsync($milestonePublicId)
    {
        return $this->deleteMilestoneAsyncWithHttpInfo($milestonePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMilestoneAsyncWithHttpInfo
     *
     * Delete Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteMilestoneAsyncWithHttpInfo($milestonePublicId)
    {
        $returnType = '';
        $request = $this->deleteMilestoneRequest($milestonePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteMultipleStories
     *
     * Delete Multiple Stories
     *
     * @param DeleteStories $body body (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteMultipleStories($body)
    {
        $this->deleteMultipleStoriesWithHttpInfo($body);
    }

    /**
     * Operation deleteMultipleStoriesWithHttpInfo
     *
     * Delete Multiple Stories
     *
     * @param DeleteStories $body (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteMultipleStoriesWithHttpInfo($body)
    {
        $returnType = '';
        $request = $this->deleteMultipleStoriesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteMultipleStories'
     *
     * @param DeleteStories $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteMultipleStoriesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling deleteMultipleStories'
            );
        }

        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMultipleStoriesAsync
     *
     * Delete Multiple Stories
     *
     * @param DeleteStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteMultipleStoriesAsync($body)
    {
        return $this->deleteMultipleStoriesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMultipleStoriesAsyncWithHttpInfo
     *
     * Delete Multiple Stories
     *
     * @param DeleteStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteMultipleStoriesAsyncWithHttpInfo($body)
    {
        $returnType = '';
        $request = $this->deleteMultipleStoriesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteProject
     *
     * Delete Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteProject($projectPublicId)
    {
        $this->deleteProjectWithHttpInfo($projectPublicId);
    }

    /**
     * Operation deleteProjectWithHttpInfo
     *
     * Delete Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteProjectWithHttpInfo($projectPublicId)
    {
        $returnType = '';
        $request = $this->deleteProjectRequest($projectPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteProject'
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteProjectRequest($projectPublicId)
    {
        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling deleteProject'
            );
        }

        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProjectAsync
     *
     * Delete Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteProjectAsync($projectPublicId)
    {
        return $this->deleteProjectAsyncWithHttpInfo($projectPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProjectAsyncWithHttpInfo
     *
     * Delete Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteProjectAsyncWithHttpInfo($projectPublicId)
    {
        $returnType = '';
        $request = $this->deleteProjectRequest($projectPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteStory
     *
     * Delete Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStory($storyPublicId)
    {
        $this->deleteStoryWithHttpInfo($storyPublicId);
    }

    /**
     * Operation deleteStoryWithHttpInfo
     *
     * Delete Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryWithHttpInfo($storyPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryRequest($storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteStory'
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteStoryRequest($storyPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStory'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryAsync
     *
     * Delete Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryAsync($storyPublicId)
    {
        return $this->deleteStoryAsyncWithHttpInfo($storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryAsyncWithHttpInfo
     *
     * Delete Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryAsyncWithHttpInfo($storyPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryRequest($storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteStoryComment
     *
     * Delete Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryComment($storyPublicId, $commentPublicId)
    {
        $this->deleteStoryCommentWithHttpInfo($storyPublicId, $commentPublicId);
    }

    /**
     * Operation deleteStoryCommentWithHttpInfo
     *
     * Delete Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryCommentWithHttpInfo($storyPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryCommentRequest($storyPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteStoryComment'
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteStoryCommentRequest($storyPublicId, $commentPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStoryComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteStoryComment'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryCommentAsync
     *
     * Delete Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryCommentAsync($storyPublicId, $commentPublicId)
    {
        return $this->deleteStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryCommentAsyncWithHttpInfo
     *
     * Delete Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryCommentRequest($storyPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteStoryLink
     *
     * Delete Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryLink($storyLinkPublicId)
    {
        $this->deleteStoryLinkWithHttpInfo($storyLinkPublicId);
    }

    /**
     * Operation deleteStoryLinkWithHttpInfo
     *
     * Delete Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryLinkWithHttpInfo($storyLinkPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryLinkRequest($storyLinkPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteStoryLink'
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteStoryLinkRequest($storyLinkPublicId)
    {
        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling deleteStoryLink'
            );
        }

        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryLinkAsync
     *
     * Delete Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryLinkAsync($storyLinkPublicId)
    {
        return $this->deleteStoryLinkAsyncWithHttpInfo($storyLinkPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryLinkAsyncWithHttpInfo
     *
     * Delete Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryLinkAsyncWithHttpInfo($storyLinkPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryLinkRequest($storyLinkPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteStoryReaction
     *
     * Delete Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryReaction($body, $storyPublicId, $commentPublicId)
    {
        $this->deleteStoryReactionWithHttpInfo($body, $storyPublicId, $commentPublicId);
    }

    /**
     * Operation deleteStoryReactionWithHttpInfo
     *
     * Delete Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteStoryReactionWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryReactionRequest($body, $storyPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteStoryReaction'
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteStoryReactionRequest($body, $storyPublicId, $commentPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling deleteStoryReaction'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStoryReaction'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteStoryReaction'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryReactionAsync
     *
     * Delete Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryReactionAsync($body, $storyPublicId, $commentPublicId)
    {
        return $this->deleteStoryReactionAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryReactionAsyncWithHttpInfo
     *
     * Delete Story Reaction
     *
     * @param CreateOrDeleteStoryReaction $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteStoryReactionAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '';
        $request = $this->deleteStoryReactionRequest($body, $storyPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation deleteTask
     *
     * Delete Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteTask($storyPublicId, $taskPublicId)
    {
        $this->deleteTaskWithHttpInfo($storyPublicId, $taskPublicId);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * Delete Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function deleteTaskWithHttpInfo($storyPublicId, $taskPublicId)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($storyPublicId, $taskPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function deleteTaskRequest($storyPublicId, $taskPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteTask'
            );
        }
        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling deleteTask'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTaskAsync
     *
     * Delete Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteTaskAsync($storyPublicId, $taskPublicId)
    {
        return $this->deleteTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * Delete Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function deleteTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($storyPublicId, $taskPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation disableGroups
     *
     * Disable Groups
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableGroups()
    {
        $this->disableGroupsWithHttpInfo();
    }

    /**
     * Operation disableGroupsWithHttpInfo
     *
     * Disable Groups
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableGroupsWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableGroupsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'disableGroups'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function disableGroupsRequest()
    {

        $resourcePath = '/api/v3/groups/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableGroupsAsync
     *
     * Disable Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableGroupsAsync()
    {
        return $this->disableGroupsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableGroupsAsyncWithHttpInfo
     *
     * Disable Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableGroupsAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableGroupsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation disableIterations
     *
     * Disable Iterations
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableIterations()
    {
        $this->disableIterationsWithHttpInfo();
    }

    /**
     * Operation disableIterationsWithHttpInfo
     *
     * Disable Iterations
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableIterationsWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableIterationsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'disableIterations'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function disableIterationsRequest()
    {

        $resourcePath = '/api/v3/iterations/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableIterationsAsync
     *
     * Disable Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableIterationsAsync()
    {
        return $this->disableIterationsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableIterationsAsyncWithHttpInfo
     *
     * Disable Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableIterationsAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableIterationsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation disableStoryTemplates
     *
     * Disable Story Templates
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableStoryTemplates()
    {
        $this->disableStoryTemplatesWithHttpInfo();
    }

    /**
     * Operation disableStoryTemplatesWithHttpInfo
     *
     * Disable Story Templates
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function disableStoryTemplatesWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableStoryTemplatesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'disableStoryTemplates'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function disableStoryTemplatesRequest()
    {

        $resourcePath = '/api/v3/entity-templates/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableStoryTemplatesAsync
     *
     * Disable Story Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableStoryTemplatesAsync()
    {
        return $this->disableStoryTemplatesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableStoryTemplatesAsyncWithHttpInfo
     *
     * Disable Story Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function disableStoryTemplatesAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->disableStoryTemplatesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation enableGroups
     *
     * Enable Groups
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableGroups()
    {
        $this->enableGroupsWithHttpInfo();
    }

    /**
     * Operation enableGroupsWithHttpInfo
     *
     * Enable Groups
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableGroupsWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableGroupsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'enableGroups'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function enableGroupsRequest()
    {

        $resourcePath = '/api/v3/groups/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableGroupsAsync
     *
     * Enable Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableGroupsAsync()
    {
        return $this->enableGroupsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableGroupsAsyncWithHttpInfo
     *
     * Enable Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableGroupsAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableGroupsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation enableIterations
     *
     * Enable Iterations
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableIterations()
    {
        $this->enableIterationsWithHttpInfo();
    }

    /**
     * Operation enableIterationsWithHttpInfo
     *
     * Enable Iterations
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableIterationsWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableIterationsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'enableIterations'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function enableIterationsRequest()
    {

        $resourcePath = '/api/v3/iterations/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableIterationsAsync
     *
     * Enable Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableIterationsAsync()
    {
        return $this->enableIterationsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableIterationsAsyncWithHttpInfo
     *
     * Enable Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableIterationsAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableIterationsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation enableStoryTemplates
     *
     * Enable Story Templates
     *
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableStoryTemplates()
    {
        $this->enableStoryTemplatesWithHttpInfo();
    }

    /**
     * Operation enableStoryTemplatesWithHttpInfo
     *
     * Enable Story Templates
     *
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function enableStoryTemplatesWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableStoryTemplatesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'enableStoryTemplates'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function enableStoryTemplatesRequest()
    {

        $resourcePath = '/api/v3/entity-templates/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableStoryTemplatesAsync
     *
     * Enable Story Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableStoryTemplatesAsync()
    {
        return $this->enableStoryTemplatesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableStoryTemplatesAsyncWithHttpInfo
     *
     * Enable Story Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function enableStoryTemplatesAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->enableStoryTemplatesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getCategory
     *
     * Get Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return Category
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCategory($categoryPublicId)
    {
        list($response) = $this->getCategoryWithHttpInfo($categoryPublicId);
        return $response;
    }

    /**
     * Operation getCategoryWithHttpInfo
     *
     * Get Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCategoryWithHttpInfo($categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->getCategoryRequest($categoryPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getCategory'
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getCategoryRequest($categoryPublicId)
    {
        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling getCategory'
            );
        }

        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategoryAsync
     *
     * Get Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCategoryAsync($categoryPublicId)
    {
        return $this->getCategoryAsyncWithHttpInfo($categoryPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoryAsyncWithHttpInfo
     *
     * Get Category
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCategoryAsyncWithHttpInfo($categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->getCategoryRequest($categoryPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getCurrentMemberInfo
     *
     * Get Current Member Info
     *
     *
     * @return MemberInfo
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCurrentMemberInfo()
    {
        list($response) = $this->getCurrentMemberInfoWithHttpInfo();
        return $response;
    }

    /**
     * Operation getCurrentMemberInfoWithHttpInfo
     *
     * Get Current Member Info
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\MemberInfo, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCurrentMemberInfoWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\MemberInfo';
        $request = $this->getCurrentMemberInfoRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MemberInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getCurrentMemberInfo'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getCurrentMemberInfoRequest()
    {

        $resourcePath = '/api/v3/member';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentMemberInfoAsync
     *
     * Get Current Member Info
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCurrentMemberInfoAsync()
    {
        return $this->getCurrentMemberInfoAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentMemberInfoAsyncWithHttpInfo
     *
     * Get Current Member Info
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCurrentMemberInfoAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\MemberInfo';
        $request = $this->getCurrentMemberInfoRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getCustomField
     *
     * Get Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return CustomField
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCustomField($customFieldPublicId)
    {
        list($response) = $this->getCustomFieldWithHttpInfo($customFieldPublicId);
        return $response;
    }

    /**
     * Operation getCustomFieldWithHttpInfo
     *
     * Get Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getCustomFieldWithHttpInfo($customFieldPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->getCustomFieldRequest($customFieldPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getCustomField'
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getCustomFieldRequest($customFieldPublicId)
    {
        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling getCustomField'
            );
        }

        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomFieldAsync
     *
     * Get Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCustomFieldAsync($customFieldPublicId)
    {
        return $this->getCustomFieldAsyncWithHttpInfo($customFieldPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomFieldAsyncWithHttpInfo
     *
     * Get Custom Field
     *
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getCustomFieldAsyncWithHttpInfo($customFieldPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->getCustomFieldRequest($customFieldPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getEntityTemplate
     *
     * Get Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return EntityTemplate
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEntityTemplate($entityTemplatePublicId)
    {
        list($response) = $this->getEntityTemplateWithHttpInfo($entityTemplatePublicId);
        return $response;
    }

    /**
     * Operation getEntityTemplateWithHttpInfo
     *
     * Get Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEntityTemplateWithHttpInfo($entityTemplatePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->getEntityTemplateRequest($entityTemplatePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getEntityTemplate'
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getEntityTemplateRequest($entityTemplatePublicId)
    {
        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling getEntityTemplate'
            );
        }

        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEntityTemplateAsync
     *
     * Get Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEntityTemplateAsync($entityTemplatePublicId)
    {
        return $this->getEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEntityTemplateAsyncWithHttpInfo
     *
     * Get Entity Template
     *
     * @param string $entityTemplatePublicId The unique ID of the entity template. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->getEntityTemplateRequest($entityTemplatePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getEpic
     *
     * Get Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Epic
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpic($epicPublicId)
    {
        list($response) = $this->getEpicWithHttpInfo($epicPublicId);
        return $response;
    }

    /**
     * Operation getEpicWithHttpInfo
     *
     * Get Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpicWithHttpInfo($epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->getEpicRequest($epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getEpic'
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getEpicRequest($epicPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling getEpic'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicAsync
     *
     * Get Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicAsync($epicPublicId)
    {
        return $this->getEpicAsyncWithHttpInfo($epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicAsyncWithHttpInfo
     *
     * Get Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicAsyncWithHttpInfo($epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->getEpicRequest($epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getEpicComment
     *
     * Get Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return ThreadedComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpicComment($epicPublicId, $commentPublicId)
    {
        list($response) = $this->getEpicCommentWithHttpInfo($epicPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation getEpicCommentWithHttpInfo
     *
     * Get Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpicCommentWithHttpInfo($epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->getEpicCommentRequest($epicPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getEpicComment'
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getEpicCommentRequest($epicPublicId, $commentPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling getEpicComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling getEpicComment'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicCommentAsync
     *
     * Get Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicCommentAsync($epicPublicId, $commentPublicId)
    {
        return $this->getEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicCommentAsyncWithHttpInfo
     *
     * Get Epic Comment
     *
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->getEpicCommentRequest($epicPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getEpicWorkflow
     *
     * Get Epic Workflow
     *
     *
     * @return EpicWorkflow
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpicWorkflow()
    {
        list($response) = $this->getEpicWorkflowWithHttpInfo();
        return $response;
    }

    /**
     * Operation getEpicWorkflowWithHttpInfo
     *
     * Get Epic Workflow
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\EpicWorkflow, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getEpicWorkflowWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicWorkflow';
        $request = $this->getEpicWorkflowRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicWorkflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getEpicWorkflow'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getEpicWorkflowRequest()
    {

        $resourcePath = '/api/v3/epic-workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicWorkflowAsync
     *
     * Get Epic Workflow
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicWorkflowAsync()
    {
        return $this->getEpicWorkflowAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicWorkflowAsyncWithHttpInfo
     *
     * Get Epic Workflow
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getEpicWorkflowAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicWorkflow';
        $request = $this->getEpicWorkflowRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getExternalLinkStories
     *
     * Get External Link Stories
     *
     * @param GetExternalLinkStoriesParams $body body (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getExternalLinkStories($body)
    {
        list($response) = $this->getExternalLinkStoriesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation getExternalLinkStoriesWithHttpInfo
     *
     * Get External Link Stories
     *
     * @param GetExternalLinkStoriesParams $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getExternalLinkStoriesWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->getExternalLinkStoriesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getExternalLinkStories'
     *
     * @param GetExternalLinkStoriesParams $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getExternalLinkStoriesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling getExternalLinkStories'
            );
        }

        $resourcePath = '/api/v3/external-link/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExternalLinkStoriesAsync
     *
     * Get External Link Stories
     *
     * @param GetExternalLinkStoriesParams $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getExternalLinkStoriesAsync($body)
    {
        return $this->getExternalLinkStoriesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExternalLinkStoriesAsyncWithHttpInfo
     *
     * Get External Link Stories
     *
     * @param GetExternalLinkStoriesParams $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getExternalLinkStoriesAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->getExternalLinkStoriesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getFile
     *
     * Get File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return UploadedFile
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getFile($filePublicId)
    {
        list($response) = $this->getFileWithHttpInfo($filePublicId);
        return $response;
    }

    /**
     * Operation getFileWithHttpInfo
     *
     * Get File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getFileWithHttpInfo($filePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->getFileRequest($filePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getFile'
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getFileRequest($filePublicId)
    {
        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling getFile'
            );
        }

        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileAsync
     *
     * Get File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getFileAsync($filePublicId)
    {
        return $this->getFileAsyncWithHttpInfo($filePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAsyncWithHttpInfo
     *
     * Get File
     *
     * @param int $filePublicId The File’s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getFileAsyncWithHttpInfo($filePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->getFileRequest($filePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getGroup
     *
     * Get Group
     *
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return Group
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getGroup($groupPublicId)
    {
        list($response) = $this->getGroupWithHttpInfo($groupPublicId);
        return $response;
    }

    /**
     * Operation getGroupWithHttpInfo
     *
     * Get Group
     *
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Group, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getGroupWithHttpInfo($groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->getGroupRequest($groupPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getGroup'
     *
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getGroupRequest($groupPublicId)
    {
        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling getGroup'
            );
        }

        $resourcePath = '/api/v3/groups/{group-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupAsync
     *
     * Get Group
     *
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getGroupAsync($groupPublicId)
    {
        return $this->getGroupAsyncWithHttpInfo($groupPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupAsyncWithHttpInfo
     *
     * Get Group
     *
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getGroupAsyncWithHttpInfo($groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->getGroupRequest($groupPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getIteration
     *
     * Get Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Iteration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getIteration($iterationPublicId)
    {
        list($response) = $this->getIterationWithHttpInfo($iterationPublicId);
        return $response;
    }

    /**
     * Operation getIterationWithHttpInfo
     *
     * Get Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getIterationWithHttpInfo($iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->getIterationRequest($iterationPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getIteration'
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getIterationRequest($iterationPublicId)
    {
        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling getIteration'
            );
        }

        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIterationAsync
     *
     * Get Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getIterationAsync($iterationPublicId)
    {
        return $this->getIterationAsyncWithHttpInfo($iterationPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIterationAsyncWithHttpInfo
     *
     * Get Iteration
     *
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getIterationAsyncWithHttpInfo($iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->getIterationRequest($iterationPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getLabel
     *
     * Get Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return Label
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getLabel($labelPublicId)
    {
        list($response) = $this->getLabelWithHttpInfo($labelPublicId);
        return $response;
    }

    /**
     * Operation getLabelWithHttpInfo
     *
     * Get Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getLabelWithHttpInfo($labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->getLabelRequest($labelPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getLabel'
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getLabelRequest($labelPublicId)
    {
        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling getLabel'
            );
        }

        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLabelAsync
     *
     * Get Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getLabelAsync($labelPublicId)
    {
        return $this->getLabelAsyncWithHttpInfo($labelPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLabelAsyncWithHttpInfo
     *
     * Get Label
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getLabelAsyncWithHttpInfo($labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->getLabelRequest($labelPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getLinkedFile
     *
     * Get Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return LinkedFile
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getLinkedFile($linkedFilePublicId)
    {
        list($response) = $this->getLinkedFileWithHttpInfo($linkedFilePublicId);
        return $response;
    }

    /**
     * Operation getLinkedFileWithHttpInfo
     *
     * Get Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getLinkedFileWithHttpInfo($linkedFilePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->getLinkedFileRequest($linkedFilePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getLinkedFile'
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getLinkedFileRequest($linkedFilePublicId)
    {
        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling getLinkedFile'
            );
        }

        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLinkedFileAsync
     *
     * Get Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getLinkedFileAsync($linkedFilePublicId)
    {
        return $this->getLinkedFileAsyncWithHttpInfo($linkedFilePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkedFileAsyncWithHttpInfo
     *
     * Get Linked File
     *
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getLinkedFileAsyncWithHttpInfo($linkedFilePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->getLinkedFileRequest($linkedFilePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getMember
     *
     * Get Member
     *
     * @param GetMember $body body (required)
     * @param string $memberPublicId The Member&#x27;s unique ID. (required)
     *
     * @return Member
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getMember($body, $memberPublicId)
    {
        list($response) = $this->getMemberWithHttpInfo($body, $memberPublicId);
        return $response;
    }

    /**
     * Operation getMemberWithHttpInfo
     *
     * Get Member
     *
     * @param GetMember $body (required)
     * @param string $memberPublicId The Member&#x27;s unique ID. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Member, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getMemberWithHttpInfo($body, $memberPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member';
        $request = $this->getMemberRequest($body, $memberPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Member',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getMember'
     *
     * @param GetMember $body (required)
     * @param string $memberPublicId The Member&#x27;s unique ID. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getMemberRequest($body, $memberPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling getMember'
            );
        }
        // verify the required parameter 'memberPublicId' is set
        if ($memberPublicId === null || (is_array($memberPublicId) && count($memberPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $memberPublicId when calling getMember'
            );
        }

        $resourcePath = '/api/v3/members/{member-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($memberPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'member-public-id' . '}',
                ObjectSerializer::toPathValue($memberPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMemberAsync
     *
     * Get Member
     *
     * @param GetMember $body (required)
     * @param string $memberPublicId The Member&#x27;s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getMemberAsync($body, $memberPublicId)
    {
        return $this->getMemberAsyncWithHttpInfo($body, $memberPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMemberAsyncWithHttpInfo
     *
     * Get Member
     *
     * @param GetMember $body (required)
     * @param string $memberPublicId The Member&#x27;s unique ID. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getMemberAsyncWithHttpInfo($body, $memberPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member';
        $request = $this->getMemberRequest($body, $memberPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getMilestone
     *
     * Get Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Milestone
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getMilestone($milestonePublicId)
    {
        list($response) = $this->getMilestoneWithHttpInfo($milestonePublicId);
        return $response;
    }

    /**
     * Operation getMilestoneWithHttpInfo
     *
     * Get Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getMilestoneWithHttpInfo($milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->getMilestoneRequest($milestonePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getMilestone'
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getMilestoneRequest($milestonePublicId)
    {
        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling getMilestone'
            );
        }

        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMilestoneAsync
     *
     * Get Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getMilestoneAsync($milestonePublicId)
    {
        return $this->getMilestoneAsyncWithHttpInfo($milestonePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMilestoneAsyncWithHttpInfo
     *
     * Get Milestone
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getMilestoneAsyncWithHttpInfo($milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->getMilestoneRequest($milestonePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getProject
     *
     * Get Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Project
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getProject($projectPublicId)
    {
        list($response) = $this->getProjectWithHttpInfo($projectPublicId);
        return $response;
    }

    /**
     * Operation getProjectWithHttpInfo
     *
     * Get Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getProjectWithHttpInfo($projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->getProjectRequest($projectPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getProject'
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getProjectRequest($projectPublicId)
    {
        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling getProject'
            );
        }

        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProjectAsync
     *
     * Get Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getProjectAsync($projectPublicId)
    {
        return $this->getProjectAsyncWithHttpInfo($projectPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProjectAsyncWithHttpInfo
     *
     * Get Project
     *
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getProjectAsyncWithHttpInfo($projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->getProjectRequest($projectPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getRepository
     *
     * Get Repository
     *
     * @param int $repoPublicId The unique ID of the Repository. (required)
     *
     * @return Repository
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getRepository($repoPublicId)
    {
        list($response) = $this->getRepositoryWithHttpInfo($repoPublicId);
        return $response;
    }

    /**
     * Operation getRepositoryWithHttpInfo
     *
     * Get Repository
     *
     * @param int $repoPublicId The unique ID of the Repository. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Repository, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getRepositoryWithHttpInfo($repoPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository';
        $request = $this->getRepositoryRequest($repoPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Repository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getRepository'
     *
     * @param int $repoPublicId The unique ID of the Repository. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getRepositoryRequest($repoPublicId)
    {
        // verify the required parameter 'repoPublicId' is set
        if ($repoPublicId === null || (is_array($repoPublicId) && count($repoPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $repoPublicId when calling getRepository'
            );
        }

        $resourcePath = '/api/v3/repositories/{repo-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repoPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'repo-public-id' . '}',
                ObjectSerializer::toPathValue($repoPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRepositoryAsync
     *
     * Get Repository
     *
     * @param int $repoPublicId The unique ID of the Repository. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getRepositoryAsync($repoPublicId)
    {
        return $this->getRepositoryAsyncWithHttpInfo($repoPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepositoryAsyncWithHttpInfo
     *
     * Get Repository
     *
     * @param int $repoPublicId The unique ID of the Repository. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getRepositoryAsyncWithHttpInfo($repoPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository';
        $request = $this->getRepositoryRequest($repoPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getStory
     *
     * Get Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return Story
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStory($storyPublicId)
    {
        list($response) = $this->getStoryWithHttpInfo($storyPublicId);
        return $response;
    }

    /**
     * Operation getStoryWithHttpInfo
     *
     * Get Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStoryWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->getStoryRequest($storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getStory'
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getStoryRequest($storyPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getStory'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStoryAsync
     *
     * Get Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryAsync($storyPublicId)
    {
        return $this->getStoryAsyncWithHttpInfo($storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryAsyncWithHttpInfo
     *
     * Get Story
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryAsyncWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->getStoryRequest($storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getStoryComment
     *
     * Get Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return StoryComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStoryComment($storyPublicId, $commentPublicId)
    {
        list($response) = $this->getStoryCommentWithHttpInfo($storyPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation getStoryCommentWithHttpInfo
     *
     * Get Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStoryCommentWithHttpInfo($storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->getStoryCommentRequest($storyPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getStoryComment'
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getStoryCommentRequest($storyPublicId, $commentPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getStoryComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling getStoryComment'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStoryCommentAsync
     *
     * Get Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryCommentAsync($storyPublicId, $commentPublicId)
    {
        return $this->getStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryCommentAsyncWithHttpInfo
     *
     * Get Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->getStoryCommentRequest($storyPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getStoryLink
     *
     * Get Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return StoryLink
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStoryLink($storyLinkPublicId)
    {
        list($response) = $this->getStoryLinkWithHttpInfo($storyLinkPublicId);
        return $response;
    }

    /**
     * Operation getStoryLinkWithHttpInfo
     *
     * Get Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getStoryLinkWithHttpInfo($storyLinkPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->getStoryLinkRequest($storyLinkPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getStoryLink'
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getStoryLinkRequest($storyLinkPublicId)
    {
        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling getStoryLink'
            );
        }

        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStoryLinkAsync
     *
     * Get Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryLinkAsync($storyLinkPublicId)
    {
        return $this->getStoryLinkAsyncWithHttpInfo($storyLinkPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryLinkAsyncWithHttpInfo
     *
     * Get Story Link
     *
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getStoryLinkAsyncWithHttpInfo($storyLinkPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->getStoryLinkRequest($storyLinkPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getTask
     *
     * Get Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return Task
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getTask($storyPublicId, $taskPublicId)
    {
        list($response) = $this->getTaskWithHttpInfo($storyPublicId, $taskPublicId);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * Get Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getTaskWithHttpInfo($storyPublicId, $taskPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->getTaskRequest($storyPublicId, $taskPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getTaskRequest($storyPublicId, $taskPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getTask'
            );
        }
        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling getTask'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskAsync
     *
     * Get Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getTaskAsync($storyPublicId, $taskPublicId)
    {
        return $this->getTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * Get Task
     *
     * @param int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param int $taskPublicId The unique ID of the Task. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->getTaskRequest($storyPublicId, $taskPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation getWorkflow
     *
     * Get Workflow
     *
     * @param int $workflowPublicId The ID of the Workflow. (required)
     *
     * @return Workflow
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getWorkflow($workflowPublicId)
    {
        list($response) = $this->getWorkflowWithHttpInfo($workflowPublicId);
        return $response;
    }

    /**
     * Operation getWorkflowWithHttpInfo
     *
     * Get Workflow
     *
     * @param int $workflowPublicId The ID of the Workflow. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Workflow, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function getWorkflowWithHttpInfo($workflowPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow';
        $request = $this->getWorkflowRequest($workflowPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Workflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'getWorkflow'
     *
     * @param int $workflowPublicId The ID of the Workflow. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function getWorkflowRequest($workflowPublicId)
    {
        // verify the required parameter 'workflowPublicId' is set
        if ($workflowPublicId === null || (is_array($workflowPublicId) && count($workflowPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $workflowPublicId when calling getWorkflow'
            );
        }

        $resourcePath = '/api/v3/workflows/{workflow-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($workflowPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow-public-id' . '}',
                ObjectSerializer::toPathValue($workflowPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWorkflowAsync
     *
     * Get Workflow
     *
     * @param int $workflowPublicId The ID of the Workflow. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getWorkflowAsync($workflowPublicId)
    {
        return $this->getWorkflowAsyncWithHttpInfo($workflowPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWorkflowAsyncWithHttpInfo
     *
     * Get Workflow
     *
     * @param int $workflowPublicId The ID of the Workflow. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function getWorkflowAsyncWithHttpInfo($workflowPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow';
        $request = $this->getWorkflowRequest($workflowPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listCategories
     *
     * List Categories
     *
     *
     * @return Category[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCategories()
    {
        list($response) = $this->listCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listCategoriesWithHttpInfo
     *
     * List Categories
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCategoriesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category[]';
        $request = $this->listCategoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listCategories'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listCategoriesRequest()
    {

        $resourcePath = '/api/v3/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategoriesAsync
     *
     * List Categories
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCategoriesAsync()
    {
        return $this->listCategoriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoriesAsyncWithHttpInfo
     *
     * List Categories
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCategoriesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category[]';
        $request = $this->listCategoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listCategoryMilestones
     *
     * List Category Milestones
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return Milestone[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCategoryMilestones($categoryPublicId)
    {
        list($response) = $this->listCategoryMilestonesWithHttpInfo($categoryPublicId);
        return $response;
    }

    /**
     * Operation listCategoryMilestonesWithHttpInfo
     *
     * List Category Milestones
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCategoryMilestonesWithHttpInfo($categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listCategoryMilestonesRequest($categoryPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listCategoryMilestones'
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listCategoryMilestonesRequest($categoryPublicId)
    {
        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling listCategoryMilestones'
            );
        }

        $resourcePath = '/api/v3/categories/{category-public-id}/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategoryMilestonesAsync
     *
     * List Category Milestones
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCategoryMilestonesAsync($categoryPublicId)
    {
        return $this->listCategoryMilestonesAsyncWithHttpInfo($categoryPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryMilestonesAsyncWithHttpInfo
     *
     * List Category Milestones
     *
     * @param int $categoryPublicId The unique ID of the Category. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCategoryMilestonesAsyncWithHttpInfo($categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listCategoryMilestonesRequest($categoryPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listCustomFields
     *
     * List Custom Fields
     *
     *
     * @return CustomField[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCustomFields()
    {
        list($response) = $this->listCustomFieldsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listCustomFieldsWithHttpInfo
     *
     * List Custom Fields
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listCustomFieldsWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField[]';
        $request = $this->listCustomFieldsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listCustomFields'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listCustomFieldsRequest()
    {

        $resourcePath = '/api/v3/custom-fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCustomFieldsAsync
     *
     * List Custom Fields
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCustomFieldsAsync()
    {
        return $this->listCustomFieldsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCustomFieldsAsyncWithHttpInfo
     *
     * List Custom Fields
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listCustomFieldsAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField[]';
        $request = $this->listCustomFieldsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listEntityTemplates
     *
     * List Entity Templates
     *
     *
     * @return EntityTemplate[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEntityTemplates()
    {
        list($response) = $this->listEntityTemplatesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listEntityTemplatesWithHttpInfo
     *
     * List Entity Templates
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEntityTemplatesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate[]';
        $request = $this->listEntityTemplatesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listEntityTemplates'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listEntityTemplatesRequest()
    {

        $resourcePath = '/api/v3/entity-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEntityTemplatesAsync
     *
     * List Entity Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEntityTemplatesAsync()
    {
        return $this->listEntityTemplatesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEntityTemplatesAsyncWithHttpInfo
     *
     * List Entity Templates
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEntityTemplatesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate[]';
        $request = $this->listEntityTemplatesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listEpicComments
     *
     * List Epic Comments
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return ThreadedComment[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpicComments($epicPublicId)
    {
        list($response) = $this->listEpicCommentsWithHttpInfo($epicPublicId);
        return $response;
    }

    /**
     * Operation listEpicCommentsWithHttpInfo
     *
     * List Epic Comments
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpicCommentsWithHttpInfo($epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment[]';
        $request = $this->listEpicCommentsRequest($epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listEpicComments'
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listEpicCommentsRequest($epicPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling listEpicComments'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicCommentsAsync
     *
     * List Epic Comments
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicCommentsAsync($epicPublicId)
    {
        return $this->listEpicCommentsAsyncWithHttpInfo($epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicCommentsAsyncWithHttpInfo
     *
     * List Epic Comments
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicCommentsAsyncWithHttpInfo($epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment[]';
        $request = $this->listEpicCommentsRequest($epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listEpicStories
     *
     * List Epic Stories
     *
     * @param GetEpicStories $body body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpicStories($body, $epicPublicId)
    {
        list($response) = $this->listEpicStoriesWithHttpInfo($body, $epicPublicId);
        return $response;
    }

    /**
     * Operation listEpicStoriesWithHttpInfo
     *
     * List Epic Stories
     *
     * @param GetEpicStories $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpicStoriesWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listEpicStoriesRequest($body, $epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listEpicStories'
     *
     * @param GetEpicStories $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listEpicStoriesRequest($body, $epicPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listEpicStories'
            );
        }
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling listEpicStories'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicStoriesAsync
     *
     * List Epic Stories
     *
     * @param GetEpicStories $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicStoriesAsync($body, $epicPublicId)
    {
        return $this->listEpicStoriesAsyncWithHttpInfo($body, $epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicStoriesAsyncWithHttpInfo
     *
     * List Epic Stories
     *
     * @param GetEpicStories $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicStoriesAsyncWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listEpicStoriesRequest($body, $epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listEpics
     *
     * List Epics
     *
     * @param ListEpics $body body (required)
     *
     * @return EpicSlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpics($body)
    {
        list($response) = $this->listEpicsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation listEpicsWithHttpInfo
     *
     * List Epics
     *
     * @param ListEpics $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listEpicsWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listEpicsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listEpics'
     *
     * @param ListEpics $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listEpicsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listEpics'
            );
        }

        $resourcePath = '/api/v3/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicsAsync
     *
     * List Epics
     *
     * @param ListEpics $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicsAsync($body)
    {
        return $this->listEpicsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicsAsyncWithHttpInfo
     *
     * List Epics
     *
     * @param ListEpics $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listEpicsAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listEpicsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listFiles
     *
     * List Files
     *
     *
     * @return UploadedFile[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listFiles()
    {
        list($response) = $this->listFilesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listFilesWithHttpInfo
     *
     * List Files
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listFilesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->listFilesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listFiles'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listFilesRequest()
    {

        $resourcePath = '/api/v3/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFilesAsync
     *
     * List Files
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listFilesAsync()
    {
        return $this->listFilesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFilesAsyncWithHttpInfo
     *
     * List Files
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listFilesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->listFilesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listGroupStories
     *
     * List Group Stories
     *
     * @param ListGroupStories $body body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listGroupStories($body, $groupPublicId)
    {
        list($response) = $this->listGroupStoriesWithHttpInfo($body, $groupPublicId);
        return $response;
    }

    /**
     * Operation listGroupStoriesWithHttpInfo
     *
     * List Group Stories
     *
     * @param ListGroupStories $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listGroupStoriesWithHttpInfo($body, $groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listGroupStoriesRequest($body, $groupPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listGroupStories'
     *
     * @param ListGroupStories $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listGroupStoriesRequest($body, $groupPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listGroupStories'
            );
        }
        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling listGroupStories'
            );
        }

        $resourcePath = '/api/v3/groups/{group-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGroupStoriesAsync
     *
     * List Group Stories
     *
     * @param ListGroupStories $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listGroupStoriesAsync($body, $groupPublicId)
    {
        return $this->listGroupStoriesAsyncWithHttpInfo($body, $groupPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGroupStoriesAsyncWithHttpInfo
     *
     * List Group Stories
     *
     * @param ListGroupStories $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listGroupStoriesAsyncWithHttpInfo($body, $groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listGroupStoriesRequest($body, $groupPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listGroups
     *
     * List Groups
     *
     *
     * @return Group[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listGroups()
    {
        list($response) = $this->listGroupsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listGroupsWithHttpInfo
     *
     * List Groups
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listGroupsWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group[]';
        $request = $this->listGroupsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listGroups'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listGroupsRequest()
    {

        $resourcePath = '/api/v3/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGroupsAsync
     *
     * List Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listGroupsAsync()
    {
        return $this->listGroupsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGroupsAsyncWithHttpInfo
     *
     * List Groups
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listGroupsAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group[]';
        $request = $this->listGroupsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listIterationStories
     *
     * List Iteration Stories
     *
     * @param GetIterationStories $body body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listIterationStories($body, $iterationPublicId)
    {
        list($response) = $this->listIterationStoriesWithHttpInfo($body, $iterationPublicId);
        return $response;
    }

    /**
     * Operation listIterationStoriesWithHttpInfo
     *
     * List Iteration Stories
     *
     * @param GetIterationStories $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listIterationStoriesWithHttpInfo($body, $iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listIterationStoriesRequest($body, $iterationPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listIterationStories'
     *
     * @param GetIterationStories $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listIterationStoriesRequest($body, $iterationPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listIterationStories'
            );
        }
        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling listIterationStories'
            );
        }

        $resourcePath = '/api/v3/iterations/{iteration-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIterationStoriesAsync
     *
     * List Iteration Stories
     *
     * @param GetIterationStories $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listIterationStoriesAsync($body, $iterationPublicId)
    {
        return $this->listIterationStoriesAsyncWithHttpInfo($body, $iterationPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIterationStoriesAsyncWithHttpInfo
     *
     * List Iteration Stories
     *
     * @param GetIterationStories $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listIterationStoriesAsyncWithHttpInfo($body, $iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listIterationStoriesRequest($body, $iterationPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listIterations
     *
     * List Iterations
     *
     *
     * @return IterationSlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listIterations()
    {
        list($response) = $this->listIterationsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listIterationsWithHttpInfo
     *
     * List Iterations
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\IterationSlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listIterationsWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSlim[]';
        $request = $this->listIterationsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\IterationSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listIterations'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listIterationsRequest()
    {

        $resourcePath = '/api/v3/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIterationsAsync
     *
     * List Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listIterationsAsync()
    {
        return $this->listIterationsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIterationsAsyncWithHttpInfo
     *
     * List Iterations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listIterationsAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSlim[]';
        $request = $this->listIterationsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listLabelEpics
     *
     * List Label Epics
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return EpicSlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabelEpics($labelPublicId)
    {
        list($response) = $this->listLabelEpicsWithHttpInfo($labelPublicId);
        return $response;
    }

    /**
     * Operation listLabelEpicsWithHttpInfo
     *
     * List Label Epics
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabelEpicsWithHttpInfo($labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listLabelEpicsRequest($labelPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listLabelEpics'
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listLabelEpicsRequest($labelPublicId)
    {
        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling listLabelEpics'
            );
        }

        $resourcePath = '/api/v3/labels/{label-public-id}/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabelEpicsAsync
     *
     * List Label Epics
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelEpicsAsync($labelPublicId)
    {
        return $this->listLabelEpicsAsyncWithHttpInfo($labelPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelEpicsAsyncWithHttpInfo
     *
     * List Label Epics
     *
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelEpicsAsyncWithHttpInfo($labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listLabelEpicsRequest($labelPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listLabelStories
     *
     * List Label Stories
     *
     * @param GetLabelStories $body body (required)
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabelStories($body, $labelPublicId)
    {
        list($response) = $this->listLabelStoriesWithHttpInfo($body, $labelPublicId);
        return $response;
    }

    /**
     * Operation listLabelStoriesWithHttpInfo
     *
     * List Label Stories
     *
     * @param GetLabelStories $body (required)
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabelStoriesWithHttpInfo($body, $labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listLabelStoriesRequest($body, $labelPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listLabelStories'
     *
     * @param GetLabelStories $body (required)
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listLabelStoriesRequest($body, $labelPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listLabelStories'
            );
        }
        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling listLabelStories'
            );
        }

        $resourcePath = '/api/v3/labels/{label-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabelStoriesAsync
     *
     * List Label Stories
     *
     * @param GetLabelStories $body (required)
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelStoriesAsync($body, $labelPublicId)
    {
        return $this->listLabelStoriesAsyncWithHttpInfo($body, $labelPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelStoriesAsyncWithHttpInfo
     *
     * List Label Stories
     *
     * @param GetLabelStories $body (required)
     * @param int $labelPublicId The unique ID of the Label. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelStoriesAsyncWithHttpInfo($body, $labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listLabelStoriesRequest($body, $labelPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listLabels
     *
     * List Labels
     *
     * @param ListLabels $body body (required)
     *
     * @return Label[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabels($body)
    {
        list($response) = $this->listLabelsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation listLabelsWithHttpInfo
     *
     * List Labels
     *
     * @param ListLabels $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLabelsWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label[]';
        $request = $this->listLabelsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listLabels'
     *
     * @param ListLabels $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listLabelsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listLabels'
            );
        }

        $resourcePath = '/api/v3/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabelsAsync
     *
     * List Labels
     *
     * @param ListLabels $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelsAsync($body)
    {
        return $this->listLabelsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelsAsyncWithHttpInfo
     *
     * List Labels
     *
     * @param ListLabels $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLabelsAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label[]';
        $request = $this->listLabelsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listLinkedFiles
     *
     * List Linked Files
     *
     *
     * @return LinkedFile[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLinkedFiles()
    {
        list($response) = $this->listLinkedFilesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listLinkedFilesWithHttpInfo
     *
     * List Linked Files
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listLinkedFilesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile[]';
        $request = $this->listLinkedFilesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listLinkedFiles'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listLinkedFilesRequest()
    {

        $resourcePath = '/api/v3/linked-files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLinkedFilesAsync
     *
     * List Linked Files
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLinkedFilesAsync()
    {
        return $this->listLinkedFilesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLinkedFilesAsyncWithHttpInfo
     *
     * List Linked Files
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listLinkedFilesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile[]';
        $request = $this->listLinkedFilesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listMembers
     *
     * List Members
     *
     * @param ListMembers $body body (required)
     *
     * @return Member[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMembers($body)
    {
        list($response) = $this->listMembersWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation listMembersWithHttpInfo
     *
     * List Members
     *
     * @param ListMembers $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Member[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMembersWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member[]';
        $request = $this->listMembersRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Member[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listMembers'
     *
     * @param ListMembers $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listMembersRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listMembers'
            );
        }

        $resourcePath = '/api/v3/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembersAsync
     *
     * List Members
     *
     * @param ListMembers $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMembersAsync($body)
    {
        return $this->listMembersAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List Members
     *
     * @param ListMembers $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMembersAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member[]';
        $request = $this->listMembersRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listMilestoneEpics
     *
     * List Milestone Epics
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return EpicSlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMilestoneEpics($milestonePublicId)
    {
        list($response) = $this->listMilestoneEpicsWithHttpInfo($milestonePublicId);
        return $response;
    }

    /**
     * Operation listMilestoneEpicsWithHttpInfo
     *
     * List Milestone Epics
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMilestoneEpicsWithHttpInfo($milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listMilestoneEpicsRequest($milestonePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listMilestoneEpics'
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listMilestoneEpicsRequest($milestonePublicId)
    {
        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling listMilestoneEpics'
            );
        }

        $resourcePath = '/api/v3/milestones/{milestone-public-id}/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMilestoneEpicsAsync
     *
     * List Milestone Epics
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMilestoneEpicsAsync($milestonePublicId)
    {
        return $this->listMilestoneEpicsAsyncWithHttpInfo($milestonePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMilestoneEpicsAsyncWithHttpInfo
     *
     * List Milestone Epics
     *
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMilestoneEpicsAsyncWithHttpInfo($milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listMilestoneEpicsRequest($milestonePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listMilestones
     *
     * List Milestones
     *
     *
     * @return Milestone[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMilestones()
    {
        list($response) = $this->listMilestonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listMilestonesWithHttpInfo
     *
     * List Milestones
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listMilestonesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listMilestonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listMilestones'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listMilestonesRequest()
    {

        $resourcePath = '/api/v3/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMilestonesAsync
     *
     * List Milestones
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMilestonesAsync()
    {
        return $this->listMilestonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMilestonesAsyncWithHttpInfo
     *
     * List Milestones
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listMilestonesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listMilestonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listProjects
     *
     * List Projects
     *
     *
     * @return Project[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listProjects()
    {
        list($response) = $this->listProjectsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listProjectsWithHttpInfo
     *
     * List Projects
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listProjectsWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project[]';
        $request = $this->listProjectsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listProjects'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listProjectsRequest()
    {

        $resourcePath = '/api/v3/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProjectsAsync
     *
     * List Projects
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listProjectsAsync()
    {
        return $this->listProjectsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProjectsAsyncWithHttpInfo
     *
     * List Projects
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listProjectsAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project[]';
        $request = $this->listProjectsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listRepositories
     *
     * List Repositories
     *
     *
     * @return Repository[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listRepositories()
    {
        list($response) = $this->listRepositoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listRepositoriesWithHttpInfo
     *
     * List Repositories
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Repository[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listRepositoriesWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository[]';
        $request = $this->listRepositoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Repository[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listRepositories'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listRepositoriesRequest()
    {

        $resourcePath = '/api/v3/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRepositoriesAsync
     *
     * List Repositories
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listRepositoriesAsync()
    {
        return $this->listRepositoriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRepositoriesAsyncWithHttpInfo
     *
     * List Repositories
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listRepositoriesAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository[]';
        $request = $this->listRepositoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listStories
     *
     * List Stories
     *
     * @param GetProjectStories $body body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listStories($body, $projectPublicId)
    {
        list($response) = $this->listStoriesWithHttpInfo($body, $projectPublicId);
        return $response;
    }

    /**
     * Operation listStoriesWithHttpInfo
     *
     * List Stories
     *
     * @param GetProjectStories $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listStoriesWithHttpInfo($body, $projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listStoriesRequest($body, $projectPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listStories'
     *
     * @param GetProjectStories $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listStoriesRequest($body, $projectPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling listStories'
            );
        }
        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling listStories'
            );
        }

        $resourcePath = '/api/v3/projects/{project-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStoriesAsync
     *
     * List Stories
     *
     * @param GetProjectStories $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listStoriesAsync($body, $projectPublicId)
    {
        return $this->listStoriesAsyncWithHttpInfo($body, $projectPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStoriesAsyncWithHttpInfo
     *
     * List Stories
     *
     * @param GetProjectStories $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listStoriesAsyncWithHttpInfo($body, $projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listStoriesRequest($body, $projectPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listStoryComment
     *
     * List Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return StoryComment[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listStoryComment($storyPublicId)
    {
        list($response) = $this->listStoryCommentWithHttpInfo($storyPublicId);
        return $response;
    }

    /**
     * Operation listStoryCommentWithHttpInfo
     *
     * List Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryComment[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listStoryCommentWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment[]';
        $request = $this->listStoryCommentRequest($storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listStoryComment'
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listStoryCommentRequest($storyPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling listStoryComment'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStoryCommentAsync
     *
     * List Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listStoryCommentAsync($storyPublicId)
    {
        return $this->listStoryCommentAsyncWithHttpInfo($storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStoryCommentAsyncWithHttpInfo
     *
     * List Story Comment
     *
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listStoryCommentAsyncWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment[]';
        $request = $this->listStoryCommentRequest($storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation listWorkflows
     *
     * List Workflows
     *
     *
     * @return Workflow[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listWorkflows()
    {
        list($response) = $this->listWorkflowsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listWorkflowsWithHttpInfo
     *
     * List Workflows
     *
     *
     * @return array of \Timetoreply\Shortcut\Model\Workflow[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function listWorkflowsWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow[]';
        $request = $this->listWorkflowsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Workflow[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'listWorkflows'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function listWorkflowsRequest()
    {

        $resourcePath = '/api/v3/workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWorkflowsAsync
     *
     * List Workflows
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listWorkflowsAsync()
    {
        return $this->listWorkflowsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWorkflowsAsyncWithHttpInfo
     *
     * List Workflows
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function listWorkflowsAsyncWithHttpInfo()
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow[]';
        $request = $this->listWorkflowsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param Search $body body (required)
     *
     * @return SearchResults
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function search($body)
    {
        list($response) = $this->searchWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param Search $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\SearchResults, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\SearchResults';
        $request = $this->searchRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\SearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'search'
     *
     * @param Search $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling search'
            );
        }

        $resourcePath = '/api/v3/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchAsync($body)
    {
        return $this->searchAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\SearchResults';
        $request = $this->searchRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation searchEpics
     *
     * Search Epics
     *
     * @param Search $body body (required)
     *
     * @return EpicSearchResults
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchEpics($body)
    {
        list($response) = $this->searchEpicsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchEpicsWithHttpInfo
     *
     * Search Epics
     *
     * @param Search $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\EpicSearchResults, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchEpicsWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSearchResults';
        $request = $this->searchEpicsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'searchEpics'
     *
     * @param Search $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchEpicsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling searchEpics'
            );
        }

        $resourcePath = '/api/v3/search/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchEpicsAsync
     *
     * Search Epics
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchEpicsAsync($body)
    {
        return $this->searchEpicsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchEpicsAsyncWithHttpInfo
     *
     * Search Epics
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchEpicsAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSearchResults';
        $request = $this->searchEpicsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation searchIterations
     *
     * Search Iterations
     *
     * @param Search $body body (required)
     *
     * @return IterationSearchResults
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchIterations($body)
    {
        list($response) = $this->searchIterationsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchIterationsWithHttpInfo
     *
     * Search Iterations
     *
     * @param Search $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\IterationSearchResults, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchIterationsWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSearchResults';
        $request = $this->searchIterationsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\IterationSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'searchIterations'
     *
     * @param Search $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchIterationsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling searchIterations'
            );
        }

        $resourcePath = '/api/v3/search/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchIterationsAsync
     *
     * Search Iterations
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchIterationsAsync($body)
    {
        return $this->searchIterationsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchIterationsAsyncWithHttpInfo
     *
     * Search Iterations
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchIterationsAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSearchResults';
        $request = $this->searchIterationsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation searchMilestones
     *
     * Search Milestones
     *
     * @param Search $body body (required)
     *
     * @return MilestoneSearchResults
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchMilestones($body)
    {
        list($response) = $this->searchMilestonesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchMilestonesWithHttpInfo
     *
     * Search Milestones
     *
     * @param Search $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\MilestoneSearchResults, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchMilestonesWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\MilestoneSearchResults';
        $request = $this->searchMilestonesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MilestoneSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'searchMilestones'
     *
     * @param Search $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchMilestonesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling searchMilestones'
            );
        }

        $resourcePath = '/api/v3/search/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMilestonesAsync
     *
     * Search Milestones
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchMilestonesAsync($body)
    {
        return $this->searchMilestonesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMilestonesAsyncWithHttpInfo
     *
     * Search Milestones
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchMilestonesAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\MilestoneSearchResults';
        $request = $this->searchMilestonesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation searchStories
     *
     * Search Stories
     *
     * @param Search $body body (required)
     *
     * @return StorySearchResults
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchStories($body)
    {
        list($response) = $this->searchStoriesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchStoriesWithHttpInfo
     *
     * Search Stories
     *
     * @param Search $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySearchResults, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchStoriesWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySearchResults';
        $request = $this->searchStoriesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'searchStories'
     *
     * @param Search $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchStoriesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling searchStories'
            );
        }

        $resourcePath = '/api/v3/search/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStoriesAsync
     *
     * Search Stories
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchStoriesAsync($body)
    {
        return $this->searchStoriesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStoriesAsyncWithHttpInfo
     *
     * Search Stories
     *
     * @param Search $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchStoriesAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySearchResults';
        $request = $this->searchStoriesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation searchStoriesOld
     *
     * Search Stories (Old)
     *
     * @param SearchStories $body body (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchStoriesOld($body)
    {
        list($response) = $this->searchStoriesOldWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation searchStoriesOldWithHttpInfo
     *
     * Search Stories (Old)
     *
     * @param SearchStories $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function searchStoriesOldWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->searchStoriesOldRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'searchStoriesOld'
     *
     * @param SearchStories $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function searchStoriesOldRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling searchStoriesOld'
            );
        }

        $resourcePath = '/api/v3/stories/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStoriesOldAsync
     *
     * Search Stories (Old)
     *
     * @param SearchStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchStoriesOldAsync($body)
    {
        return $this->searchStoriesOldAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStoriesOldAsyncWithHttpInfo
     *
     * Search Stories (Old)
     *
     * @param SearchStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function searchStoriesOldAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->searchStoriesOldRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation storyHistory
     *
     * Story History
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return History[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function storyHistory($storyPublicId)
    {
        list($response) = $this->storyHistoryWithHttpInfo($storyPublicId);
        return $response;
    }

    /**
     * Operation storyHistoryWithHttpInfo
     *
     * Story History
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\History[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function storyHistoryWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\History[]';
        $request = $this->storyHistoryRequest($storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\History[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'storyHistory'
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function storyHistoryRequest($storyPublicId)
    {
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling storyHistory'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storyHistoryAsync
     *
     * Story History
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function storyHistoryAsync($storyPublicId)
    {
        return $this->storyHistoryAsyncWithHttpInfo($storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storyHistoryAsyncWithHttpInfo
     *
     * Story History
     *
     * @param int $storyPublicId The ID of the Story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function storyHistoryAsyncWithHttpInfo($storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\History[]';
        $request = $this->storyHistoryRequest($storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation unlinkProductboardFromEpic
     *
     * Unlink Productboard from Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function unlinkProductboardFromEpic($epicPublicId)
    {
        $this->unlinkProductboardFromEpicWithHttpInfo($epicPublicId);
    }

    /**
     * Operation unlinkProductboardFromEpicWithHttpInfo
     *
     * Unlink Productboard from Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function unlinkProductboardFromEpicWithHttpInfo($epicPublicId)
    {
        $returnType = '';
        $request = $this->unlinkProductboardFromEpicRequest($epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'unlinkProductboardFromEpic'
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function unlinkProductboardFromEpicRequest($epicPublicId)
    {
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling unlinkProductboardFromEpic'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/unlink-productboard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkProductboardFromEpicAsync
     *
     * Unlink Productboard from Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function unlinkProductboardFromEpicAsync($epicPublicId)
    {
        return $this->unlinkProductboardFromEpicAsyncWithHttpInfo($epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkProductboardFromEpicAsyncWithHttpInfo
     *
     * Unlink Productboard from Epic
     *
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function unlinkProductboardFromEpicAsyncWithHttpInfo($epicPublicId)
    {
        $returnType = '';
        $request = $this->unlinkProductboardFromEpicRequest($epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateCategory
     *
     * Update Category
     *
     * @param UpdateCategory $body body (required)
     * @param int $categoryPublicId The unique ID of the Category you wish to update. (required)
     *
     * @return Category
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateCategory($body, $categoryPublicId)
    {
        list($response) = $this->updateCategoryWithHttpInfo($body, $categoryPublicId);
        return $response;
    }

    /**
     * Operation updateCategoryWithHttpInfo
     *
     * Update Category
     *
     * @param UpdateCategory $body (required)
     * @param int $categoryPublicId The unique ID of the Category you wish to update. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateCategoryWithHttpInfo($body, $categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->updateCategoryRequest($body, $categoryPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateCategory'
     *
     * @param UpdateCategory $body (required)
     * @param int $categoryPublicId The unique ID of the Category you wish to update. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateCategoryRequest($body, $categoryPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateCategory'
            );
        }
        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling updateCategory'
            );
        }

        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCategoryAsync
     *
     * Update Category
     *
     * @param UpdateCategory $body (required)
     * @param int $categoryPublicId The unique ID of the Category you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateCategoryAsync($body, $categoryPublicId)
    {
        return $this->updateCategoryAsyncWithHttpInfo($body, $categoryPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCategoryAsyncWithHttpInfo
     *
     * Update Category
     *
     * @param UpdateCategory $body (required)
     * @param int $categoryPublicId The unique ID of the Category you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateCategoryAsyncWithHttpInfo($body, $categoryPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->updateCategoryRequest($body, $categoryPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateCustomField
     *
     * Update Custom Field
     *
     * @param UpdateCustomField $body body (required)
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return CustomField
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateCustomField($body, $customFieldPublicId)
    {
        list($response) = $this->updateCustomFieldWithHttpInfo($body, $customFieldPublicId);
        return $response;
    }

    /**
     * Operation updateCustomFieldWithHttpInfo
     *
     * Update Custom Field
     *
     * @param UpdateCustomField $body (required)
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateCustomFieldWithHttpInfo($body, $customFieldPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->updateCustomFieldRequest($body, $customFieldPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DataConflictError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateCustomField'
     *
     * @param UpdateCustomField $body (required)
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateCustomFieldRequest($body, $customFieldPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateCustomField'
            );
        }
        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling updateCustomField'
            );
        }

        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomFieldAsync
     *
     * Update Custom Field
     *
     * @param UpdateCustomField $body (required)
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateCustomFieldAsync($body, $customFieldPublicId)
    {
        return $this->updateCustomFieldAsyncWithHttpInfo($body, $customFieldPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomFieldAsyncWithHttpInfo
     *
     * Update Custom Field
     *
     * @param UpdateCustomField $body (required)
     * @param string $customFieldPublicId The unique ID of the CustomField. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateCustomFieldAsyncWithHttpInfo($body, $customFieldPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->updateCustomFieldRequest($body, $customFieldPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateEntityTemplate
     *
     * Update Entity Template
     *
     * @param UpdateEntityTemplate $body Request parameters for changing either a template&#x27;s name or any of
     * the attributes it is designed to pre-populate. (required)
     * @param string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return EntityTemplate
     */
    public function updateEntityTemplate($body, $entityTemplatePublicId)
    {
        list($response) = $this->updateEntityTemplateWithHttpInfo($body, $entityTemplatePublicId);
        return $response;
    }

    /**
     * Operation updateEntityTemplateWithHttpInfo
     *
     * Update Entity Template
     *
     * @param UpdateEntityTemplate $body Request parameters for changing either a template&#x27;s name or any of
     * the attributes it is designed to pre-populate. (required)
     * @param string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     *
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEntityTemplateWithHttpInfo($body, $entityTemplatePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->updateEntityTemplateRequest($body, $entityTemplatePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateEntityTemplate'
     *
     * @param UpdateEntityTemplate $body Request parameters for changing either a template&#x27;s name or any of
     * the attributes it is designed to pre-populate. (required)
     * @param string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     *
     * @throws InvalidArgumentException
     * @return Request
     */
    protected function updateEntityTemplateRequest($body, $entityTemplatePublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateEntityTemplate'
            );
        }
        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling updateEntityTemplate'
            );
        }

        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEntityTemplateAsync
     *
     * Update Entity Template
     *
     * @param UpdateEntityTemplate $body Request parameters for changing either a template&#x27;s name or any of
     * the attributes it is designed to pre-populate. (required)
     * @param string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateEntityTemplateAsync($body, $entityTemplatePublicId)
    {
        return $this->updateEntityTemplateAsyncWithHttpInfo($body, $entityTemplatePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEntityTemplateAsyncWithHttpInfo
     *
     * Update Entity Template
     *
     * @param UpdateEntityTemplate $body Request parameters for changing either a template&#x27;s name or any of
     * the attributes it is designed to pre-populate. (required)
     * @param string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateEntityTemplateAsyncWithHttpInfo($body, $entityTemplatePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->updateEntityTemplateRequest($body, $entityTemplatePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateEpic
     *
     * Update Epic
     *
     * @param UpdateEpic $body body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Epic
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateEpic($body, $epicPublicId)
    {
        list($response) = $this->updateEpicWithHttpInfo($body, $epicPublicId);
        return $response;
    }

    /**
     * Operation updateEpicWithHttpInfo
     *
     * Update Epic
     *
     * @param UpdateEpic $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateEpicWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->updateEpicRequest($body, $epicPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateEpic'
     *
     * @param UpdateEpic $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateEpicRequest($body, $epicPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateEpic'
            );
        }
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling updateEpic'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEpicAsync
     *
     * Update Epic
     *
     * @param UpdateEpic $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateEpicAsync($body, $epicPublicId)
    {
        return $this->updateEpicAsyncWithHttpInfo($body, $epicPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEpicAsyncWithHttpInfo
     *
     * Update Epic
     *
     * @param UpdateEpic $body (required)
     * @param int $epicPublicId The unique ID of the Epic. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateEpicAsyncWithHttpInfo($body, $epicPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->updateEpicRequest($body, $epicPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateEpicComment
     *
     * Update Epic Comment
     *
     * @param UpdateComment $body body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return ThreadedComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateEpicComment($body, $epicPublicId, $commentPublicId)
    {
        list($response) = $this->updateEpicCommentWithHttpInfo($body, $epicPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation updateEpicCommentWithHttpInfo
     *
     * Update Epic Comment
     *
     * @param UpdateComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateEpicCommentWithHttpInfo($body, $epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->updateEpicCommentRequest($body, $epicPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateEpicComment'
     *
     * @param UpdateComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateEpicCommentRequest($body, $epicPublicId, $commentPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateEpicComment'
            );
        }
        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling updateEpicComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling updateEpicComment'
            );
        }

        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEpicCommentAsync
     *
     * Update Epic Comment
     *
     * @param UpdateComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateEpicCommentAsync($body, $epicPublicId, $commentPublicId)
    {
        return $this->updateEpicCommentAsyncWithHttpInfo($body, $epicPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEpicCommentAsyncWithHttpInfo
     *
     * Update Epic Comment
     *
     * @param UpdateComment $body (required)
     * @param int $epicPublicId The ID of the associated Epic. (required)
     * @param int $commentPublicId The ID of the Comment. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateEpicCommentAsyncWithHttpInfo($body, $epicPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->updateEpicCommentRequest($body, $epicPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateFile
     *
     * Update File
     *
     * @param UpdateFile $body body (required)
     * @param int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     *
     * @return UploadedFile
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateFile($body, $filePublicId)
    {
        list($response) = $this->updateFileWithHttpInfo($body, $filePublicId);
        return $response;
    }

    /**
     * Operation updateFileWithHttpInfo
     *
     * Update File
     *
     * @param UpdateFile $body (required)
     * @param int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateFileWithHttpInfo($body, $filePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->updateFileRequest($body, $filePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateFile'
     *
     * @param UpdateFile $body (required)
     * @param int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateFileRequest($body, $filePublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateFile'
            );
        }
        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling updateFile'
            );
        }

        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFileAsync
     *
     * Update File
     *
     * @param UpdateFile $body (required)
     * @param int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateFileAsync($body, $filePublicId)
    {
        return $this->updateFileAsyncWithHttpInfo($body, $filePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileAsyncWithHttpInfo
     *
     * Update File
     *
     * @param UpdateFile $body (required)
     * @param int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateFileAsyncWithHttpInfo($body, $filePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->updateFileRequest($body, $filePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateGroup
     *
     * Update Group
     *
     * @param UpdateGroup $body body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return Group
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateGroup($body, $groupPublicId)
    {
        list($response) = $this->updateGroupWithHttpInfo($body, $groupPublicId);
        return $response;
    }

    /**
     * Operation updateGroupWithHttpInfo
     *
     * Update Group
     *
     * @param UpdateGroup $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Group, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateGroupWithHttpInfo($body, $groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->updateGroupRequest($body, $groupPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateGroup'
     *
     * @param UpdateGroup $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateGroupRequest($body, $groupPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateGroup'
            );
        }
        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling updateGroup'
            );
        }

        $resourcePath = '/api/v3/groups/{group-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGroupAsync
     *
     * Update Group
     *
     * @param UpdateGroup $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateGroupAsync($body, $groupPublicId)
    {
        return $this->updateGroupAsyncWithHttpInfo($body, $groupPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGroupAsyncWithHttpInfo
     *
     * Update Group
     *
     * @param UpdateGroup $body (required)
     * @param string $groupPublicId The unique ID of the Group. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateGroupAsyncWithHttpInfo($body, $groupPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->updateGroupRequest($body, $groupPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateIteration
     *
     * Update Iteration
     *
     * @param UpdateIteration $body body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Iteration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateIteration($body, $iterationPublicId)
    {
        list($response) = $this->updateIterationWithHttpInfo($body, $iterationPublicId);
        return $response;
    }

    /**
     * Operation updateIterationWithHttpInfo
     *
     * Update Iteration
     *
     * @param UpdateIteration $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateIterationWithHttpInfo($body, $iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->updateIterationRequest($body, $iterationPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateIteration'
     *
     * @param UpdateIteration $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateIterationRequest($body, $iterationPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateIteration'
            );
        }
        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling updateIteration'
            );
        }

        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateIterationAsync
     *
     * Update Iteration
     *
     * @param UpdateIteration $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateIterationAsync($body, $iterationPublicId)
    {
        return $this->updateIterationAsyncWithHttpInfo($body, $iterationPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateIterationAsyncWithHttpInfo
     *
     * Update Iteration
     *
     * @param UpdateIteration $body (required)
     * @param int $iterationPublicId The unique ID of the Iteration. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateIterationAsyncWithHttpInfo($body, $iterationPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->updateIterationRequest($body, $iterationPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateLabel
     *
     * Update Label
     *
     * @param UpdateLabel $body body (required)
     * @param int $labelPublicId The unique ID of the Label you wish to update. (required)
     *
     * @return Label
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateLabel($body, $labelPublicId)
    {
        list($response) = $this->updateLabelWithHttpInfo($body, $labelPublicId);
        return $response;
    }

    /**
     * Operation updateLabelWithHttpInfo
     *
     * Update Label
     *
     * @param UpdateLabel $body (required)
     * @param int $labelPublicId The unique ID of the Label you wish to update. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateLabelWithHttpInfo($body, $labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->updateLabelRequest($body, $labelPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateLabel'
     *
     * @param UpdateLabel $body (required)
     * @param int $labelPublicId The unique ID of the Label you wish to update. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateLabelRequest($body, $labelPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateLabel'
            );
        }
        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling updateLabel'
            );
        }

        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLabelAsync
     *
     * Update Label
     *
     * @param UpdateLabel $body (required)
     * @param int $labelPublicId The unique ID of the Label you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateLabelAsync($body, $labelPublicId)
    {
        return $this->updateLabelAsyncWithHttpInfo($body, $labelPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLabelAsyncWithHttpInfo
     *
     * Update Label
     *
     * @param UpdateLabel $body (required)
     * @param int $labelPublicId The unique ID of the Label you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateLabelAsyncWithHttpInfo($body, $labelPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->updateLabelRequest($body, $labelPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateLinkedFile
     *
     * Update Linked File
     *
     * @param UpdateLinkedFile $body body (required)
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return LinkedFile
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateLinkedFile($body, $linkedFilePublicId)
    {
        list($response) = $this->updateLinkedFileWithHttpInfo($body, $linkedFilePublicId);
        return $response;
    }

    /**
     * Operation updateLinkedFileWithHttpInfo
     *
     * Update Linked File
     *
     * @param UpdateLinkedFile $body (required)
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateLinkedFileWithHttpInfo($body, $linkedFilePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->updateLinkedFileRequest($body, $linkedFilePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateLinkedFile'
     *
     * @param UpdateLinkedFile $body (required)
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateLinkedFileRequest($body, $linkedFilePublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateLinkedFile'
            );
        }
        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling updateLinkedFile'
            );
        }

        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLinkedFileAsync
     *
     * Update Linked File
     *
     * @param UpdateLinkedFile $body (required)
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateLinkedFileAsync($body, $linkedFilePublicId)
    {
        return $this->updateLinkedFileAsyncWithHttpInfo($body, $linkedFilePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLinkedFileAsyncWithHttpInfo
     *
     * Update Linked File
     *
     * @param UpdateLinkedFile $body (required)
     * @param int $linkedFilePublicId The unique identifier of the linked file. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateLinkedFileAsyncWithHttpInfo($body, $linkedFilePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->updateLinkedFileRequest($body, $linkedFilePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateMilestone
     *
     * Update Milestone
     *
     * @param UpdateMilestone $body body (required)
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Milestone
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateMilestone($body, $milestonePublicId)
    {
        list($response) = $this->updateMilestoneWithHttpInfo($body, $milestonePublicId);
        return $response;
    }

    /**
     * Operation updateMilestoneWithHttpInfo
     *
     * Update Milestone
     *
     * @param UpdateMilestone $body (required)
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateMilestoneWithHttpInfo($body, $milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->updateMilestoneRequest($body, $milestonePublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateMilestone'
     *
     * @param UpdateMilestone $body (required)
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateMilestoneRequest($body, $milestonePublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateMilestone'
            );
        }
        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling updateMilestone'
            );
        }

        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMilestoneAsync
     *
     * Update Milestone
     *
     * @param UpdateMilestone $body (required)
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateMilestoneAsync($body, $milestonePublicId)
    {
        return $this->updateMilestoneAsyncWithHttpInfo($body, $milestonePublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMilestoneAsyncWithHttpInfo
     *
     * Update Milestone
     *
     * @param UpdateMilestone $body (required)
     * @param int $milestonePublicId The ID of the Milestone. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateMilestoneAsyncWithHttpInfo($body, $milestonePublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->updateMilestoneRequest($body, $milestonePublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateMultipleStories
     *
     * Update Multiple Stories
     *
     * @param UpdateStories $body body (required)
     *
     * @return StorySlim[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateMultipleStories($body)
    {
        list($response) = $this->updateMultipleStoriesWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation updateMultipleStoriesWithHttpInfo
     *
     * Update Multiple Stories
     *
     * @param UpdateStories $body (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateMultipleStoriesWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->updateMultipleStoriesRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateMultipleStories'
     *
     * @param UpdateStories $body (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateMultipleStoriesRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateMultipleStories'
            );
        }

        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMultipleStoriesAsync
     *
     * Update Multiple Stories
     *
     * @param UpdateStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateMultipleStoriesAsync($body)
    {
        return $this->updateMultipleStoriesAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMultipleStoriesAsyncWithHttpInfo
     *
     * Update Multiple Stories
     *
     * @param UpdateStories $body (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateMultipleStoriesAsyncWithHttpInfo($body)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->updateMultipleStoriesRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateProject
     *
     * Update Project
     *
     * @param UpdateProject $body body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Project
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateProject($body, $projectPublicId)
    {
        list($response) = $this->updateProjectWithHttpInfo($body, $projectPublicId);
        return $response;
    }

    /**
     * Operation updateProjectWithHttpInfo
     *
     * Update Project
     *
     * @param UpdateProject $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateProjectWithHttpInfo($body, $projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->updateProjectRequest($body, $projectPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateProject'
     *
     * @param UpdateProject $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateProjectRequest($body, $projectPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateProject'
            );
        }
        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling updateProject'
            );
        }

        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProjectAsync
     *
     * Update Project
     *
     * @param UpdateProject $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateProjectAsync($body, $projectPublicId)
    {
        return $this->updateProjectAsyncWithHttpInfo($body, $projectPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProjectAsyncWithHttpInfo
     *
     * Update Project
     *
     * @param UpdateProject $body (required)
     * @param int $projectPublicId The unique ID of the Project. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateProjectAsyncWithHttpInfo($body, $projectPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->updateProjectRequest($body, $projectPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateStory
     *
     * Update Story
     *
     * @param UpdateStory $body body (required)
     * @param int $storyPublicId The unique identifier of this story. (required)
     *
     * @return Story
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStory($body, $storyPublicId)
    {
        list($response) = $this->updateStoryWithHttpInfo($body, $storyPublicId);
        return $response;
    }

    /**
     * Operation updateStoryWithHttpInfo
     *
     * Update Story
     *
     * @param UpdateStory $body (required)
     * @param int $storyPublicId The unique identifier of this story. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStoryWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->updateStoryRequest($body, $storyPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateStory'
     *
     * @param UpdateStory $body (required)
     * @param int $storyPublicId The unique identifier of this story. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateStoryRequest($body, $storyPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateStory'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateStory'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStoryAsync
     *
     * Update Story
     *
     * @param UpdateStory $body (required)
     * @param int $storyPublicId The unique identifier of this story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryAsync($body, $storyPublicId)
    {
        return $this->updateStoryAsyncWithHttpInfo($body, $storyPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryAsyncWithHttpInfo
     *
     * Update Story
     *
     * @param UpdateStory $body (required)
     * @param int $storyPublicId The unique identifier of this story. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryAsyncWithHttpInfo($body, $storyPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->updateStoryRequest($body, $storyPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateStoryComment
     *
     * Update Story Comment
     *
     * @param UpdateStoryComment $body body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment (required)
     *
     * @return StoryComment
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStoryComment($body, $storyPublicId, $commentPublicId)
    {
        list($response) = $this->updateStoryCommentWithHttpInfo($body, $storyPublicId, $commentPublicId);
        return $response;
    }

    /**
     * Operation updateStoryCommentWithHttpInfo
     *
     * Update Story Comment
     *
     * @param UpdateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStoryCommentWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->updateStoryCommentRequest($body, $storyPublicId, $commentPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateStoryComment'
     *
     * @param UpdateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateStoryCommentRequest($body, $storyPublicId, $commentPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateStoryComment'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateStoryComment'
            );
        }
        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling updateStoryComment'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStoryCommentAsync
     *
     * Update Story Comment
     *
     * @param UpdateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryCommentAsync($body, $storyPublicId, $commentPublicId)
    {
        return $this->updateStoryCommentAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryCommentAsyncWithHttpInfo
     *
     * Update Story Comment
     *
     * @param UpdateStoryComment $body (required)
     * @param int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param int $commentPublicId The ID of the Comment (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryCommentAsyncWithHttpInfo($body, $storyPublicId, $commentPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->updateStoryCommentRequest($body, $storyPublicId, $commentPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateStoryLink
     *
     * Update Story Link
     *
     * @param UpdateStoryLink $body body (required)
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return StoryLink
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStoryLink($body, $storyLinkPublicId)
    {
        list($response) = $this->updateStoryLinkWithHttpInfo($body, $storyLinkPublicId);
        return $response;
    }

    /**
     * Operation updateStoryLinkWithHttpInfo
     *
     * Update Story Link
     *
     * @param UpdateStoryLink $body (required)
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateStoryLinkWithHttpInfo($body, $storyLinkPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->updateStoryLinkRequest($body, $storyLinkPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateStoryLink'
     *
     * @param UpdateStoryLink $body (required)
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateStoryLinkRequest($body, $storyLinkPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateStoryLink'
            );
        }
        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling updateStoryLink'
            );
        }

        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStoryLinkAsync
     *
     * Update Story Link
     *
     * @param UpdateStoryLink $body (required)
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryLinkAsync($body, $storyLinkPublicId)
    {
        return $this->updateStoryLinkAsyncWithHttpInfo($body, $storyLinkPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryLinkAsyncWithHttpInfo
     *
     * Update Story Link
     *
     * @param UpdateStoryLink $body (required)
     * @param int $storyLinkPublicId The unique ID of the Story Link. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateStoryLinkAsyncWithHttpInfo($body, $storyLinkPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->updateStoryLinkRequest($body, $storyLinkPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation updateTask
     *
     * Update Task
     *
     * @param UpdateTask $body body (required)
     * @param int $storyPublicId The unique identifier of the parent Story. (required)
     * @param int $taskPublicId The unique identifier of the Task you wish to update. (required)
     *
     * @return Task
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateTask($body, $storyPublicId, $taskPublicId)
    {
        list($response) = $this->updateTaskWithHttpInfo($body, $storyPublicId, $taskPublicId);
        return $response;
    }

    /**
     * Operation updateTaskWithHttpInfo
     *
     * Update Task
     *
     * @param UpdateTask $body (required)
     * @param int $storyPublicId The unique identifier of the parent Story. (required)
     * @param int $taskPublicId The unique identifier of the Task you wish to update. (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function updateTaskWithHttpInfo($body, $storyPublicId, $taskPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->updateTaskRequest($body, $storyPublicId, $taskPublicId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'updateTask'
     *
     * @param UpdateTask $body (required)
     * @param int $storyPublicId The unique identifier of the parent Story. (required)
     * @param int $taskPublicId The unique identifier of the Task you wish to update. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function updateTaskRequest($body, $storyPublicId, $taskPublicId)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $body when calling updateTask'
            );
        }
        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateTask'
            );
        }
        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling updateTask'
            );
        }

        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTaskAsync
     *
     * Update Task
     *
     * @param UpdateTask $body (required)
     * @param int $storyPublicId The unique identifier of the parent Story. (required)
     * @param int $taskPublicId The unique identifier of the Task you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateTaskAsync($body, $storyPublicId, $taskPublicId)
    {
        return $this->updateTaskAsyncWithHttpInfo($body, $storyPublicId, $taskPublicId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskAsyncWithHttpInfo
     *
     * Update Task
     *
     * @param UpdateTask $body (required)
     * @param int $storyPublicId The unique identifier of the parent Story. (required)
     * @param int $taskPublicId The unique identifier of the Task you wish to update. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function updateTaskAsyncWithHttpInfo($body, $storyPublicId, $taskPublicId)
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->updateTaskRequest($body, $storyPublicId, $taskPublicId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Operation uploadFiles
     *
     * Upload Files
     *
     * @param int $storyId storyId (required)
     * @param string $file0 file0 (required)
     * @param string $file1 file1 (required)
     * @param string $file2 file2 (required)
     * @param string $file3 file3 (required)
     *
     * @return UploadedFile[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function uploadFiles($storyId, $file0, $file1, $file2, $file3)
    {
        list($response) = $this->uploadFilesWithHttpInfo($storyId, $file0, $file1, $file2, $file3);
        return $response;
    }

    /**
     * Operation uploadFilesWithHttpInfo
     *
     * Upload Files
     *
     * @param int $storyId (required)
     * @param string $file0 (required)
     * @param string $file1 (required)
     * @param string $file2 (required)
     * @param string $file3 (required)
     *
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function uploadFilesWithHttpInfo($storyId, $file0, $file1, $file2, $file3)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->uploadFilesRequest($storyId, $file0, $file1, $file2, $file3);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'uploadFiles'
     *
     * @param int $storyId (required)
     * @param string $file0 (required)
     * @param string $file1 (required)
     * @param string $file2 (required)
     * @param string $file3 (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function uploadFilesRequest($storyId, $file0, $file1, $file2, $file3)
    {
        // verify the required parameter 'storyId' is set
        if ($storyId === null || (is_array($storyId) && count($storyId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $storyId when calling uploadFiles'
            );
        }
        // verify the required parameter 'file0' is set
        if ($file0 === null || (is_array($file0) && count($file0) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file0 when calling uploadFiles'
            );
        }
        // verify the required parameter 'file1' is set
        if ($file1 === null || (is_array($file1) && count($file1) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file1 when calling uploadFiles'
            );
        }
        // verify the required parameter 'file2' is set
        if ($file2 === null || (is_array($file2) && count($file2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file2 when calling uploadFiles'
            );
        }
        // verify the required parameter 'file3' is set
        if ($file3 === null || (is_array($file3) && count($file3) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file3 when calling uploadFiles'
            );
        }

        $resourcePath = '/api/v3/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // form params
        if ($storyId !== null) {
            $formParams['story_id'] = ObjectSerializer::toFormValue($storyId);
        }
        // form params
        if ($file0 !== null) {
            $multipart = true;
            $formParams['file0'] = Utils::tryFopen(ObjectSerializer::toFormValue($file0), 'rb');
        }
        // form params
        if ($file1 !== null) {
            $multipart = true;
            $formParams['file1'] = Utils::tryFopen(ObjectSerializer::toFormValue($file1), 'rb');
        }
        // form params
        if ($file2 !== null) {
            $multipart = true;
            $formParams['file2'] = Utils::tryFopen(ObjectSerializer::toFormValue($file2), 'rb');
        }
        // form params
        if ($file3 !== null) {
            $multipart = true;
            $formParams['file3'] = Utils::tryFopen(ObjectSerializer::toFormValue($file3), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFilesAsync
     *
     * Upload Files
     *
     * @param int $storyId (required)
     * @param string $file0 (required)
     * @param string $file1 (required)
     * @param string $file2 (required)
     * @param string $file3 (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function uploadFilesAsync($storyId, $file0, $file1, $file2, $file3)
    {
        return $this->uploadFilesAsyncWithHttpInfo($storyId, $file0, $file1, $file2, $file3)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFilesAsyncWithHttpInfo
     *
     * Upload Files
     *
     * @param int $storyId (required)
     * @param string $file0 (required)
     * @param string $file1 (required)
     * @param string $file2 (required)
     * @param string $file3 (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function uploadFilesAsyncWithHttpInfo($storyId, $file0, $file1, $file2, $file3)
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->uploadFilesRequest($storyId, $file0, $file1, $file2, $file3);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }
}
