<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Timetoreply\Shortcut
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Shortcut API
 *
 * Shortcut API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Timetoreply\Shortcut\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Timetoreply\Shortcut\ApiException;
use Timetoreply\Shortcut\Configuration;
use Timetoreply\Shortcut\FormDataProcessor;
use Timetoreply\Shortcut\HeaderSelector;
use Timetoreply\Shortcut\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Timetoreply\Shortcut
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createCategory' => [
            'application/json',
        ],
        'createDoc' => [
            'application/json',
        ],
        'createEntityTemplate' => [
            'application/json',
        ],
        'createEpic' => [
            'application/json',
        ],
        'createEpicComment' => [
            'application/json',
        ],
        'createEpicCommentComment' => [
            'application/json',
        ],
        'createEpicHealth' => [
            'application/json',
        ],
        'createGenericIntegration' => [
            'application/json',
        ],
        'createGroup' => [
            'application/json',
        ],
        'createIteration' => [
            'application/json',
        ],
        'createLabel' => [
            'application/json',
        ],
        'createLinkedFile' => [
            'application/json',
        ],
        'createMilestone' => [
            'application/json',
        ],
        'createMultipleStories' => [
            'application/json',
        ],
        'createObjective' => [
            'application/json',
        ],
        'createProject' => [
            'application/json',
        ],
        'createStory' => [
            'application/json',
        ],
        'createStoryComment' => [
            'application/json',
        ],
        'createStoryFromTemplate' => [
            'application/json',
        ],
        'createStoryLink' => [
            'application/json',
        ],
        'createStoryReaction' => [
            'application/json',
        ],
        'createTask' => [
            'application/json',
        ],
        'deleteCategory' => [
            'application/json',
        ],
        'deleteCustomField' => [
            'application/json',
        ],
        'deleteEntityTemplate' => [
            'application/json',
        ],
        'deleteEpic' => [
            'application/json',
        ],
        'deleteEpicComment' => [
            'application/json',
        ],
        'deleteFile' => [
            'application/json',
        ],
        'deleteGenericIntegration' => [
            'application/json',
        ],
        'deleteIteration' => [
            'application/json',
        ],
        'deleteLabel' => [
            'application/json',
        ],
        'deleteLinkedFile' => [
            'application/json',
        ],
        'deleteMilestone' => [
            'application/json',
        ],
        'deleteMultipleStories' => [
            'application/json',
        ],
        'deleteObjective' => [
            'application/json',
        ],
        'deleteProject' => [
            'application/json',
        ],
        'deleteStory' => [
            'application/json',
        ],
        'deleteStoryComment' => [
            'application/json',
        ],
        'deleteStoryLink' => [
            'application/json',
        ],
        'deleteStoryReaction' => [
            'application/json',
        ],
        'deleteTask' => [
            'application/json',
        ],
        'disableIterations' => [
            'application/json',
        ],
        'disableStoryTemplates' => [
            'application/json',
        ],
        'enableIterations' => [
            'application/json',
        ],
        'enableStoryTemplates' => [
            'application/json',
        ],
        'getCategory' => [
            'application/json',
        ],
        'getCurrentMemberInfo' => [
            'application/json',
        ],
        'getCustomField' => [
            'application/json',
        ],
        'getEntityTemplate' => [
            'application/json',
        ],
        'getEpic' => [
            'application/json',
        ],
        'getEpicComment' => [
            'application/json',
        ],
        'getEpicHealth' => [
            'application/json',
        ],
        'getEpicWorkflow' => [
            'application/json',
        ],
        'getExternalLinkStories' => [
            'application/json',
        ],
        'getFile' => [
            'application/json',
        ],
        'getGenericIntegration' => [
            'application/json',
        ],
        'getGroup' => [
            'application/json',
        ],
        'getIteration' => [
            'application/json',
        ],
        'getKeyResult' => [
            'application/json',
        ],
        'getLabel' => [
            'application/json',
        ],
        'getLinkedFile' => [
            'application/json',
        ],
        'getMember' => [
            'application/json',
        ],
        'getMilestone' => [
            'application/json',
        ],
        'getObjective' => [
            'application/json',
        ],
        'getProject' => [
            'application/json',
        ],
        'getRepository' => [
            'application/json',
        ],
        'getStory' => [
            'application/json',
        ],
        'getStoryComment' => [
            'application/json',
        ],
        'getStoryLink' => [
            'application/json',
        ],
        'getTask' => [
            'application/json',
        ],
        'getWorkflow' => [
            'application/json',
        ],
        'listCategories' => [
            'application/json',
        ],
        'listCategoryMilestones' => [
            'application/json',
        ],
        'listCategoryObjectives' => [
            'application/json',
        ],
        'listCustomFields' => [
            'application/json',
        ],
        'listDocs' => [
            'application/json',
        ],
        'listEntityTemplates' => [
            'application/json',
        ],
        'listEpicComments' => [
            'application/json',
        ],
        'listEpicHealths' => [
            'application/json',
        ],
        'listEpicStories' => [
            'application/json',
        ],
        'listEpics' => [
            'application/json',
        ],
        'listEpicsPaginated' => [
            'application/json',
        ],
        'listFiles' => [
            'application/json',
        ],
        'listGroupStories' => [
            'application/json',
        ],
        'listGroups' => [
            'application/json',
        ],
        'listIterationStories' => [
            'application/json',
        ],
        'listIterations' => [
            'application/json',
        ],
        'listLabelEpics' => [
            'application/json',
        ],
        'listLabelStories' => [
            'application/json',
        ],
        'listLabels' => [
            'application/json',
        ],
        'listLinkedFiles' => [
            'application/json',
        ],
        'listMembers' => [
            'application/json',
        ],
        'listMilestoneEpics' => [
            'application/json',
        ],
        'listMilestones' => [
            'application/json',
        ],
        'listObjectiveEpics' => [
            'application/json',
        ],
        'listObjectives' => [
            'application/json',
        ],
        'listProjects' => [
            'application/json',
        ],
        'listRepositories' => [
            'application/json',
        ],
        'listStories' => [
            'application/json',
        ],
        'listStoryComment' => [
            'application/json',
        ],
        'listWorkflows' => [
            'application/json',
        ],
        'search' => [
            'application/json',
        ],
        'searchEpics' => [
            'application/json',
        ],
        'searchIterations' => [
            'application/json',
        ],
        'searchMilestones' => [
            'application/json',
        ],
        'searchObjectives' => [
            'application/json',
        ],
        'searchStories' => [
            'application/json',
        ],
        'searchStoriesOld' => [
            'application/json',
        ],
        'storyHistory' => [
            'application/json',
        ],
        'unlinkCommentThreadFromSlack' => [
            'application/json',
        ],
        'unlinkProductboardFromEpic' => [
            'application/json',
        ],
        'updateCategory' => [
            'application/json',
        ],
        'updateCustomField' => [
            'application/json',
        ],
        'updateEntityTemplate' => [
            'application/json',
        ],
        'updateEpic' => [
            'application/json',
        ],
        'updateEpicComment' => [
            'application/json',
        ],
        'updateFile' => [
            'application/json',
        ],
        'updateGroup' => [
            'application/json',
        ],
        'updateHealth' => [
            'application/json',
        ],
        'updateIteration' => [
            'application/json',
        ],
        'updateKeyResult' => [
            'application/json',
        ],
        'updateLabel' => [
            'application/json',
        ],
        'updateLinkedFile' => [
            'application/json',
        ],
        'updateMilestone' => [
            'application/json',
        ],
        'updateMultipleStories' => [
            'application/json',
        ],
        'updateObjective' => [
            'application/json',
        ],
        'updateProject' => [
            'application/json',
        ],
        'updateStory' => [
            'application/json',
        ],
        'updateStoryComment' => [
            'application/json',
        ],
        'updateStoryLink' => [
            'application/json',
        ],
        'updateTask' => [
            'application/json',
        ],
        'uploadFiles' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCategory
     *
     * Create Category
     *
     * @param  \Timetoreply\Shortcut\Model\CreateCategory $createCategory createCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Category
     */
    public function createCategory($createCategory, string $contentType = self::contentTypes['createCategory'][0])
    {
        list($response) = $this->createCategoryWithHttpInfo($createCategory, $contentType);
        return $response;
    }

    /**
     * Operation createCategoryWithHttpInfo
     *
     * Create Category
     *
     * @param  \Timetoreply\Shortcut\Model\CreateCategory $createCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCategoryWithHttpInfo($createCategory, string $contentType = self::contentTypes['createCategory'][0])
    {
        $request = $this->createCategoryRequest($createCategory, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Category',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Category',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCategoryAsync
     *
     * Create Category
     *
     * @param  \Timetoreply\Shortcut\Model\CreateCategory $createCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCategoryAsync($createCategory, string $contentType = self::contentTypes['createCategory'][0])
    {
        return $this->createCategoryAsyncWithHttpInfo($createCategory, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCategoryAsyncWithHttpInfo
     *
     * Create Category
     *
     * @param  \Timetoreply\Shortcut\Model\CreateCategory $createCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCategoryAsyncWithHttpInfo($createCategory, string $contentType = self::contentTypes['createCategory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->createCategoryRequest($createCategory, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCategory'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateCategory $createCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCategoryRequest($createCategory, string $contentType = self::contentTypes['createCategory'][0])
    {

        // verify the required parameter 'createCategory' is set
        if ($createCategory === null || (is_array($createCategory) && count($createCategory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCategory when calling createCategory'
            );
        }


        $resourcePath = '/api/v3/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createCategory)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCategory));
            } else {
                $httpBody = $createCategory;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDoc
     *
     * Create Doc
     *
     * @param  \Timetoreply\Shortcut\Model\CreateDoc $createDoc createDoc (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDoc'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\DocSlim|\Timetoreply\Shortcut\Model\DisabledFeatureError
     */
    public function createDoc($createDoc, string $contentType = self::contentTypes['createDoc'][0])
    {
        list($response) = $this->createDocWithHttpInfo($createDoc, $contentType);
        return $response;
    }

    /**
     * Operation createDocWithHttpInfo
     *
     * Create Doc
     *
     * @param  \Timetoreply\Shortcut\Model\CreateDoc $createDoc (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDoc'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\DocSlim|\Timetoreply\Shortcut\Model\DisabledFeatureError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocWithHttpInfo($createDoc, string $contentType = self::contentTypes['createDoc'][0])
    {
        $request = $this->createDocRequest($createDoc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\DocSlim',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\DisabledFeatureError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\DocSlim',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DocSlim',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DisabledFeatureError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDocAsync
     *
     * Create Doc
     *
     * @param  \Timetoreply\Shortcut\Model\CreateDoc $createDoc (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDoc'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocAsync($createDoc, string $contentType = self::contentTypes['createDoc'][0])
    {
        return $this->createDocAsyncWithHttpInfo($createDoc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocAsyncWithHttpInfo
     *
     * Create Doc
     *
     * @param  \Timetoreply\Shortcut\Model\CreateDoc $createDoc (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDoc'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocAsyncWithHttpInfo($createDoc, string $contentType = self::contentTypes['createDoc'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\DocSlim';
        $request = $this->createDocRequest($createDoc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDoc'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateDoc $createDoc (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDoc'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocRequest($createDoc, string $contentType = self::contentTypes['createDoc'][0])
    {

        // verify the required parameter 'createDoc' is set
        if ($createDoc === null || (is_array($createDoc) && count($createDoc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createDoc when calling createDoc'
            );
        }


        $resourcePath = '/api/v3/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createDoc)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createDoc));
            } else {
                $httpBody = $createDoc;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEntityTemplate
     *
     * Create Entity Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEntityTemplate $createEntityTemplate Request parameters for creating an entirely new entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EntityTemplate
     */
    public function createEntityTemplate($createEntityTemplate, string $contentType = self::contentTypes['createEntityTemplate'][0])
    {
        list($response) = $this->createEntityTemplateWithHttpInfo($createEntityTemplate, $contentType);
        return $response;
    }

    /**
     * Operation createEntityTemplateWithHttpInfo
     *
     * Create Entity Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEntityTemplate $createEntityTemplate Request parameters for creating an entirely new entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEntityTemplateWithHttpInfo($createEntityTemplate, string $contentType = self::contentTypes['createEntityTemplate'][0])
    {
        $request = $this->createEntityTemplateRequest($createEntityTemplate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EntityTemplate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEntityTemplateAsync
     *
     * Create Entity Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEntityTemplate $createEntityTemplate Request parameters for creating an entirely new entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEntityTemplateAsync($createEntityTemplate, string $contentType = self::contentTypes['createEntityTemplate'][0])
    {
        return $this->createEntityTemplateAsyncWithHttpInfo($createEntityTemplate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEntityTemplateAsyncWithHttpInfo
     *
     * Create Entity Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEntityTemplate $createEntityTemplate Request parameters for creating an entirely new entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEntityTemplateAsyncWithHttpInfo($createEntityTemplate, string $contentType = self::contentTypes['createEntityTemplate'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->createEntityTemplateRequest($createEntityTemplate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEntityTemplate'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEntityTemplate $createEntityTemplate Request parameters for creating an entirely new entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEntityTemplateRequest($createEntityTemplate, string $contentType = self::contentTypes['createEntityTemplate'][0])
    {

        // verify the required parameter 'createEntityTemplate' is set
        if ($createEntityTemplate === null || (is_array($createEntityTemplate) && count($createEntityTemplate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createEntityTemplate when calling createEntityTemplate'
            );
        }


        $resourcePath = '/api/v3/entity-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createEntityTemplate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createEntityTemplate));
            } else {
                $httpBody = $createEntityTemplate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpic
     *
     * Create Epic
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEpic $createEpic createEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Epic
     */
    public function createEpic($createEpic, string $contentType = self::contentTypes['createEpic'][0])
    {
        list($response) = $this->createEpicWithHttpInfo($createEpic, $contentType);
        return $response;
    }

    /**
     * Operation createEpicWithHttpInfo
     *
     * Create Epic
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEpic $createEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEpicWithHttpInfo($createEpic, string $contentType = self::contentTypes['createEpic'][0])
    {
        $request = $this->createEpicRequest($createEpic, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Epic',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Epic',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEpicAsync
     *
     * Create Epic
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEpic $createEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicAsync($createEpic, string $contentType = self::contentTypes['createEpic'][0])
    {
        return $this->createEpicAsyncWithHttpInfo($createEpic, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicAsyncWithHttpInfo
     *
     * Create Epic
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEpic $createEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicAsyncWithHttpInfo($createEpic, string $contentType = self::contentTypes['createEpic'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->createEpicRequest($createEpic, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEpic'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateEpic $createEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEpicRequest($createEpic, string $contentType = self::contentTypes['createEpic'][0])
    {

        // verify the required parameter 'createEpic' is set
        if ($createEpic === null || (is_array($createEpic) && count($createEpic) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createEpic when calling createEpic'
            );
        }


        $resourcePath = '/api/v3/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createEpic)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createEpic));
            } else {
                $httpBody = $createEpic;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicComment
     *
     * Create Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicComment $createEpicComment createEpicComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ThreadedComment
     */
    public function createEpicComment($epicPublicId, $createEpicComment, string $contentType = self::contentTypes['createEpicComment'][0])
    {
        list($response) = $this->createEpicCommentWithHttpInfo($epicPublicId, $createEpicComment, $contentType);
        return $response;
    }

    /**
     * Operation createEpicCommentWithHttpInfo
     *
     * Create Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicComment $createEpicComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEpicCommentWithHttpInfo($epicPublicId, $createEpicComment, string $contentType = self::contentTypes['createEpicComment'][0])
    {
        $request = $this->createEpicCommentRequest($epicPublicId, $createEpicComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ThreadedComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEpicCommentAsync
     *
     * Create Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicComment $createEpicComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicCommentAsync($epicPublicId, $createEpicComment, string $contentType = self::contentTypes['createEpicComment'][0])
    {
        return $this->createEpicCommentAsyncWithHttpInfo($epicPublicId, $createEpicComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicCommentAsyncWithHttpInfo
     *
     * Create Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicComment $createEpicComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicCommentAsyncWithHttpInfo($epicPublicId, $createEpicComment, string $contentType = self::contentTypes['createEpicComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentRequest($epicPublicId, $createEpicComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEpicComment'
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicComment $createEpicComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEpicCommentRequest($epicPublicId, $createEpicComment, string $contentType = self::contentTypes['createEpicComment'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling createEpicComment'
            );
        }

        // verify the required parameter 'createEpicComment' is set
        if ($createEpicComment === null || (is_array($createEpicComment) && count($createEpicComment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createEpicComment when calling createEpicComment'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createEpicComment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createEpicComment));
            } else {
                $httpBody = $createEpicComment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicCommentComment
     *
     * Create Epic Comment Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the parent Epic Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateCommentComment $createCommentComment createCommentComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicCommentComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ThreadedComment
     */
    public function createEpicCommentComment($epicPublicId, $commentPublicId, $createCommentComment, string $contentType = self::contentTypes['createEpicCommentComment'][0])
    {
        list($response) = $this->createEpicCommentCommentWithHttpInfo($epicPublicId, $commentPublicId, $createCommentComment, $contentType);
        return $response;
    }

    /**
     * Operation createEpicCommentCommentWithHttpInfo
     *
     * Create Epic Comment Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the parent Epic Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateCommentComment $createCommentComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicCommentComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEpicCommentCommentWithHttpInfo($epicPublicId, $commentPublicId, $createCommentComment, string $contentType = self::contentTypes['createEpicCommentComment'][0])
    {
        $request = $this->createEpicCommentCommentRequest($epicPublicId, $commentPublicId, $createCommentComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ThreadedComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEpicCommentCommentAsync
     *
     * Create Epic Comment Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the parent Epic Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateCommentComment $createCommentComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicCommentComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicCommentCommentAsync($epicPublicId, $commentPublicId, $createCommentComment, string $contentType = self::contentTypes['createEpicCommentComment'][0])
    {
        return $this->createEpicCommentCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $createCommentComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicCommentCommentAsyncWithHttpInfo
     *
     * Create Epic Comment Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the parent Epic Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateCommentComment $createCommentComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicCommentComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicCommentCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $createCommentComment, string $contentType = self::contentTypes['createEpicCommentComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->createEpicCommentCommentRequest($epicPublicId, $commentPublicId, $createCommentComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEpicCommentComment'
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the parent Epic Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateCommentComment $createCommentComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicCommentComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEpicCommentCommentRequest($epicPublicId, $commentPublicId, $createCommentComment, string $contentType = self::contentTypes['createEpicCommentComment'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling createEpicCommentComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling createEpicCommentComment'
            );
        }

        // verify the required parameter 'createCommentComment' is set
        if ($createCommentComment === null || (is_array($createCommentComment) && count($createCommentComment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCommentComment when calling createEpicCommentComment'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createCommentComment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCommentComment));
            } else {
                $httpBody = $createCommentComment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEpicHealth
     *
     * Create Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicHealth $createEpicHealth createEpicHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Health
     */
    public function createEpicHealth($epicPublicId, $createEpicHealth, string $contentType = self::contentTypes['createEpicHealth'][0])
    {
        list($response) = $this->createEpicHealthWithHttpInfo($epicPublicId, $createEpicHealth, $contentType);
        return $response;
    }

    /**
     * Operation createEpicHealthWithHttpInfo
     *
     * Create Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicHealth $createEpicHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Health, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEpicHealthWithHttpInfo($epicPublicId, $createEpicHealth, string $contentType = self::contentTypes['createEpicHealth'][0])
    {
        $request = $this->createEpicHealthRequest($epicPublicId, $createEpicHealth, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Health',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Health',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Health',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEpicHealthAsync
     *
     * Create Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicHealth $createEpicHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicHealthAsync($epicPublicId, $createEpicHealth, string $contentType = self::contentTypes['createEpicHealth'][0])
    {
        return $this->createEpicHealthAsyncWithHttpInfo($epicPublicId, $createEpicHealth, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEpicHealthAsyncWithHttpInfo
     *
     * Create Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicHealth $createEpicHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEpicHealthAsyncWithHttpInfo($epicPublicId, $createEpicHealth, string $contentType = self::contentTypes['createEpicHealth'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Health';
        $request = $this->createEpicHealthRequest($epicPublicId, $createEpicHealth, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEpicHealth'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateEpicHealth $createEpicHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEpicHealthRequest($epicPublicId, $createEpicHealth, string $contentType = self::contentTypes['createEpicHealth'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling createEpicHealth'
            );
        }

        // verify the required parameter 'createEpicHealth' is set
        if ($createEpicHealth === null || (is_array($createEpicHealth) && count($createEpicHealth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createEpicHealth when calling createEpicHealth'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/health';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createEpicHealth)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createEpicHealth));
            } else {
                $httpBody = $createEpicHealth;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGenericIntegration
     *
     * Create Generic Integration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGenericIntegration $createGenericIntegration createGenericIntegration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createGenericIntegration($createGenericIntegration, string $contentType = self::contentTypes['createGenericIntegration'][0])
    {
        $this->createGenericIntegrationWithHttpInfo($createGenericIntegration, $contentType);
    }

    /**
     * Operation createGenericIntegrationWithHttpInfo
     *
     * Create Generic Integration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGenericIntegration $createGenericIntegration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGenericIntegrationWithHttpInfo($createGenericIntegration, string $contentType = self::contentTypes['createGenericIntegration'][0])
    {
        $request = $this->createGenericIntegrationRequest($createGenericIntegration, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation createGenericIntegrationAsync
     *
     * Create Generic Integration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGenericIntegration $createGenericIntegration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGenericIntegrationAsync($createGenericIntegration, string $contentType = self::contentTypes['createGenericIntegration'][0])
    {
        return $this->createGenericIntegrationAsyncWithHttpInfo($createGenericIntegration, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGenericIntegrationAsyncWithHttpInfo
     *
     * Create Generic Integration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGenericIntegration $createGenericIntegration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGenericIntegrationAsyncWithHttpInfo($createGenericIntegration, string $contentType = self::contentTypes['createGenericIntegration'][0])
    {
        $returnType = '';
        $request = $this->createGenericIntegrationRequest($createGenericIntegration, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGenericIntegration'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGenericIntegration $createGenericIntegration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGenericIntegrationRequest($createGenericIntegration, string $contentType = self::contentTypes['createGenericIntegration'][0])
    {

        // verify the required parameter 'createGenericIntegration' is set
        if ($createGenericIntegration === null || (is_array($createGenericIntegration) && count($createGenericIntegration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createGenericIntegration when calling createGenericIntegration'
            );
        }


        $resourcePath = '/api/v3/integrations/webhook';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createGenericIntegration)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createGenericIntegration));
            } else {
                $httpBody = $createGenericIntegration;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGroup
     *
     * Create Group
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGroup $createGroup createGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Group|\Timetoreply\Shortcut\Model\UnusableEntitlementError
     */
    public function createGroup($createGroup, string $contentType = self::contentTypes['createGroup'][0])
    {
        list($response) = $this->createGroupWithHttpInfo($createGroup, $contentType);
        return $response;
    }

    /**
     * Operation createGroupWithHttpInfo
     *
     * Create Group
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGroup $createGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Group|\Timetoreply\Shortcut\Model\UnusableEntitlementError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGroupWithHttpInfo($createGroup, string $contentType = self::contentTypes['createGroup'][0])
    {
        $request = $this->createGroupRequest($createGroup, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Group',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Group',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createGroupAsync
     *
     * Create Group
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGroup $createGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGroupAsync($createGroup, string $contentType = self::contentTypes['createGroup'][0])
    {
        return $this->createGroupAsyncWithHttpInfo($createGroup, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGroupAsyncWithHttpInfo
     *
     * Create Group
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGroup $createGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGroupAsyncWithHttpInfo($createGroup, string $contentType = self::contentTypes['createGroup'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->createGroupRequest($createGroup, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGroup'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateGroup $createGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGroupRequest($createGroup, string $contentType = self::contentTypes['createGroup'][0])
    {

        // verify the required parameter 'createGroup' is set
        if ($createGroup === null || (is_array($createGroup) && count($createGroup) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createGroup when calling createGroup'
            );
        }


        $resourcePath = '/api/v3/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createGroup)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createGroup));
            } else {
                $httpBody = $createGroup;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createIteration
     *
     * Create Iteration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateIteration $createIteration createIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Iteration
     */
    public function createIteration($createIteration, string $contentType = self::contentTypes['createIteration'][0])
    {
        list($response) = $this->createIterationWithHttpInfo($createIteration, $contentType);
        return $response;
    }

    /**
     * Operation createIterationWithHttpInfo
     *
     * Create Iteration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateIteration $createIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     */
    public function createIterationWithHttpInfo($createIteration, string $contentType = self::contentTypes['createIteration'][0])
    {
        $request = $this->createIterationRequest($createIteration, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Iteration',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createIterationAsync
     *
     * Create Iteration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateIteration $createIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIterationAsync($createIteration, string $contentType = self::contentTypes['createIteration'][0])
    {
        return $this->createIterationAsyncWithHttpInfo($createIteration, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createIterationAsyncWithHttpInfo
     *
     * Create Iteration
     *
     * @param  \Timetoreply\Shortcut\Model\CreateIteration $createIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIterationAsyncWithHttpInfo($createIteration, string $contentType = self::contentTypes['createIteration'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->createIterationRequest($createIteration, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createIteration'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateIteration $createIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createIterationRequest($createIteration, string $contentType = self::contentTypes['createIteration'][0])
    {

        // verify the required parameter 'createIteration' is set
        if ($createIteration === null || (is_array($createIteration) && count($createIteration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createIteration when calling createIteration'
            );
        }


        $resourcePath = '/api/v3/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createIteration)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createIteration));
            } else {
                $httpBody = $createIteration;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createLabel
     *
     * Create Label
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLabelParams $createLabelParams Request parameters for creating a Label on a Shortcut Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Label
     */
    public function createLabel($createLabelParams, string $contentType = self::contentTypes['createLabel'][0])
    {
        list($response) = $this->createLabelWithHttpInfo($createLabelParams, $contentType);
        return $response;
    }

    /**
     * Operation createLabelWithHttpInfo
     *
     * Create Label
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLabelParams $createLabelParams Request parameters for creating a Label on a Shortcut Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function createLabelWithHttpInfo($createLabelParams, string $contentType = self::contentTypes['createLabel'][0])
    {
        $request = $this->createLabelRequest($createLabelParams, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Label',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Label',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createLabelAsync
     *
     * Create Label
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLabelParams $createLabelParams Request parameters for creating a Label on a Shortcut Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLabelAsync($createLabelParams, string $contentType = self::contentTypes['createLabel'][0])
    {
        return $this->createLabelAsyncWithHttpInfo($createLabelParams, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLabelAsyncWithHttpInfo
     *
     * Create Label
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLabelParams $createLabelParams Request parameters for creating a Label on a Shortcut Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLabelAsyncWithHttpInfo($createLabelParams, string $contentType = self::contentTypes['createLabel'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->createLabelRequest($createLabelParams, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createLabel'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLabelParams $createLabelParams Request parameters for creating a Label on a Shortcut Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createLabelRequest($createLabelParams, string $contentType = self::contentTypes['createLabel'][0])
    {

        // verify the required parameter 'createLabelParams' is set
        if ($createLabelParams === null || (is_array($createLabelParams) && count($createLabelParams) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createLabelParams when calling createLabel'
            );
        }


        $resourcePath = '/api/v3/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createLabelParams)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createLabelParams));
            } else {
                $httpBody = $createLabelParams;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createLinkedFile
     *
     * Create Linked File
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLinkedFile $createLinkedFile createLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\LinkedFile
     */
    public function createLinkedFile($createLinkedFile, string $contentType = self::contentTypes['createLinkedFile'][0])
    {
        list($response) = $this->createLinkedFileWithHttpInfo($createLinkedFile, $contentType);
        return $response;
    }

    /**
     * Operation createLinkedFileWithHttpInfo
     *
     * Create Linked File
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLinkedFile $createLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function createLinkedFileWithHttpInfo($createLinkedFile, string $contentType = self::contentTypes['createLinkedFile'][0])
    {
        $request = $this->createLinkedFileRequest($createLinkedFile, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\LinkedFile',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createLinkedFileAsync
     *
     * Create Linked File
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLinkedFile $createLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLinkedFileAsync($createLinkedFile, string $contentType = self::contentTypes['createLinkedFile'][0])
    {
        return $this->createLinkedFileAsyncWithHttpInfo($createLinkedFile, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLinkedFileAsyncWithHttpInfo
     *
     * Create Linked File
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLinkedFile $createLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLinkedFileAsyncWithHttpInfo($createLinkedFile, string $contentType = self::contentTypes['createLinkedFile'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->createLinkedFileRequest($createLinkedFile, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createLinkedFile'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateLinkedFile $createLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createLinkedFileRequest($createLinkedFile, string $contentType = self::contentTypes['createLinkedFile'][0])
    {

        // verify the required parameter 'createLinkedFile' is set
        if ($createLinkedFile === null || (is_array($createLinkedFile) && count($createLinkedFile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createLinkedFile when calling createLinkedFile'
            );
        }


        $resourcePath = '/api/v3/linked-files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createLinkedFile)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createLinkedFile));
            } else {
                $httpBody = $createLinkedFile;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMilestone
     *
     * Create Milestone
     *
     * @param  \Timetoreply\Shortcut\Model\CreateMilestone $createMilestone createMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone|\Timetoreply\Shortcut\Model\UnusableEntitlementError
     */
    public function createMilestone($createMilestone, string $contentType = self::contentTypes['createMilestone'][0])
    {
        list($response) = $this->createMilestoneWithHttpInfo($createMilestone, $contentType);
        return $response;
    }

    /**
     * Operation createMilestoneWithHttpInfo
     *
     * Create Milestone
     *
     * @param  \Timetoreply\Shortcut\Model\CreateMilestone $createMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone|\Timetoreply\Shortcut\Model\UnusableEntitlementError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMilestoneWithHttpInfo($createMilestone, string $contentType = self::contentTypes['createMilestone'][0])
    {
        $request = $this->createMilestoneRequest($createMilestone, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMilestoneAsync
     *
     * Create Milestone
     *
     * @param  \Timetoreply\Shortcut\Model\CreateMilestone $createMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMilestoneAsync($createMilestone, string $contentType = self::contentTypes['createMilestone'][0])
    {
        return $this->createMilestoneAsyncWithHttpInfo($createMilestone, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMilestoneAsyncWithHttpInfo
     *
     * Create Milestone
     *
     * @param  \Timetoreply\Shortcut\Model\CreateMilestone $createMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMilestoneAsyncWithHttpInfo($createMilestone, string $contentType = self::contentTypes['createMilestone'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->createMilestoneRequest($createMilestone, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMilestone'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateMilestone $createMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMilestoneRequest($createMilestone, string $contentType = self::contentTypes['createMilestone'][0])
    {

        // verify the required parameter 'createMilestone' is set
        if ($createMilestone === null || (is_array($createMilestone) && count($createMilestone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createMilestone when calling createMilestone'
            );
        }


        $resourcePath = '/api/v3/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createMilestone)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createMilestone));
            } else {
                $httpBody = $createMilestone;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMultipleStories
     *
     * Create Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStories $createStories createStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function createMultipleStories($createStories, string $contentType = self::contentTypes['createMultipleStories'][0])
    {
        list($response) = $this->createMultipleStoriesWithHttpInfo($createStories, $contentType);
        return $response;
    }

    /**
     * Operation createMultipleStoriesWithHttpInfo
     *
     * Create Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStories $createStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createMultipleStoriesWithHttpInfo($createStories, string $contentType = self::contentTypes['createMultipleStories'][0])
    {
        $request = $this->createMultipleStoriesRequest($createStories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMultipleStoriesAsync
     *
     * Create Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStories $createStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMultipleStoriesAsync($createStories, string $contentType = self::contentTypes['createMultipleStories'][0])
    {
        return $this->createMultipleStoriesAsyncWithHttpInfo($createStories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMultipleStoriesAsyncWithHttpInfo
     *
     * Create Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStories $createStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMultipleStoriesAsyncWithHttpInfo($createStories, string $contentType = self::contentTypes['createMultipleStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->createMultipleStoriesRequest($createStories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMultipleStories'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStories $createStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMultipleStoriesRequest($createStories, string $contentType = self::contentTypes['createMultipleStories'][0])
    {

        // verify the required parameter 'createStories' is set
        if ($createStories === null || (is_array($createStories) && count($createStories) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createStories when calling createMultipleStories'
            );
        }


        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createStories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createStories));
            } else {
                $httpBody = $createStories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createObjective
     *
     * Create Objective
     *
     * @param  \Timetoreply\Shortcut\Model\CreateObjective $createObjective createObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Objective|\Timetoreply\Shortcut\Model\UnusableEntitlementError
     */
    public function createObjective($createObjective, string $contentType = self::contentTypes['createObjective'][0])
    {
        list($response) = $this->createObjectiveWithHttpInfo($createObjective, $contentType);
        return $response;
    }

    /**
     * Operation createObjectiveWithHttpInfo
     *
     * Create Objective
     *
     * @param  \Timetoreply\Shortcut\Model\CreateObjective $createObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Objective|\Timetoreply\Shortcut\Model\UnusableEntitlementError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createObjectiveWithHttpInfo($createObjective, string $contentType = self::contentTypes['createObjective'][0])
    {
        $request = $this->createObjectiveRequest($createObjective, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Objective',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Objective',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Objective',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createObjectiveAsync
     *
     * Create Objective
     *
     * @param  \Timetoreply\Shortcut\Model\CreateObjective $createObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createObjectiveAsync($createObjective, string $contentType = self::contentTypes['createObjective'][0])
    {
        return $this->createObjectiveAsyncWithHttpInfo($createObjective, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createObjectiveAsyncWithHttpInfo
     *
     * Create Objective
     *
     * @param  \Timetoreply\Shortcut\Model\CreateObjective $createObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createObjectiveAsyncWithHttpInfo($createObjective, string $contentType = self::contentTypes['createObjective'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Objective';
        $request = $this->createObjectiveRequest($createObjective, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createObjective'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateObjective $createObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createObjectiveRequest($createObjective, string $contentType = self::contentTypes['createObjective'][0])
    {

        // verify the required parameter 'createObjective' is set
        if ($createObjective === null || (is_array($createObjective) && count($createObjective) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createObjective when calling createObjective'
            );
        }


        $resourcePath = '/api/v3/objectives';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createObjective)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createObjective));
            } else {
                $httpBody = $createObjective;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createProject
     *
     * Create Project
     *
     * @param  \Timetoreply\Shortcut\Model\CreateProject $createProject createProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Project
     */
    public function createProject($createProject, string $contentType = self::contentTypes['createProject'][0])
    {
        list($response) = $this->createProjectWithHttpInfo($createProject, $contentType);
        return $response;
    }

    /**
     * Operation createProjectWithHttpInfo
     *
     * Create Project
     *
     * @param  \Timetoreply\Shortcut\Model\CreateProject $createProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function createProjectWithHttpInfo($createProject, string $contentType = self::contentTypes['createProject'][0])
    {
        $request = $this->createProjectRequest($createProject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Project',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Project',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createProjectAsync
     *
     * Create Project
     *
     * @param  \Timetoreply\Shortcut\Model\CreateProject $createProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProjectAsync($createProject, string $contentType = self::contentTypes['createProject'][0])
    {
        return $this->createProjectAsyncWithHttpInfo($createProject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createProjectAsyncWithHttpInfo
     *
     * Create Project
     *
     * @param  \Timetoreply\Shortcut\Model\CreateProject $createProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProjectAsyncWithHttpInfo($createProject, string $contentType = self::contentTypes['createProject'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->createProjectRequest($createProject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createProject'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateProject $createProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createProjectRequest($createProject, string $contentType = self::contentTypes['createProject'][0])
    {

        // verify the required parameter 'createProject' is set
        if ($createProject === null || (is_array($createProject) && count($createProject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createProject when calling createProject'
            );
        }


        $resourcePath = '/api/v3/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createProject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createProject));
            } else {
                $httpBody = $createProject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStory
     *
     * Create Story
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryParams $createStoryParams Request parameters for creating a story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Story
     */
    public function createStory($createStoryParams, string $contentType = self::contentTypes['createStory'][0])
    {
        list($response) = $this->createStoryWithHttpInfo($createStoryParams, $contentType);
        return $response;
    }

    /**
     * Operation createStoryWithHttpInfo
     *
     * Create Story
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryParams $createStoryParams Request parameters for creating a story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStoryWithHttpInfo($createStoryParams, string $contentType = self::contentTypes['createStory'][0])
    {
        $request = $this->createStoryRequest($createStoryParams, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Story',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Story',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStoryAsync
     *
     * Create Story
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryParams $createStoryParams Request parameters for creating a story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryAsync($createStoryParams, string $contentType = self::contentTypes['createStory'][0])
    {
        return $this->createStoryAsyncWithHttpInfo($createStoryParams, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryAsyncWithHttpInfo
     *
     * Create Story
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryParams $createStoryParams Request parameters for creating a story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryAsyncWithHttpInfo($createStoryParams, string $contentType = self::contentTypes['createStory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->createStoryRequest($createStoryParams, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStory'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryParams $createStoryParams Request parameters for creating a story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStoryRequest($createStoryParams, string $contentType = self::contentTypes['createStory'][0])
    {

        // verify the required parameter 'createStoryParams' is set
        if ($createStoryParams === null || (is_array($createStoryParams) && count($createStoryParams) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createStoryParams when calling createStory'
            );
        }


        $resourcePath = '/api/v3/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createStoryParams)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createStoryParams));
            } else {
                $httpBody = $createStoryParams;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryComment
     *
     * Create Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateStoryComment $createStoryComment createStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryComment
     */
    public function createStoryComment($storyPublicId, $createStoryComment, string $contentType = self::contentTypes['createStoryComment'][0])
    {
        list($response) = $this->createStoryCommentWithHttpInfo($storyPublicId, $createStoryComment, $contentType);
        return $response;
    }

    /**
     * Operation createStoryCommentWithHttpInfo
     *
     * Create Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateStoryComment $createStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStoryCommentWithHttpInfo($storyPublicId, $createStoryComment, string $contentType = self::contentTypes['createStoryComment'][0])
    {
        $request = $this->createStoryCommentRequest($storyPublicId, $createStoryComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStoryCommentAsync
     *
     * Create Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateStoryComment $createStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryCommentAsync($storyPublicId, $createStoryComment, string $contentType = self::contentTypes['createStoryComment'][0])
    {
        return $this->createStoryCommentAsyncWithHttpInfo($storyPublicId, $createStoryComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryCommentAsyncWithHttpInfo
     *
     * Create Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateStoryComment $createStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryCommentAsyncWithHttpInfo($storyPublicId, $createStoryComment, string $contentType = self::contentTypes['createStoryComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->createStoryCommentRequest($storyPublicId, $createStoryComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStoryComment'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateStoryComment $createStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStoryCommentRequest($storyPublicId, $createStoryComment, string $contentType = self::contentTypes['createStoryComment'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createStoryComment'
            );
        }

        // verify the required parameter 'createStoryComment' is set
        if ($createStoryComment === null || (is_array($createStoryComment) && count($createStoryComment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createStoryComment when calling createStoryComment'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createStoryComment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createStoryComment));
            } else {
                $httpBody = $createStoryComment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryFromTemplate
     *
     * Create Story From Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryFromTemplateParams $createStoryFromTemplateParams Request parameters for creating a story from a story template. These parameters are merged with the values derived from the template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryFromTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Story
     */
    public function createStoryFromTemplate($createStoryFromTemplateParams, string $contentType = self::contentTypes['createStoryFromTemplate'][0])
    {
        list($response) = $this->createStoryFromTemplateWithHttpInfo($createStoryFromTemplateParams, $contentType);
        return $response;
    }

    /**
     * Operation createStoryFromTemplateWithHttpInfo
     *
     * Create Story From Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryFromTemplateParams $createStoryFromTemplateParams Request parameters for creating a story from a story template. These parameters are merged with the values derived from the template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryFromTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStoryFromTemplateWithHttpInfo($createStoryFromTemplateParams, string $contentType = self::contentTypes['createStoryFromTemplate'][0])
    {
        $request = $this->createStoryFromTemplateRequest($createStoryFromTemplateParams, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Story',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Story',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStoryFromTemplateAsync
     *
     * Create Story From Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryFromTemplateParams $createStoryFromTemplateParams Request parameters for creating a story from a story template. These parameters are merged with the values derived from the template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryFromTemplateAsync($createStoryFromTemplateParams, string $contentType = self::contentTypes['createStoryFromTemplate'][0])
    {
        return $this->createStoryFromTemplateAsyncWithHttpInfo($createStoryFromTemplateParams, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryFromTemplateAsyncWithHttpInfo
     *
     * Create Story From Template
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryFromTemplateParams $createStoryFromTemplateParams Request parameters for creating a story from a story template. These parameters are merged with the values derived from the template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryFromTemplateAsyncWithHttpInfo($createStoryFromTemplateParams, string $contentType = self::contentTypes['createStoryFromTemplate'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->createStoryFromTemplateRequest($createStoryFromTemplateParams, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStoryFromTemplate'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryFromTemplateParams $createStoryFromTemplateParams Request parameters for creating a story from a story template. These parameters are merged with the values derived from the template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStoryFromTemplateRequest($createStoryFromTemplateParams, string $contentType = self::contentTypes['createStoryFromTemplate'][0])
    {

        // verify the required parameter 'createStoryFromTemplateParams' is set
        if ($createStoryFromTemplateParams === null || (is_array($createStoryFromTemplateParams) && count($createStoryFromTemplateParams) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createStoryFromTemplateParams when calling createStoryFromTemplate'
            );
        }


        $resourcePath = '/api/v3/stories/from-template';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createStoryFromTemplateParams)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createStoryFromTemplateParams));
            } else {
                $httpBody = $createStoryFromTemplateParams;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryLink
     *
     * Create Story Link
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryLink $createStoryLink createStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryLink
     */
    public function createStoryLink($createStoryLink, string $contentType = self::contentTypes['createStoryLink'][0])
    {
        list($response) = $this->createStoryLinkWithHttpInfo($createStoryLink, $contentType);
        return $response;
    }

    /**
     * Operation createStoryLinkWithHttpInfo
     *
     * Create Story Link
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryLink $createStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStoryLinkWithHttpInfo($createStoryLink, string $contentType = self::contentTypes['createStoryLink'][0])
    {
        $request = $this->createStoryLinkRequest($createStoryLink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryLink',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStoryLinkAsync
     *
     * Create Story Link
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryLink $createStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryLinkAsync($createStoryLink, string $contentType = self::contentTypes['createStoryLink'][0])
    {
        return $this->createStoryLinkAsyncWithHttpInfo($createStoryLink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryLinkAsyncWithHttpInfo
     *
     * Create Story Link
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryLink $createStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryLinkAsyncWithHttpInfo($createStoryLink, string $contentType = self::contentTypes['createStoryLink'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->createStoryLinkRequest($createStoryLink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStoryLink'
     *
     * @param  \Timetoreply\Shortcut\Model\CreateStoryLink $createStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStoryLinkRequest($createStoryLink, string $contentType = self::contentTypes['createStoryLink'][0])
    {

        // verify the required parameter 'createStoryLink' is set
        if ($createStoryLink === null || (is_array($createStoryLink) && count($createStoryLink) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createStoryLink when calling createStoryLink'
            );
        }


        $resourcePath = '/api/v3/story-links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createStoryLink)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createStoryLink));
            } else {
                $httpBody = $createStoryLink;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStoryReaction
     *
     * Create Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryReaction'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryReaction[]
     */
    public function createStoryReaction($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['createStoryReaction'][0])
    {
        list($response) = $this->createStoryReactionWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);
        return $response;
    }

    /**
     * Operation createStoryReactionWithHttpInfo
     *
     * Create Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryReaction'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryReaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createStoryReactionWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['createStoryReaction'][0])
    {
        $request = $this->createStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryReaction[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryReaction[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryReaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStoryReactionAsync
     *
     * Create Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryReactionAsync($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['createStoryReaction'][0])
    {
        return $this->createStoryReactionAsyncWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStoryReactionAsyncWithHttpInfo
     *
     * Create Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStoryReactionAsyncWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['createStoryReaction'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryReaction[]';
        $request = $this->createStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStoryReaction'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['createStoryReaction'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createStoryReaction'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling createStoryReaction'
            );
        }

        // verify the required parameter 'createOrDeleteStoryReaction' is set
        if ($createOrDeleteStoryReaction === null || (is_array($createOrDeleteStoryReaction) && count($createOrDeleteStoryReaction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createOrDeleteStoryReaction when calling createStoryReaction'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createOrDeleteStoryReaction)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createOrDeleteStoryReaction));
            } else {
                $httpBody = $createOrDeleteStoryReaction;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTask
     *
     * Create Task
     *
     * @param  int $storyPublicId The ID of the Story that the Task will be in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateTask $createTask createTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Task
     */
    public function createTask($storyPublicId, $createTask, string $contentType = self::contentTypes['createTask'][0])
    {
        list($response) = $this->createTaskWithHttpInfo($storyPublicId, $createTask, $contentType);
        return $response;
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * Create Task
     *
     * @param  int $storyPublicId The ID of the Story that the Task will be in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateTask $createTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskWithHttpInfo($storyPublicId, $createTask, string $contentType = self::contentTypes['createTask'][0])
    {
        $request = $this->createTaskRequest($storyPublicId, $createTask, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Task',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Task',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTaskAsync
     *
     * Create Task
     *
     * @param  int $storyPublicId The ID of the Story that the Task will be in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateTask $createTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsync($storyPublicId, $createTask, string $contentType = self::contentTypes['createTask'][0])
    {
        return $this->createTaskAsyncWithHttpInfo($storyPublicId, $createTask, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * Create Task
     *
     * @param  int $storyPublicId The ID of the Story that the Task will be in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateTask $createTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsyncWithHttpInfo($storyPublicId, $createTask, string $contentType = self::contentTypes['createTask'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->createTaskRequest($storyPublicId, $createTask, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param  int $storyPublicId The ID of the Story that the Task will be in. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateTask $createTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTaskRequest($storyPublicId, $createTask, string $contentType = self::contentTypes['createTask'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling createTask'
            );
        }

        // verify the required parameter 'createTask' is set
        if ($createTask === null || (is_array($createTask) && count($createTask) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createTask when calling createTask'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createTask)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createTask));
            } else {
                $httpBody = $createTask;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCategory
     *
     * Delete Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCategory($categoryPublicId, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        $this->deleteCategoryWithHttpInfo($categoryPublicId, $contentType);
    }

    /**
     * Operation deleteCategoryWithHttpInfo
     *
     * Delete Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCategoryWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        $request = $this->deleteCategoryRequest($categoryPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCategoryAsync
     *
     * Delete Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCategoryAsync($categoryPublicId, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        return $this->deleteCategoryAsyncWithHttpInfo($categoryPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCategoryAsyncWithHttpInfo
     *
     * Delete Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCategoryAsyncWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        $returnType = '';
        $request = $this->deleteCategoryRequest($categoryPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCategory'
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCategoryRequest($categoryPublicId, string $contentType = self::contentTypes['deleteCategory'][0])
    {

        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling deleteCategory'
            );
        }


        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomField
     *
     * Delete Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomField($customFieldPublicId, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $this->deleteCustomFieldWithHttpInfo($customFieldPublicId, $contentType);
    }

    /**
     * Operation deleteCustomFieldWithHttpInfo
     *
     * Delete Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomFieldWithHttpInfo($customFieldPublicId, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $request = $this->deleteCustomFieldRequest($customFieldPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCustomFieldAsync
     *
     * Delete Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomFieldAsync($customFieldPublicId, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        return $this->deleteCustomFieldAsyncWithHttpInfo($customFieldPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomFieldAsyncWithHttpInfo
     *
     * Delete Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomFieldAsyncWithHttpInfo($customFieldPublicId, string $contentType = self::contentTypes['deleteCustomField'][0])
    {
        $returnType = '';
        $request = $this->deleteCustomFieldRequest($customFieldPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomField'
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCustomFieldRequest($customFieldPublicId, string $contentType = self::contentTypes['deleteCustomField'][0])
    {

        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling deleteCustomField'
            );
        }


        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEntityTemplate
     *
     * Delete Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteEntityTemplate($entityTemplatePublicId, string $contentType = self::contentTypes['deleteEntityTemplate'][0])
    {
        $this->deleteEntityTemplateWithHttpInfo($entityTemplatePublicId, $contentType);
    }

    /**
     * Operation deleteEntityTemplateWithHttpInfo
     *
     * Delete Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEntityTemplateWithHttpInfo($entityTemplatePublicId, string $contentType = self::contentTypes['deleteEntityTemplate'][0])
    {
        $request = $this->deleteEntityTemplateRequest($entityTemplatePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteEntityTemplateAsync
     *
     * Delete Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEntityTemplateAsync($entityTemplatePublicId, string $contentType = self::contentTypes['deleteEntityTemplate'][0])
    {
        return $this->deleteEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEntityTemplateAsyncWithHttpInfo
     *
     * Delete Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, string $contentType = self::contentTypes['deleteEntityTemplate'][0])
    {
        $returnType = '';
        $request = $this->deleteEntityTemplateRequest($entityTemplatePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEntityTemplate'
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteEntityTemplateRequest($entityTemplatePublicId, string $contentType = self::contentTypes['deleteEntityTemplate'][0])
    {

        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling deleteEntityTemplate'
            );
        }


        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEpic
     *
     * Delete Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteEpic($epicPublicId, string $contentType = self::contentTypes['deleteEpic'][0])
    {
        $this->deleteEpicWithHttpInfo($epicPublicId, $contentType);
    }

    /**
     * Operation deleteEpicWithHttpInfo
     *
     * Delete Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEpicWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['deleteEpic'][0])
    {
        $request = $this->deleteEpicRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteEpicAsync
     *
     * Delete Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEpicAsync($epicPublicId, string $contentType = self::contentTypes['deleteEpic'][0])
    {
        return $this->deleteEpicAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEpicAsyncWithHttpInfo
     *
     * Delete Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEpicAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['deleteEpic'][0])
    {
        $returnType = '';
        $request = $this->deleteEpicRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEpic'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteEpicRequest($epicPublicId, string $contentType = self::contentTypes['deleteEpic'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling deleteEpic'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEpicComment
     *
     * Delete Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteEpicComment($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteEpicComment'][0])
    {
        $this->deleteEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, $contentType);
    }

    /**
     * Operation deleteEpicCommentWithHttpInfo
     *
     * Delete Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteEpicComment'][0])
    {
        $request = $this->deleteEpicCommentRequest($epicPublicId, $commentPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteEpicCommentAsync
     *
     * Delete Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEpicCommentAsync($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteEpicComment'][0])
    {
        return $this->deleteEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEpicCommentAsyncWithHttpInfo
     *
     * Delete Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteEpicComment'][0])
    {
        $returnType = '';
        $request = $this->deleteEpicCommentRequest($epicPublicId, $commentPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEpicComment'
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteEpicCommentRequest($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteEpicComment'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling deleteEpicComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteEpicComment'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * Delete File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFile($filePublicId, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $this->deleteFileWithHttpInfo($filePublicId, $contentType);
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Delete File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($filePublicId, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $request = $this->deleteFileRequest($filePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * Delete File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($filePublicId, string $contentType = self::contentTypes['deleteFile'][0])
    {
        return $this->deleteFileAsyncWithHttpInfo($filePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Delete File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($filePublicId, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $returnType = '';
        $request = $this->deleteFileRequest($filePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileRequest($filePublicId, string $contentType = self::contentTypes['deleteFile'][0])
    {

        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling deleteFile'
            );
        }


        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGenericIntegration
     *
     * Delete Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteGenericIntegration($integrationPublicId, string $contentType = self::contentTypes['deleteGenericIntegration'][0])
    {
        $this->deleteGenericIntegrationWithHttpInfo($integrationPublicId, $contentType);
    }

    /**
     * Operation deleteGenericIntegrationWithHttpInfo
     *
     * Delete Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGenericIntegrationWithHttpInfo($integrationPublicId, string $contentType = self::contentTypes['deleteGenericIntegration'][0])
    {
        $request = $this->deleteGenericIntegrationRequest($integrationPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteGenericIntegrationAsync
     *
     * Delete Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGenericIntegrationAsync($integrationPublicId, string $contentType = self::contentTypes['deleteGenericIntegration'][0])
    {
        return $this->deleteGenericIntegrationAsyncWithHttpInfo($integrationPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGenericIntegrationAsyncWithHttpInfo
     *
     * Delete Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGenericIntegrationAsyncWithHttpInfo($integrationPublicId, string $contentType = self::contentTypes['deleteGenericIntegration'][0])
    {
        $returnType = '';
        $request = $this->deleteGenericIntegrationRequest($integrationPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGenericIntegration'
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGenericIntegrationRequest($integrationPublicId, string $contentType = self::contentTypes['deleteGenericIntegration'][0])
    {

        // verify the required parameter 'integrationPublicId' is set
        if ($integrationPublicId === null || (is_array($integrationPublicId) && count($integrationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $integrationPublicId when calling deleteGenericIntegration'
            );
        }


        $resourcePath = '/api/v3/integrations/webhook/{integration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($integrationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'integration-public-id' . '}',
                ObjectSerializer::toPathValue($integrationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteIteration
     *
     * Delete Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteIteration($iterationPublicId, string $contentType = self::contentTypes['deleteIteration'][0])
    {
        $this->deleteIterationWithHttpInfo($iterationPublicId, $contentType);
    }

    /**
     * Operation deleteIterationWithHttpInfo
     *
     * Delete Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteIterationWithHttpInfo($iterationPublicId, string $contentType = self::contentTypes['deleteIteration'][0])
    {
        $request = $this->deleteIterationRequest($iterationPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteIterationAsync
     *
     * Delete Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIterationAsync($iterationPublicId, string $contentType = self::contentTypes['deleteIteration'][0])
    {
        return $this->deleteIterationAsyncWithHttpInfo($iterationPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteIterationAsyncWithHttpInfo
     *
     * Delete Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIterationAsyncWithHttpInfo($iterationPublicId, string $contentType = self::contentTypes['deleteIteration'][0])
    {
        $returnType = '';
        $request = $this->deleteIterationRequest($iterationPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteIteration'
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteIterationRequest($iterationPublicId, string $contentType = self::contentTypes['deleteIteration'][0])
    {

        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling deleteIteration'
            );
        }


        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLabel
     *
     * Delete Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLabel($labelPublicId, string $contentType = self::contentTypes['deleteLabel'][0])
    {
        $this->deleteLabelWithHttpInfo($labelPublicId, $contentType);
    }

    /**
     * Operation deleteLabelWithHttpInfo
     *
     * Delete Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLabelWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['deleteLabel'][0])
    {
        $request = $this->deleteLabelRequest($labelPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteLabelAsync
     *
     * Delete Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLabelAsync($labelPublicId, string $contentType = self::contentTypes['deleteLabel'][0])
    {
        return $this->deleteLabelAsyncWithHttpInfo($labelPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLabelAsyncWithHttpInfo
     *
     * Delete Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLabelAsyncWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['deleteLabel'][0])
    {
        $returnType = '';
        $request = $this->deleteLabelRequest($labelPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLabel'
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteLabelRequest($labelPublicId, string $contentType = self::contentTypes['deleteLabel'][0])
    {

        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling deleteLabel'
            );
        }


        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLinkedFile
     *
     * Delete Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLinkedFile($linkedFilePublicId, string $contentType = self::contentTypes['deleteLinkedFile'][0])
    {
        $this->deleteLinkedFileWithHttpInfo($linkedFilePublicId, $contentType);
    }

    /**
     * Operation deleteLinkedFileWithHttpInfo
     *
     * Delete Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLinkedFileWithHttpInfo($linkedFilePublicId, string $contentType = self::contentTypes['deleteLinkedFile'][0])
    {
        $request = $this->deleteLinkedFileRequest($linkedFilePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteLinkedFileAsync
     *
     * Delete Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkedFileAsync($linkedFilePublicId, string $contentType = self::contentTypes['deleteLinkedFile'][0])
    {
        return $this->deleteLinkedFileAsyncWithHttpInfo($linkedFilePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLinkedFileAsyncWithHttpInfo
     *
     * Delete Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkedFileAsyncWithHttpInfo($linkedFilePublicId, string $contentType = self::contentTypes['deleteLinkedFile'][0])
    {
        $returnType = '';
        $request = $this->deleteLinkedFileRequest($linkedFilePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLinkedFile'
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteLinkedFileRequest($linkedFilePublicId, string $contentType = self::contentTypes['deleteLinkedFile'][0])
    {

        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling deleteLinkedFile'
            );
        }


        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMilestone
     *
     * Delete Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMilestone($milestonePublicId, string $contentType = self::contentTypes['deleteMilestone'][0])
    {
        $this->deleteMilestoneWithHttpInfo($milestonePublicId, $contentType);
    }

    /**
     * Operation deleteMilestoneWithHttpInfo
     *
     * Delete Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMilestoneWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['deleteMilestone'][0])
    {
        $request = $this->deleteMilestoneRequest($milestonePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteMilestoneAsync
     *
     * Delete Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMilestoneAsync($milestonePublicId, string $contentType = self::contentTypes['deleteMilestone'][0])
    {
        return $this->deleteMilestoneAsyncWithHttpInfo($milestonePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMilestoneAsyncWithHttpInfo
     *
     * Delete Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMilestoneAsyncWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['deleteMilestone'][0])
    {
        $returnType = '';
        $request = $this->deleteMilestoneRequest($milestonePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMilestone'
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMilestoneRequest($milestonePublicId, string $contentType = self::contentTypes['deleteMilestone'][0])
    {

        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling deleteMilestone'
            );
        }


        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMultipleStories
     *
     * Delete Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\DeleteStories $deleteStories deleteStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMultipleStories($deleteStories, string $contentType = self::contentTypes['deleteMultipleStories'][0])
    {
        $this->deleteMultipleStoriesWithHttpInfo($deleteStories, $contentType);
    }

    /**
     * Operation deleteMultipleStoriesWithHttpInfo
     *
     * Delete Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\DeleteStories $deleteStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMultipleStoriesWithHttpInfo($deleteStories, string $contentType = self::contentTypes['deleteMultipleStories'][0])
    {
        $request = $this->deleteMultipleStoriesRequest($deleteStories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteMultipleStoriesAsync
     *
     * Delete Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\DeleteStories $deleteStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleStoriesAsync($deleteStories, string $contentType = self::contentTypes['deleteMultipleStories'][0])
    {
        return $this->deleteMultipleStoriesAsyncWithHttpInfo($deleteStories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMultipleStoriesAsyncWithHttpInfo
     *
     * Delete Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\DeleteStories $deleteStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleStoriesAsyncWithHttpInfo($deleteStories, string $contentType = self::contentTypes['deleteMultipleStories'][0])
    {
        $returnType = '';
        $request = $this->deleteMultipleStoriesRequest($deleteStories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMultipleStories'
     *
     * @param  \Timetoreply\Shortcut\Model\DeleteStories $deleteStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMultipleStoriesRequest($deleteStories, string $contentType = self::contentTypes['deleteMultipleStories'][0])
    {

        // verify the required parameter 'deleteStories' is set
        if ($deleteStories === null || (is_array($deleteStories) && count($deleteStories) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteStories when calling deleteMultipleStories'
            );
        }


        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteStories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteStories));
            } else {
                $httpBody = $deleteStories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteObjective
     *
     * Delete Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteObjective($objectivePublicId, string $contentType = self::contentTypes['deleteObjective'][0])
    {
        $this->deleteObjectiveWithHttpInfo($objectivePublicId, $contentType);
    }

    /**
     * Operation deleteObjectiveWithHttpInfo
     *
     * Delete Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteObjectiveWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['deleteObjective'][0])
    {
        $request = $this->deleteObjectiveRequest($objectivePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteObjectiveAsync
     *
     * Delete Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteObjectiveAsync($objectivePublicId, string $contentType = self::contentTypes['deleteObjective'][0])
    {
        return $this->deleteObjectiveAsyncWithHttpInfo($objectivePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteObjectiveAsyncWithHttpInfo
     *
     * Delete Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteObjectiveAsyncWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['deleteObjective'][0])
    {
        $returnType = '';
        $request = $this->deleteObjectiveRequest($objectivePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteObjective'
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteObjectiveRequest($objectivePublicId, string $contentType = self::contentTypes['deleteObjective'][0])
    {

        // verify the required parameter 'objectivePublicId' is set
        if ($objectivePublicId === null || (is_array($objectivePublicId) && count($objectivePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectivePublicId when calling deleteObjective'
            );
        }


        $resourcePath = '/api/v3/objectives/{objective-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($objectivePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'objective-public-id' . '}',
                ObjectSerializer::toPathValue($objectivePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProject
     *
     * Delete Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProject($projectPublicId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $this->deleteProjectWithHttpInfo($projectPublicId, $contentType);
    }

    /**
     * Operation deleteProjectWithHttpInfo
     *
     * Delete Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProjectWithHttpInfo($projectPublicId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $request = $this->deleteProjectRequest($projectPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteProjectAsync
     *
     * Delete Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProjectAsync($projectPublicId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        return $this->deleteProjectAsyncWithHttpInfo($projectPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProjectAsyncWithHttpInfo
     *
     * Delete Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProjectAsyncWithHttpInfo($projectPublicId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $returnType = '';
        $request = $this->deleteProjectRequest($projectPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProject'
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteProjectRequest($projectPublicId, string $contentType = self::contentTypes['deleteProject'][0])
    {

        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling deleteProject'
            );
        }


        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStory
     *
     * Delete Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStory($storyPublicId, string $contentType = self::contentTypes['deleteStory'][0])
    {
        $this->deleteStoryWithHttpInfo($storyPublicId, $contentType);
    }

    /**
     * Operation deleteStoryWithHttpInfo
     *
     * Delete Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStoryWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['deleteStory'][0])
    {
        $request = $this->deleteStoryRequest($storyPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteStoryAsync
     *
     * Delete Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryAsync($storyPublicId, string $contentType = self::contentTypes['deleteStory'][0])
    {
        return $this->deleteStoryAsyncWithHttpInfo($storyPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryAsyncWithHttpInfo
     *
     * Delete Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryAsyncWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['deleteStory'][0])
    {
        $returnType = '';
        $request = $this->deleteStoryRequest($storyPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStory'
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStoryRequest($storyPublicId, string $contentType = self::contentTypes['deleteStory'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStory'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryComment
     *
     * Delete Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStoryComment($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteStoryComment'][0])
    {
        $this->deleteStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, $contentType);
    }

    /**
     * Operation deleteStoryCommentWithHttpInfo
     *
     * Delete Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteStoryComment'][0])
    {
        $request = $this->deleteStoryCommentRequest($storyPublicId, $commentPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteStoryCommentAsync
     *
     * Delete Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryCommentAsync($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteStoryComment'][0])
    {
        return $this->deleteStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryCommentAsyncWithHttpInfo
     *
     * Delete Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteStoryComment'][0])
    {
        $returnType = '';
        $request = $this->deleteStoryCommentRequest($storyPublicId, $commentPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStoryComment'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStoryCommentRequest($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['deleteStoryComment'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStoryComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteStoryComment'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryLink
     *
     * Delete Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStoryLink($storyLinkPublicId, string $contentType = self::contentTypes['deleteStoryLink'][0])
    {
        $this->deleteStoryLinkWithHttpInfo($storyLinkPublicId, $contentType);
    }

    /**
     * Operation deleteStoryLinkWithHttpInfo
     *
     * Delete Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStoryLinkWithHttpInfo($storyLinkPublicId, string $contentType = self::contentTypes['deleteStoryLink'][0])
    {
        $request = $this->deleteStoryLinkRequest($storyLinkPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteStoryLinkAsync
     *
     * Delete Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryLinkAsync($storyLinkPublicId, string $contentType = self::contentTypes['deleteStoryLink'][0])
    {
        return $this->deleteStoryLinkAsyncWithHttpInfo($storyLinkPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryLinkAsyncWithHttpInfo
     *
     * Delete Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryLinkAsyncWithHttpInfo($storyLinkPublicId, string $contentType = self::contentTypes['deleteStoryLink'][0])
    {
        $returnType = '';
        $request = $this->deleteStoryLinkRequest($storyLinkPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStoryLink'
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStoryLinkRequest($storyLinkPublicId, string $contentType = self::contentTypes['deleteStoryLink'][0])
    {

        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling deleteStoryLink'
            );
        }


        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStoryReaction
     *
     * Delete Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryReaction'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStoryReaction($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['deleteStoryReaction'][0])
    {
        $this->deleteStoryReactionWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);
    }

    /**
     * Operation deleteStoryReactionWithHttpInfo
     *
     * Delete Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryReaction'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStoryReactionWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['deleteStoryReaction'][0])
    {
        $request = $this->deleteStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteStoryReactionAsync
     *
     * Delete Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryReactionAsync($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['deleteStoryReaction'][0])
    {
        return $this->deleteStoryReactionAsyncWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStoryReactionAsyncWithHttpInfo
     *
     * Delete Story Reaction
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStoryReactionAsyncWithHttpInfo($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['deleteStoryReaction'][0])
    {
        $returnType = '';
        $request = $this->deleteStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStoryReaction'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\CreateOrDeleteStoryReaction $createOrDeleteStoryReaction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStoryReaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStoryReactionRequest($storyPublicId, $commentPublicId, $createOrDeleteStoryReaction, string $contentType = self::contentTypes['deleteStoryReaction'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteStoryReaction'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling deleteStoryReaction'
            );
        }

        // verify the required parameter 'createOrDeleteStoryReaction' is set
        if ($createOrDeleteStoryReaction === null || (is_array($createOrDeleteStoryReaction) && count($createOrDeleteStoryReaction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createOrDeleteStoryReaction when calling deleteStoryReaction'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createOrDeleteStoryReaction)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createOrDeleteStoryReaction));
            } else {
                $httpBody = $createOrDeleteStoryReaction;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTask
     *
     * Delete Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTask($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $this->deleteTaskWithHttpInfo($storyPublicId, $taskPublicId, $contentType);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * Delete Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskWithHttpInfo($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $request = $this->deleteTaskRequest($storyPublicId, $taskPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTaskAsync
     *
     * Delete Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsync($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        return $this->deleteTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * Delete Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($storyPublicId, $taskPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTaskRequest($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['deleteTask'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling deleteTask'
            );
        }

        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling deleteTask'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableIterations
     *
     * Disable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function disableIterations(string $contentType = self::contentTypes['disableIterations'][0])
    {
        $this->disableIterationsWithHttpInfo($contentType);
    }

    /**
     * Operation disableIterationsWithHttpInfo
     *
     * Disable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableIterationsWithHttpInfo(string $contentType = self::contentTypes['disableIterations'][0])
    {
        $request = $this->disableIterationsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation disableIterationsAsync
     *
     * Disable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableIterationsAsync(string $contentType = self::contentTypes['disableIterations'][0])
    {
        return $this->disableIterationsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableIterationsAsyncWithHttpInfo
     *
     * Disable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableIterationsAsyncWithHttpInfo(string $contentType = self::contentTypes['disableIterations'][0])
    {
        $returnType = '';
        $request = $this->disableIterationsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableIterations'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableIterationsRequest(string $contentType = self::contentTypes['disableIterations'][0])
    {


        $resourcePath = '/api/v3/iterations/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableStoryTemplates
     *
     * Disable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function disableStoryTemplates(string $contentType = self::contentTypes['disableStoryTemplates'][0])
    {
        $this->disableStoryTemplatesWithHttpInfo($contentType);
    }

    /**
     * Operation disableStoryTemplatesWithHttpInfo
     *
     * Disable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableStoryTemplatesWithHttpInfo(string $contentType = self::contentTypes['disableStoryTemplates'][0])
    {
        $request = $this->disableStoryTemplatesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation disableStoryTemplatesAsync
     *
     * Disable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableStoryTemplatesAsync(string $contentType = self::contentTypes['disableStoryTemplates'][0])
    {
        return $this->disableStoryTemplatesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableStoryTemplatesAsyncWithHttpInfo
     *
     * Disable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableStoryTemplatesAsyncWithHttpInfo(string $contentType = self::contentTypes['disableStoryTemplates'][0])
    {
        $returnType = '';
        $request = $this->disableStoryTemplatesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableStoryTemplates'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableStoryTemplatesRequest(string $contentType = self::contentTypes['disableStoryTemplates'][0])
    {


        $resourcePath = '/api/v3/entity-templates/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableIterations
     *
     * Enable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enableIterations(string $contentType = self::contentTypes['enableIterations'][0])
    {
        $this->enableIterationsWithHttpInfo($contentType);
    }

    /**
     * Operation enableIterationsWithHttpInfo
     *
     * Enable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableIterationsWithHttpInfo(string $contentType = self::contentTypes['enableIterations'][0])
    {
        $request = $this->enableIterationsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation enableIterationsAsync
     *
     * Enable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableIterationsAsync(string $contentType = self::contentTypes['enableIterations'][0])
    {
        return $this->enableIterationsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableIterationsAsyncWithHttpInfo
     *
     * Enable Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableIterationsAsyncWithHttpInfo(string $contentType = self::contentTypes['enableIterations'][0])
    {
        $returnType = '';
        $request = $this->enableIterationsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableIterations'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableIterationsRequest(string $contentType = self::contentTypes['enableIterations'][0])
    {


        $resourcePath = '/api/v3/iterations/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableStoryTemplates
     *
     * Enable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enableStoryTemplates(string $contentType = self::contentTypes['enableStoryTemplates'][0])
    {
        $this->enableStoryTemplatesWithHttpInfo($contentType);
    }

    /**
     * Operation enableStoryTemplatesWithHttpInfo
     *
     * Enable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableStoryTemplatesWithHttpInfo(string $contentType = self::contentTypes['enableStoryTemplates'][0])
    {
        $request = $this->enableStoryTemplatesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation enableStoryTemplatesAsync
     *
     * Enable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableStoryTemplatesAsync(string $contentType = self::contentTypes['enableStoryTemplates'][0])
    {
        return $this->enableStoryTemplatesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableStoryTemplatesAsyncWithHttpInfo
     *
     * Enable Story Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableStoryTemplatesAsyncWithHttpInfo(string $contentType = self::contentTypes['enableStoryTemplates'][0])
    {
        $returnType = '';
        $request = $this->enableStoryTemplatesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableStoryTemplates'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableStoryTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableStoryTemplatesRequest(string $contentType = self::contentTypes['enableStoryTemplates'][0])
    {


        $resourcePath = '/api/v3/entity-templates/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategory
     *
     * Get Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Category
     */
    public function getCategory($categoryPublicId, string $contentType = self::contentTypes['getCategory'][0])
    {
        list($response) = $this->getCategoryWithHttpInfo($categoryPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getCategoryWithHttpInfo
     *
     * Get Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCategoryWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['getCategory'][0])
    {
        $request = $this->getCategoryRequest($categoryPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Category',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Category',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCategoryAsync
     *
     * Get Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsync($categoryPublicId, string $contentType = self::contentTypes['getCategory'][0])
    {
        return $this->getCategoryAsyncWithHttpInfo($categoryPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoryAsyncWithHttpInfo
     *
     * Get Category
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsyncWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['getCategory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->getCategoryRequest($categoryPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCategory'
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCategoryRequest($categoryPublicId, string $contentType = self::contentTypes['getCategory'][0])
    {

        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling getCategory'
            );
        }


        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentMemberInfo
     *
     * Get Current Member Info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentMemberInfo'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\MemberInfo
     */
    public function getCurrentMemberInfo(string $contentType = self::contentTypes['getCurrentMemberInfo'][0])
    {
        list($response) = $this->getCurrentMemberInfoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getCurrentMemberInfoWithHttpInfo
     *
     * Get Current Member Info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentMemberInfo'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\MemberInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentMemberInfoWithHttpInfo(string $contentType = self::contentTypes['getCurrentMemberInfo'][0])
    {
        $request = $this->getCurrentMemberInfoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MemberInfo',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\MemberInfo',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MemberInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrentMemberInfoAsync
     *
     * Get Current Member Info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentMemberInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentMemberInfoAsync(string $contentType = self::contentTypes['getCurrentMemberInfo'][0])
    {
        return $this->getCurrentMemberInfoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentMemberInfoAsyncWithHttpInfo
     *
     * Get Current Member Info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentMemberInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentMemberInfoAsyncWithHttpInfo(string $contentType = self::contentTypes['getCurrentMemberInfo'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\MemberInfo';
        $request = $this->getCurrentMemberInfoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentMemberInfo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrentMemberInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrentMemberInfoRequest(string $contentType = self::contentTypes['getCurrentMemberInfo'][0])
    {


        $resourcePath = '/api/v3/member';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomField
     *
     * Get Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\CustomField
     */
    public function getCustomField($customFieldPublicId, string $contentType = self::contentTypes['getCustomField'][0])
    {
        list($response) = $this->getCustomFieldWithHttpInfo($customFieldPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getCustomFieldWithHttpInfo
     *
     * Get Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\CustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomFieldWithHttpInfo($customFieldPublicId, string $contentType = self::contentTypes['getCustomField'][0])
    {
        $request = $this->getCustomFieldRequest($customFieldPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\CustomField',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCustomFieldAsync
     *
     * Get Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldAsync($customFieldPublicId, string $contentType = self::contentTypes['getCustomField'][0])
    {
        return $this->getCustomFieldAsyncWithHttpInfo($customFieldPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomFieldAsyncWithHttpInfo
     *
     * Get Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldAsyncWithHttpInfo($customFieldPublicId, string $contentType = self::contentTypes['getCustomField'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->getCustomFieldRequest($customFieldPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomField'
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomFieldRequest($customFieldPublicId, string $contentType = self::contentTypes['getCustomField'][0])
    {

        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling getCustomField'
            );
        }


        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEntityTemplate
     *
     * Get Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EntityTemplate
     */
    public function getEntityTemplate($entityTemplatePublicId, string $contentType = self::contentTypes['getEntityTemplate'][0])
    {
        list($response) = $this->getEntityTemplateWithHttpInfo($entityTemplatePublicId, $contentType);
        return $response;
    }

    /**
     * Operation getEntityTemplateWithHttpInfo
     *
     * Get Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEntityTemplateWithHttpInfo($entityTemplatePublicId, string $contentType = self::contentTypes['getEntityTemplate'][0])
    {
        $request = $this->getEntityTemplateRequest($entityTemplatePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EntityTemplate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEntityTemplateAsync
     *
     * Get Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEntityTemplateAsync($entityTemplatePublicId, string $contentType = self::contentTypes['getEntityTemplate'][0])
    {
        return $this->getEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEntityTemplateAsyncWithHttpInfo
     *
     * Get Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, string $contentType = self::contentTypes['getEntityTemplate'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->getEntityTemplateRequest($entityTemplatePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEntityTemplate'
     *
     * @param  string $entityTemplatePublicId The unique ID of the entity template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEntityTemplateRequest($entityTemplatePublicId, string $contentType = self::contentTypes['getEntityTemplate'][0])
    {

        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling getEntityTemplate'
            );
        }


        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpic
     *
     * Get Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Epic
     */
    public function getEpic($epicPublicId, string $contentType = self::contentTypes['getEpic'][0])
    {
        list($response) = $this->getEpicWithHttpInfo($epicPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getEpicWithHttpInfo
     *
     * Get Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpicWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['getEpic'][0])
    {
        $request = $this->getEpicRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Epic',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Epic',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEpicAsync
     *
     * Get Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicAsync($epicPublicId, string $contentType = self::contentTypes['getEpic'][0])
    {
        return $this->getEpicAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicAsyncWithHttpInfo
     *
     * Get Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['getEpic'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->getEpicRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpic'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEpicRequest($epicPublicId, string $contentType = self::contentTypes['getEpic'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling getEpic'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicComment
     *
     * Get Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ThreadedComment
     */
    public function getEpicComment($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['getEpicComment'][0])
    {
        list($response) = $this->getEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getEpicCommentWithHttpInfo
     *
     * Get Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['getEpicComment'][0])
    {
        $request = $this->getEpicCommentRequest($epicPublicId, $commentPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ThreadedComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEpicCommentAsync
     *
     * Get Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicCommentAsync($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['getEpicComment'][0])
    {
        return $this->getEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicCommentAsyncWithHttpInfo
     *
     * Get Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['getEpicComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->getEpicCommentRequest($epicPublicId, $commentPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpicComment'
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEpicCommentRequest($epicPublicId, $commentPublicId, string $contentType = self::contentTypes['getEpicComment'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling getEpicComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling getEpicComment'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicHealth
     *
     * Get Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Health
     */
    public function getEpicHealth($epicPublicId, string $contentType = self::contentTypes['getEpicHealth'][0])
    {
        list($response) = $this->getEpicHealthWithHttpInfo($epicPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getEpicHealthWithHttpInfo
     *
     * Get Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Health, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpicHealthWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['getEpicHealth'][0])
    {
        $request = $this->getEpicHealthRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Health',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Health',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Health',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEpicHealthAsync
     *
     * Get Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicHealthAsync($epicPublicId, string $contentType = self::contentTypes['getEpicHealth'][0])
    {
        return $this->getEpicHealthAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicHealthAsyncWithHttpInfo
     *
     * Get Epic Health
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicHealthAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['getEpicHealth'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Health';
        $request = $this->getEpicHealthRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpicHealth'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEpicHealthRequest($epicPublicId, string $contentType = self::contentTypes['getEpicHealth'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling getEpicHealth'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/health';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpicWorkflow
     *
     * Get Epic Workflow
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicWorkflow'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicWorkflow
     */
    public function getEpicWorkflow(string $contentType = self::contentTypes['getEpicWorkflow'][0])
    {
        list($response) = $this->getEpicWorkflowWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getEpicWorkflowWithHttpInfo
     *
     * Get Epic Workflow
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicWorkflow'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicWorkflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpicWorkflowWithHttpInfo(string $contentType = self::contentTypes['getEpicWorkflow'][0])
    {
        $request = $this->getEpicWorkflowRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicWorkflow',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicWorkflow',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicWorkflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEpicWorkflowAsync
     *
     * Get Epic Workflow
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicWorkflowAsync(string $contentType = self::contentTypes['getEpicWorkflow'][0])
    {
        return $this->getEpicWorkflowAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpicWorkflowAsyncWithHttpInfo
     *
     * Get Epic Workflow
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpicWorkflowAsyncWithHttpInfo(string $contentType = self::contentTypes['getEpicWorkflow'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicWorkflow';
        $request = $this->getEpicWorkflowRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpicWorkflow'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpicWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEpicWorkflowRequest(string $contentType = self::contentTypes['getEpicWorkflow'][0])
    {


        $resourcePath = '/api/v3/epic-workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExternalLinkStories
     *
     * Get External Link Stories
     *
     * @param  string $externalLink The external link associated with one or more stories. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExternalLinkStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function getExternalLinkStories($externalLink, string $contentType = self::contentTypes['getExternalLinkStories'][0])
    {
        list($response) = $this->getExternalLinkStoriesWithHttpInfo($externalLink, $contentType);
        return $response;
    }

    /**
     * Operation getExternalLinkStoriesWithHttpInfo
     *
     * Get External Link Stories
     *
     * @param  string $externalLink The external link associated with one or more stories. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExternalLinkStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getExternalLinkStoriesWithHttpInfo($externalLink, string $contentType = self::contentTypes['getExternalLinkStories'][0])
    {
        $request = $this->getExternalLinkStoriesRequest($externalLink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getExternalLinkStoriesAsync
     *
     * Get External Link Stories
     *
     * @param  string $externalLink The external link associated with one or more stories. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExternalLinkStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExternalLinkStoriesAsync($externalLink, string $contentType = self::contentTypes['getExternalLinkStories'][0])
    {
        return $this->getExternalLinkStoriesAsyncWithHttpInfo($externalLink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExternalLinkStoriesAsyncWithHttpInfo
     *
     * Get External Link Stories
     *
     * @param  string $externalLink The external link associated with one or more stories. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExternalLinkStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExternalLinkStoriesAsyncWithHttpInfo($externalLink, string $contentType = self::contentTypes['getExternalLinkStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->getExternalLinkStoriesRequest($externalLink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExternalLinkStories'
     *
     * @param  string $externalLink The external link associated with one or more stories. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExternalLinkStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExternalLinkStoriesRequest($externalLink, string $contentType = self::contentTypes['getExternalLinkStories'][0])
    {

        // verify the required parameter 'externalLink' is set
        if ($externalLink === null || (is_array($externalLink) && count($externalLink) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $externalLink when calling getExternalLinkStories'
            );
        }
        if (strlen($externalLink) > 2048) {
            throw new \InvalidArgumentException('invalid length for "$externalLink" when calling DefaultApi.getExternalLinkStories, must be smaller than or equal to 2048.');
        }
        if (!preg_match("/^https?:\/\/.+$/", $externalLink)) {
            throw new \InvalidArgumentException("invalid value for \"externalLink\" when calling DefaultApi.getExternalLinkStories, must conform to the pattern /^https?:\/\/.+$/.");
        }
        

        $resourcePath = '/api/v3/external-link/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $externalLink,
            'external_link', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFile
     *
     * Get File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\UploadedFile
     */
    public function getFile($filePublicId, string $contentType = self::contentTypes['getFile'][0])
    {
        list($response) = $this->getFileWithHttpInfo($filePublicId, $contentType);
        return $response;
    }

    /**
     * Operation getFileWithHttpInfo
     *
     * Get File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileWithHttpInfo($filePublicId, string $contentType = self::contentTypes['getFile'][0])
    {
        $request = $this->getFileRequest($filePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\UploadedFile',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileAsync
     *
     * Get File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsync($filePublicId, string $contentType = self::contentTypes['getFile'][0])
    {
        return $this->getFileAsyncWithHttpInfo($filePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAsyncWithHttpInfo
     *
     * Get File
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsyncWithHttpInfo($filePublicId, string $contentType = self::contentTypes['getFile'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->getFileRequest($filePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFile'
     *
     * @param  int $filePublicId The File’s unique ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileRequest($filePublicId, string $contentType = self::contentTypes['getFile'][0])
    {

        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling getFile'
            );
        }


        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGenericIntegration
     *
     * Get Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getGenericIntegration($integrationPublicId, string $contentType = self::contentTypes['getGenericIntegration'][0])
    {
        $this->getGenericIntegrationWithHttpInfo($integrationPublicId, $contentType);
    }

    /**
     * Operation getGenericIntegrationWithHttpInfo
     *
     * Get Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenericIntegration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGenericIntegrationWithHttpInfo($integrationPublicId, string $contentType = self::contentTypes['getGenericIntegration'][0])
    {
        $request = $this->getGenericIntegrationRequest($integrationPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getGenericIntegrationAsync
     *
     * Get Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenericIntegrationAsync($integrationPublicId, string $contentType = self::contentTypes['getGenericIntegration'][0])
    {
        return $this->getGenericIntegrationAsyncWithHttpInfo($integrationPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGenericIntegrationAsyncWithHttpInfo
     *
     * Get Generic Integration
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenericIntegrationAsyncWithHttpInfo($integrationPublicId, string $contentType = self::contentTypes['getGenericIntegration'][0])
    {
        $returnType = '';
        $request = $this->getGenericIntegrationRequest($integrationPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGenericIntegration'
     *
     * @param  int $integrationPublicId  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenericIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGenericIntegrationRequest($integrationPublicId, string $contentType = self::contentTypes['getGenericIntegration'][0])
    {

        // verify the required parameter 'integrationPublicId' is set
        if ($integrationPublicId === null || (is_array($integrationPublicId) && count($integrationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $integrationPublicId when calling getGenericIntegration'
            );
        }


        $resourcePath = '/api/v3/integrations/webhook/{integration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($integrationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'integration-public-id' . '}',
                ObjectSerializer::toPathValue($integrationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroup
     *
     * Get Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Group
     */
    public function getGroup($groupPublicId, string $contentType = self::contentTypes['getGroup'][0])
    {
        list($response) = $this->getGroupWithHttpInfo($groupPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getGroupWithHttpInfo
     *
     * Get Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupWithHttpInfo($groupPublicId, string $contentType = self::contentTypes['getGroup'][0])
    {
        $request = $this->getGroupRequest($groupPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Group',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Group',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getGroupAsync
     *
     * Get Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsync($groupPublicId, string $contentType = self::contentTypes['getGroup'][0])
    {
        return $this->getGroupAsyncWithHttpInfo($groupPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupAsyncWithHttpInfo
     *
     * Get Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsyncWithHttpInfo($groupPublicId, string $contentType = self::contentTypes['getGroup'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->getGroupRequest($groupPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroup'
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupRequest($groupPublicId, string $contentType = self::contentTypes['getGroup'][0])
    {

        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling getGroup'
            );
        }


        $resourcePath = '/api/v3/groups/{group-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIteration
     *
     * Get Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Iteration
     */
    public function getIteration($iterationPublicId, string $contentType = self::contentTypes['getIteration'][0])
    {
        list($response) = $this->getIterationWithHttpInfo($iterationPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getIterationWithHttpInfo
     *
     * Get Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIterationWithHttpInfo($iterationPublicId, string $contentType = self::contentTypes['getIteration'][0])
    {
        $request = $this->getIterationRequest($iterationPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Iteration',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getIterationAsync
     *
     * Get Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIterationAsync($iterationPublicId, string $contentType = self::contentTypes['getIteration'][0])
    {
        return $this->getIterationAsyncWithHttpInfo($iterationPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIterationAsyncWithHttpInfo
     *
     * Get Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIterationAsyncWithHttpInfo($iterationPublicId, string $contentType = self::contentTypes['getIteration'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->getIterationRequest($iterationPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIteration'
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIterationRequest($iterationPublicId, string $contentType = self::contentTypes['getIteration'][0])
    {

        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling getIteration'
            );
        }


        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKeyResult
     *
     * Get Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getKeyResult'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\KeyResult
     */
    public function getKeyResult($keyResultPublicId, string $contentType = self::contentTypes['getKeyResult'][0])
    {
        list($response) = $this->getKeyResultWithHttpInfo($keyResultPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getKeyResultWithHttpInfo
     *
     * Get Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getKeyResult'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\KeyResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKeyResultWithHttpInfo($keyResultPublicId, string $contentType = self::contentTypes['getKeyResult'][0])
    {
        $request = $this->getKeyResultRequest($keyResultPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\KeyResult',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\KeyResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\KeyResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getKeyResultAsync
     *
     * Get Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeyResultAsync($keyResultPublicId, string $contentType = self::contentTypes['getKeyResult'][0])
    {
        return $this->getKeyResultAsyncWithHttpInfo($keyResultPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKeyResultAsyncWithHttpInfo
     *
     * Get Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeyResultAsyncWithHttpInfo($keyResultPublicId, string $contentType = self::contentTypes['getKeyResult'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\KeyResult';
        $request = $this->getKeyResultRequest($keyResultPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKeyResult'
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getKeyResultRequest($keyResultPublicId, string $contentType = self::contentTypes['getKeyResult'][0])
    {

        // verify the required parameter 'keyResultPublicId' is set
        if ($keyResultPublicId === null || (is_array($keyResultPublicId) && count($keyResultPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyResultPublicId when calling getKeyResult'
            );
        }


        $resourcePath = '/api/v3/key-results/{key-result-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($keyResultPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'key-result-public-id' . '}',
                ObjectSerializer::toPathValue($keyResultPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLabel
     *
     * Get Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Label
     */
    public function getLabel($labelPublicId, string $contentType = self::contentTypes['getLabel'][0])
    {
        list($response) = $this->getLabelWithHttpInfo($labelPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getLabelWithHttpInfo
     *
     * Get Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLabelWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['getLabel'][0])
    {
        $request = $this->getLabelRequest($labelPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Label',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Label',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getLabelAsync
     *
     * Get Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLabelAsync($labelPublicId, string $contentType = self::contentTypes['getLabel'][0])
    {
        return $this->getLabelAsyncWithHttpInfo($labelPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLabelAsyncWithHttpInfo
     *
     * Get Label
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLabelAsyncWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['getLabel'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->getLabelRequest($labelPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLabel'
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLabelRequest($labelPublicId, string $contentType = self::contentTypes['getLabel'][0])
    {

        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling getLabel'
            );
        }


        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLinkedFile
     *
     * Get Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\LinkedFile
     */
    public function getLinkedFile($linkedFilePublicId, string $contentType = self::contentTypes['getLinkedFile'][0])
    {
        list($response) = $this->getLinkedFileWithHttpInfo($linkedFilePublicId, $contentType);
        return $response;
    }

    /**
     * Operation getLinkedFileWithHttpInfo
     *
     * Get Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedFileWithHttpInfo($linkedFilePublicId, string $contentType = self::contentTypes['getLinkedFile'][0])
    {
        $request = $this->getLinkedFileRequest($linkedFilePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\LinkedFile',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getLinkedFileAsync
     *
     * Get Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedFileAsync($linkedFilePublicId, string $contentType = self::contentTypes['getLinkedFile'][0])
    {
        return $this->getLinkedFileAsyncWithHttpInfo($linkedFilePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkedFileAsyncWithHttpInfo
     *
     * Get Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedFileAsyncWithHttpInfo($linkedFilePublicId, string $contentType = self::contentTypes['getLinkedFile'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->getLinkedFileRequest($linkedFilePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkedFile'
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLinkedFileRequest($linkedFilePublicId, string $contentType = self::contentTypes['getLinkedFile'][0])
    {

        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling getLinkedFile'
            );
        }


        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMember
     *
     * Get Member
     *
     * @param  string $memberPublicId The Member&#39;s unique ID. (required)
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the lookup to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMember'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Member
     */
    public function getMember($memberPublicId, $orgPublicId = null, string $contentType = self::contentTypes['getMember'][0])
    {
        list($response) = $this->getMemberWithHttpInfo($memberPublicId, $orgPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getMemberWithHttpInfo
     *
     * Get Member
     *
     * @param  string $memberPublicId The Member&#39;s unique ID. (required)
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the lookup to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMember'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Member, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMemberWithHttpInfo($memberPublicId, $orgPublicId = null, string $contentType = self::contentTypes['getMember'][0])
    {
        $request = $this->getMemberRequest($memberPublicId, $orgPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Member',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Member',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Member',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMemberAsync
     *
     * Get Member
     *
     * @param  string $memberPublicId The Member&#39;s unique ID. (required)
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the lookup to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMemberAsync($memberPublicId, $orgPublicId = null, string $contentType = self::contentTypes['getMember'][0])
    {
        return $this->getMemberAsyncWithHttpInfo($memberPublicId, $orgPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMemberAsyncWithHttpInfo
     *
     * Get Member
     *
     * @param  string $memberPublicId The Member&#39;s unique ID. (required)
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the lookup to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMemberAsyncWithHttpInfo($memberPublicId, $orgPublicId = null, string $contentType = self::contentTypes['getMember'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member';
        $request = $this->getMemberRequest($memberPublicId, $orgPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMember'
     *
     * @param  string $memberPublicId The Member&#39;s unique ID. (required)
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the lookup to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMember'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMemberRequest($memberPublicId, $orgPublicId = null, string $contentType = self::contentTypes['getMember'][0])
    {

        // verify the required parameter 'memberPublicId' is set
        if ($memberPublicId === null || (is_array($memberPublicId) && count($memberPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $memberPublicId when calling getMember'
            );
        }



        $resourcePath = '/api/v3/members/{member-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orgPublicId,
            'org-public-id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($memberPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'member-public-id' . '}',
                ObjectSerializer::toPathValue($memberPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMilestone
     *
     * Get Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone
     */
    public function getMilestone($milestonePublicId, string $contentType = self::contentTypes['getMilestone'][0])
    {
        list($response) = $this->getMilestoneWithHttpInfo($milestonePublicId, $contentType);
        return $response;
    }

    /**
     * Operation getMilestoneWithHttpInfo
     *
     * Get Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMilestoneWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['getMilestone'][0])
    {
        $request = $this->getMilestoneRequest($milestonePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMilestoneAsync
     *
     * Get Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMilestoneAsync($milestonePublicId, string $contentType = self::contentTypes['getMilestone'][0])
    {
        return $this->getMilestoneAsyncWithHttpInfo($milestonePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMilestoneAsyncWithHttpInfo
     *
     * Get Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMilestoneAsyncWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['getMilestone'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->getMilestoneRequest($milestonePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMilestone'
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMilestoneRequest($milestonePublicId, string $contentType = self::contentTypes['getMilestone'][0])
    {

        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling getMilestone'
            );
        }


        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getObjective
     *
     * Get Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Objective
     */
    public function getObjective($objectivePublicId, string $contentType = self::contentTypes['getObjective'][0])
    {
        list($response) = $this->getObjectiveWithHttpInfo($objectivePublicId, $contentType);
        return $response;
    }

    /**
     * Operation getObjectiveWithHttpInfo
     *
     * Get Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Objective, HTTP status code, HTTP response headers (array of strings)
     */
    public function getObjectiveWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['getObjective'][0])
    {
        $request = $this->getObjectiveRequest($objectivePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Objective',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Objective',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Objective',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getObjectiveAsync
     *
     * Get Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getObjectiveAsync($objectivePublicId, string $contentType = self::contentTypes['getObjective'][0])
    {
        return $this->getObjectiveAsyncWithHttpInfo($objectivePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getObjectiveAsyncWithHttpInfo
     *
     * Get Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getObjectiveAsyncWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['getObjective'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Objective';
        $request = $this->getObjectiveRequest($objectivePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getObjective'
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getObjectiveRequest($objectivePublicId, string $contentType = self::contentTypes['getObjective'][0])
    {

        // verify the required parameter 'objectivePublicId' is set
        if ($objectivePublicId === null || (is_array($objectivePublicId) && count($objectivePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectivePublicId when calling getObjective'
            );
        }


        $resourcePath = '/api/v3/objectives/{objective-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($objectivePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'objective-public-id' . '}',
                ObjectSerializer::toPathValue($objectivePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProject
     *
     * Get Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Project
     */
    public function getProject($projectPublicId, string $contentType = self::contentTypes['getProject'][0])
    {
        list($response) = $this->getProjectWithHttpInfo($projectPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getProjectWithHttpInfo
     *
     * Get Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProjectWithHttpInfo($projectPublicId, string $contentType = self::contentTypes['getProject'][0])
    {
        $request = $this->getProjectRequest($projectPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Project',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Project',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProjectAsync
     *
     * Get Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProjectAsync($projectPublicId, string $contentType = self::contentTypes['getProject'][0])
    {
        return $this->getProjectAsyncWithHttpInfo($projectPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProjectAsyncWithHttpInfo
     *
     * Get Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProjectAsyncWithHttpInfo($projectPublicId, string $contentType = self::contentTypes['getProject'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->getProjectRequest($projectPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProject'
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProjectRequest($projectPublicId, string $contentType = self::contentTypes['getProject'][0])
    {

        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling getProject'
            );
        }


        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRepository
     *
     * Get Repository
     *
     * @param  int $repoPublicId The unique ID of the Repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRepository'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Repository
     */
    public function getRepository($repoPublicId, string $contentType = self::contentTypes['getRepository'][0])
    {
        list($response) = $this->getRepositoryWithHttpInfo($repoPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getRepositoryWithHttpInfo
     *
     * Get Repository
     *
     * @param  int $repoPublicId The unique ID of the Repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRepository'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Repository, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryWithHttpInfo($repoPublicId, string $contentType = self::contentTypes['getRepository'][0])
    {
        $request = $this->getRepositoryRequest($repoPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Repository',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Repository',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Repository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRepositoryAsync
     *
     * Get Repository
     *
     * @param  int $repoPublicId The unique ID of the Repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepositoryAsync($repoPublicId, string $contentType = self::contentTypes['getRepository'][0])
    {
        return $this->getRepositoryAsyncWithHttpInfo($repoPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepositoryAsyncWithHttpInfo
     *
     * Get Repository
     *
     * @param  int $repoPublicId The unique ID of the Repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepositoryAsyncWithHttpInfo($repoPublicId, string $contentType = self::contentTypes['getRepository'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository';
        $request = $this->getRepositoryRequest($repoPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepository'
     *
     * @param  int $repoPublicId The unique ID of the Repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRepositoryRequest($repoPublicId, string $contentType = self::contentTypes['getRepository'][0])
    {

        // verify the required parameter 'repoPublicId' is set
        if ($repoPublicId === null || (is_array($repoPublicId) && count($repoPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repoPublicId when calling getRepository'
            );
        }


        $resourcePath = '/api/v3/repositories/{repo-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($repoPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'repo-public-id' . '}',
                ObjectSerializer::toPathValue($repoPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStory
     *
     * Get Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Story
     */
    public function getStory($storyPublicId, string $contentType = self::contentTypes['getStory'][0])
    {
        list($response) = $this->getStoryWithHttpInfo($storyPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getStoryWithHttpInfo
     *
     * Get Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStoryWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['getStory'][0])
    {
        $request = $this->getStoryRequest($storyPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Story',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Story',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getStoryAsync
     *
     * Get Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryAsync($storyPublicId, string $contentType = self::contentTypes['getStory'][0])
    {
        return $this->getStoryAsyncWithHttpInfo($storyPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryAsyncWithHttpInfo
     *
     * Get Story
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryAsyncWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['getStory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->getStoryRequest($storyPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStory'
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStoryRequest($storyPublicId, string $contentType = self::contentTypes['getStory'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getStory'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStoryComment
     *
     * Get Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryComment
     */
    public function getStoryComment($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['getStoryComment'][0])
    {
        list($response) = $this->getStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getStoryCommentWithHttpInfo
     *
     * Get Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['getStoryComment'][0])
    {
        $request = $this->getStoryCommentRequest($storyPublicId, $commentPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getStoryCommentAsync
     *
     * Get Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryCommentAsync($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['getStoryComment'][0])
    {
        return $this->getStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryCommentAsyncWithHttpInfo
     *
     * Get Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['getStoryComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->getStoryCommentRequest($storyPublicId, $commentPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStoryComment'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStoryCommentRequest($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['getStoryComment'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getStoryComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling getStoryComment'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStoryLink
     *
     * Get Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryLink
     */
    public function getStoryLink($storyLinkPublicId, string $contentType = self::contentTypes['getStoryLink'][0])
    {
        list($response) = $this->getStoryLinkWithHttpInfo($storyLinkPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getStoryLinkWithHttpInfo
     *
     * Get Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStoryLinkWithHttpInfo($storyLinkPublicId, string $contentType = self::contentTypes['getStoryLink'][0])
    {
        $request = $this->getStoryLinkRequest($storyLinkPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryLink',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getStoryLinkAsync
     *
     * Get Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryLinkAsync($storyLinkPublicId, string $contentType = self::contentTypes['getStoryLink'][0])
    {
        return $this->getStoryLinkAsyncWithHttpInfo($storyLinkPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStoryLinkAsyncWithHttpInfo
     *
     * Get Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStoryLinkAsyncWithHttpInfo($storyLinkPublicId, string $contentType = self::contentTypes['getStoryLink'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->getStoryLinkRequest($storyLinkPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStoryLink'
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStoryLinkRequest($storyLinkPublicId, string $contentType = self::contentTypes['getStoryLink'][0])
    {

        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling getStoryLink'
            );
        }


        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTask
     *
     * Get Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Task
     */
    public function getTask($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['getTask'][0])
    {
        list($response) = $this->getTaskWithHttpInfo($storyPublicId, $taskPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * Get Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskWithHttpInfo($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['getTask'][0])
    {
        $request = $this->getTaskRequest($storyPublicId, $taskPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Task',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Task',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTaskAsync
     *
     * Get Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsync($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['getTask'][0])
    {
        return $this->getTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * Get Task
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['getTask'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->getTaskRequest($storyPublicId, $taskPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param  int $storyPublicId The unique ID of the Story this Task is associated with. (required)
     * @param  int $taskPublicId The unique ID of the Task. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTaskRequest($storyPublicId, $taskPublicId, string $contentType = self::contentTypes['getTask'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling getTask'
            );
        }

        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling getTask'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWorkflow
     *
     * Get Workflow
     *
     * @param  int $workflowPublicId The ID of the Workflow. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWorkflow'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Workflow
     */
    public function getWorkflow($workflowPublicId, string $contentType = self::contentTypes['getWorkflow'][0])
    {
        list($response) = $this->getWorkflowWithHttpInfo($workflowPublicId, $contentType);
        return $response;
    }

    /**
     * Operation getWorkflowWithHttpInfo
     *
     * Get Workflow
     *
     * @param  int $workflowPublicId The ID of the Workflow. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWorkflow'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Workflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWorkflowWithHttpInfo($workflowPublicId, string $contentType = self::contentTypes['getWorkflow'][0])
    {
        $request = $this->getWorkflowRequest($workflowPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Workflow',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Workflow',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Workflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getWorkflowAsync
     *
     * Get Workflow
     *
     * @param  int $workflowPublicId The ID of the Workflow. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWorkflowAsync($workflowPublicId, string $contentType = self::contentTypes['getWorkflow'][0])
    {
        return $this->getWorkflowAsyncWithHttpInfo($workflowPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWorkflowAsyncWithHttpInfo
     *
     * Get Workflow
     *
     * @param  int $workflowPublicId The ID of the Workflow. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWorkflowAsyncWithHttpInfo($workflowPublicId, string $contentType = self::contentTypes['getWorkflow'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow';
        $request = $this->getWorkflowRequest($workflowPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWorkflow'
     *
     * @param  int $workflowPublicId The ID of the Workflow. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWorkflowRequest($workflowPublicId, string $contentType = self::contentTypes['getWorkflow'][0])
    {

        // verify the required parameter 'workflowPublicId' is set
        if ($workflowPublicId === null || (is_array($workflowPublicId) && count($workflowPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflowPublicId when calling getWorkflow'
            );
        }


        $resourcePath = '/api/v3/workflows/{workflow-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($workflowPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow-public-id' . '}',
                ObjectSerializer::toPathValue($workflowPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategories
     *
     * List Categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Category[]
     */
    public function listCategories(string $contentType = self::contentTypes['listCategories'][0])
    {
        list($response) = $this->listCategoriesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listCategoriesWithHttpInfo
     *
     * List Categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Category[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoriesWithHttpInfo(string $contentType = self::contentTypes['listCategories'][0])
    {
        $request = $this->listCategoriesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Category[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Category[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCategoriesAsync
     *
     * List Categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoriesAsync(string $contentType = self::contentTypes['listCategories'][0])
    {
        return $this->listCategoriesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoriesAsyncWithHttpInfo
     *
     * List Categories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoriesAsyncWithHttpInfo(string $contentType = self::contentTypes['listCategories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category[]';
        $request = $this->listCategoriesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategories'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCategoriesRequest(string $contentType = self::contentTypes['listCategories'][0])
    {


        $resourcePath = '/api/v3/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategoryMilestones
     *
     * List Category Milestones
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone[]
     */
    public function listCategoryMilestones($categoryPublicId, string $contentType = self::contentTypes['listCategoryMilestones'][0])
    {
        list($response) = $this->listCategoryMilestonesWithHttpInfo($categoryPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listCategoryMilestonesWithHttpInfo
     *
     * List Category Milestones
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryMilestonesWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['listCategoryMilestones'][0])
    {
        $request = $this->listCategoryMilestonesRequest($categoryPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCategoryMilestonesAsync
     *
     * List Category Milestones
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryMilestonesAsync($categoryPublicId, string $contentType = self::contentTypes['listCategoryMilestones'][0])
    {
        return $this->listCategoryMilestonesAsyncWithHttpInfo($categoryPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryMilestonesAsyncWithHttpInfo
     *
     * List Category Milestones
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryMilestonesAsyncWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['listCategoryMilestones'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listCategoryMilestonesRequest($categoryPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategoryMilestones'
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCategoryMilestonesRequest($categoryPublicId, string $contentType = self::contentTypes['listCategoryMilestones'][0])
    {

        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling listCategoryMilestones'
            );
        }


        $resourcePath = '/api/v3/categories/{category-public-id}/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategoryObjectives
     *
     * List Category Objectives
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone[]
     */
    public function listCategoryObjectives($categoryPublicId, string $contentType = self::contentTypes['listCategoryObjectives'][0])
    {
        list($response) = $this->listCategoryObjectivesWithHttpInfo($categoryPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listCategoryObjectivesWithHttpInfo
     *
     * List Category Objectives
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryObjectivesWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['listCategoryObjectives'][0])
    {
        $request = $this->listCategoryObjectivesRequest($categoryPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCategoryObjectivesAsync
     *
     * List Category Objectives
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryObjectivesAsync($categoryPublicId, string $contentType = self::contentTypes['listCategoryObjectives'][0])
    {
        return $this->listCategoryObjectivesAsyncWithHttpInfo($categoryPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryObjectivesAsyncWithHttpInfo
     *
     * List Category Objectives
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryObjectivesAsyncWithHttpInfo($categoryPublicId, string $contentType = self::contentTypes['listCategoryObjectives'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listCategoryObjectivesRequest($categoryPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategoryObjectives'
     *
     * @param  int $categoryPublicId The unique ID of the Category. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCategoryObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCategoryObjectivesRequest($categoryPublicId, string $contentType = self::contentTypes['listCategoryObjectives'][0])
    {

        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling listCategoryObjectives'
            );
        }


        $resourcePath = '/api/v3/categories/{category-public-id}/objectives';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCustomFields
     *
     * List Custom Fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomFields'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\CustomField[]
     */
    public function listCustomFields(string $contentType = self::contentTypes['listCustomFields'][0])
    {
        list($response) = $this->listCustomFieldsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listCustomFieldsWithHttpInfo
     *
     * List Custom Fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomFields'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCustomFieldsWithHttpInfo(string $contentType = self::contentTypes['listCustomFields'][0])
    {
        $request = $this->listCustomFieldsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\CustomField[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\CustomField[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCustomFieldsAsync
     *
     * List Custom Fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCustomFieldsAsync(string $contentType = self::contentTypes['listCustomFields'][0])
    {
        return $this->listCustomFieldsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCustomFieldsAsyncWithHttpInfo
     *
     * List Custom Fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCustomFieldsAsyncWithHttpInfo(string $contentType = self::contentTypes['listCustomFields'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField[]';
        $request = $this->listCustomFieldsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCustomFields'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCustomFieldsRequest(string $contentType = self::contentTypes['listCustomFields'][0])
    {


        $resourcePath = '/api/v3/custom-fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDocs
     *
     * List Docs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocs'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\DocSlim[]|\Timetoreply\Shortcut\Model\DisabledFeatureError
     */
    public function listDocs(string $contentType = self::contentTypes['listDocs'][0])
    {
        list($response) = $this->listDocsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listDocsWithHttpInfo
     *
     * List Docs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocs'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\DocSlim[]|\Timetoreply\Shortcut\Model\DisabledFeatureError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDocsWithHttpInfo(string $contentType = self::contentTypes['listDocs'][0])
    {
        $request = $this->listDocsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\DocSlim[]',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\DisabledFeatureError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\DocSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DocSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DisabledFeatureError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listDocsAsync
     *
     * List Docs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocsAsync(string $contentType = self::contentTypes['listDocs'][0])
    {
        return $this->listDocsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDocsAsyncWithHttpInfo
     *
     * List Docs
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocsAsyncWithHttpInfo(string $contentType = self::contentTypes['listDocs'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\DocSlim[]';
        $request = $this->listDocsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDocs'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDocsRequest(string $contentType = self::contentTypes['listDocs'][0])
    {


        $resourcePath = '/api/v3/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEntityTemplates
     *
     * List Entity Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEntityTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EntityTemplate[]
     */
    public function listEntityTemplates(string $contentType = self::contentTypes['listEntityTemplates'][0])
    {
        list($response) = $this->listEntityTemplatesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listEntityTemplatesWithHttpInfo
     *
     * List Entity Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEntityTemplates'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEntityTemplatesWithHttpInfo(string $contentType = self::contentTypes['listEntityTemplates'][0])
    {
        $request = $this->listEntityTemplatesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EntityTemplate[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EntityTemplate[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEntityTemplatesAsync
     *
     * List Entity Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEntityTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEntityTemplatesAsync(string $contentType = self::contentTypes['listEntityTemplates'][0])
    {
        return $this->listEntityTemplatesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEntityTemplatesAsyncWithHttpInfo
     *
     * List Entity Templates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEntityTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEntityTemplatesAsyncWithHttpInfo(string $contentType = self::contentTypes['listEntityTemplates'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate[]';
        $request = $this->listEntityTemplatesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEntityTemplates'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEntityTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEntityTemplatesRequest(string $contentType = self::contentTypes['listEntityTemplates'][0])
    {


        $resourcePath = '/api/v3/entity-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicComments
     *
     * List Epic Comments
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicComments'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ThreadedComment[]
     */
    public function listEpicComments($epicPublicId, string $contentType = self::contentTypes['listEpicComments'][0])
    {
        list($response) = $this->listEpicCommentsWithHttpInfo($epicPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listEpicCommentsWithHttpInfo
     *
     * List Epic Comments
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicComments'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEpicCommentsWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['listEpicComments'][0])
    {
        $request = $this->listEpicCommentsRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ThreadedComment[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ThreadedComment[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEpicCommentsAsync
     *
     * List Epic Comments
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicCommentsAsync($epicPublicId, string $contentType = self::contentTypes['listEpicComments'][0])
    {
        return $this->listEpicCommentsAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicCommentsAsyncWithHttpInfo
     *
     * List Epic Comments
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicCommentsAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['listEpicComments'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment[]';
        $request = $this->listEpicCommentsRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEpicComments'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEpicCommentsRequest($epicPublicId, string $contentType = self::contentTypes['listEpicComments'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling listEpicComments'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicHealths
     *
     * List Epic Healths
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicHealths'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Health[]
     */
    public function listEpicHealths($epicPublicId, string $contentType = self::contentTypes['listEpicHealths'][0])
    {
        list($response) = $this->listEpicHealthsWithHttpInfo($epicPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listEpicHealthsWithHttpInfo
     *
     * List Epic Healths
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicHealths'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Health[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEpicHealthsWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['listEpicHealths'][0])
    {
        $request = $this->listEpicHealthsRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Health[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Health[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Health[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEpicHealthsAsync
     *
     * List Epic Healths
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicHealths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicHealthsAsync($epicPublicId, string $contentType = self::contentTypes['listEpicHealths'][0])
    {
        return $this->listEpicHealthsAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicHealthsAsyncWithHttpInfo
     *
     * List Epic Healths
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicHealths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicHealthsAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['listEpicHealths'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Health[]';
        $request = $this->listEpicHealthsRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEpicHealths'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicHealths'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEpicHealthsRequest($epicPublicId, string $contentType = self::contentTypes['listEpicHealths'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling listEpicHealths'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/health-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicStories
     *
     * List Epic Stories
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function listEpicStories($epicPublicId, $includesDescription = null, string $contentType = self::contentTypes['listEpicStories'][0])
    {
        list($response) = $this->listEpicStoriesWithHttpInfo($epicPublicId, $includesDescription, $contentType);
        return $response;
    }

    /**
     * Operation listEpicStoriesWithHttpInfo
     *
     * List Epic Stories
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEpicStoriesWithHttpInfo($epicPublicId, $includesDescription = null, string $contentType = self::contentTypes['listEpicStories'][0])
    {
        $request = $this->listEpicStoriesRequest($epicPublicId, $includesDescription, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEpicStoriesAsync
     *
     * List Epic Stories
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicStoriesAsync($epicPublicId, $includesDescription = null, string $contentType = self::contentTypes['listEpicStories'][0])
    {
        return $this->listEpicStoriesAsyncWithHttpInfo($epicPublicId, $includesDescription, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicStoriesAsyncWithHttpInfo
     *
     * List Epic Stories
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicStoriesAsyncWithHttpInfo($epicPublicId, $includesDescription = null, string $contentType = self::contentTypes['listEpicStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listEpicStoriesRequest($epicPublicId, $includesDescription, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEpicStories'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEpicStoriesRequest($epicPublicId, $includesDescription = null, string $contentType = self::contentTypes['listEpicStories'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling listEpicStories'
            );
        }



        $resourcePath = '/api/v3/epics/{epic-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpics
     *
     * List Epics
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicSlim[]
     */
    public function listEpics($includesDescription = null, string $contentType = self::contentTypes['listEpics'][0])
    {
        list($response) = $this->listEpicsWithHttpInfo($includesDescription, $contentType);
        return $response;
    }

    /**
     * Operation listEpicsWithHttpInfo
     *
     * List Epics
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEpicsWithHttpInfo($includesDescription = null, string $contentType = self::contentTypes['listEpics'][0])
    {
        $request = $this->listEpicsRequest($includesDescription, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEpicsAsync
     *
     * List Epics
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicsAsync($includesDescription = null, string $contentType = self::contentTypes['listEpics'][0])
    {
        return $this->listEpicsAsyncWithHttpInfo($includesDescription, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicsAsyncWithHttpInfo
     *
     * List Epics
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicsAsyncWithHttpInfo($includesDescription = null, string $contentType = self::contentTypes['listEpics'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listEpicsRequest($includesDescription, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEpics'
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEpicsRequest($includesDescription = null, string $contentType = self::contentTypes['listEpics'][0])
    {



        $resourcePath = '/api/v3/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEpicsPaginated
     *
     * List Epics Paginated
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  int|null $page The page number to return, starting with 1. Defaults to 1. (optional)
     * @param  int|null $pageSize The number of Epics to return per page. Minimum 1, maximum 250, default 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicsPaginated'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicPaginatedResults
     */
    public function listEpicsPaginated($includesDescription = null, $page = null, $pageSize = null, string $contentType = self::contentTypes['listEpicsPaginated'][0])
    {
        list($response) = $this->listEpicsPaginatedWithHttpInfo($includesDescription, $page, $pageSize, $contentType);
        return $response;
    }

    /**
     * Operation listEpicsPaginatedWithHttpInfo
     *
     * List Epics Paginated
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  int|null $page The page number to return, starting with 1. Defaults to 1. (optional)
     * @param  int|null $pageSize The number of Epics to return per page. Minimum 1, maximum 250, default 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicsPaginated'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicPaginatedResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEpicsPaginatedWithHttpInfo($includesDescription = null, $page = null, $pageSize = null, string $contentType = self::contentTypes['listEpicsPaginated'][0])
    {
        $request = $this->listEpicsPaginatedRequest($includesDescription, $page, $pageSize, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicPaginatedResults',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicPaginatedResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicPaginatedResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEpicsPaginatedAsync
     *
     * List Epics Paginated
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  int|null $page The page number to return, starting with 1. Defaults to 1. (optional)
     * @param  int|null $pageSize The number of Epics to return per page. Minimum 1, maximum 250, default 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicsPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicsPaginatedAsync($includesDescription = null, $page = null, $pageSize = null, string $contentType = self::contentTypes['listEpicsPaginated'][0])
    {
        return $this->listEpicsPaginatedAsyncWithHttpInfo($includesDescription, $page, $pageSize, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEpicsPaginatedAsyncWithHttpInfo
     *
     * List Epics Paginated
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  int|null $page The page number to return, starting with 1. Defaults to 1. (optional)
     * @param  int|null $pageSize The number of Epics to return per page. Minimum 1, maximum 250, default 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicsPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEpicsPaginatedAsyncWithHttpInfo($includesDescription = null, $page = null, $pageSize = null, string $contentType = self::contentTypes['listEpicsPaginated'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicPaginatedResults';
        $request = $this->listEpicsPaginatedRequest($includesDescription, $page, $pageSize, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEpicsPaginated'
     *
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Epics with their descriptions. (optional)
     * @param  int|null $page The page number to return, starting with 1. Defaults to 1. (optional)
     * @param  int|null $pageSize The number of Epics to return per page. Minimum 1, maximum 250, default 10. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEpicsPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEpicsPaginatedRequest($includesDescription = null, $page = null, $pageSize = null, string $contentType = self::contentTypes['listEpicsPaginated'][0])
    {





        $resourcePath = '/api/v3/epics/paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFiles
     *
     * List Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\UploadedFile[]
     */
    public function listFiles(string $contentType = self::contentTypes['listFiles'][0])
    {
        list($response) = $this->listFilesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listFilesWithHttpInfo
     *
     * List Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFilesWithHttpInfo(string $contentType = self::contentTypes['listFiles'][0])
    {
        $request = $this->listFilesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\UploadedFile[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listFilesAsync
     *
     * List Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFilesAsync(string $contentType = self::contentTypes['listFiles'][0])
    {
        return $this->listFilesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFilesAsyncWithHttpInfo
     *
     * List Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFilesAsyncWithHttpInfo(string $contentType = self::contentTypes['listFiles'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->listFilesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFiles'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFilesRequest(string $contentType = self::contentTypes['listFiles'][0])
    {


        $resourcePath = '/api/v3/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGroupStories
     *
     * List Group Stories
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  int|null $limit The maximum number of results to return. (Defaults to 1000, max 1000) (optional)
     * @param  int|null $offset The offset at which to begin returning results. (Defaults to 0) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroupStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function listGroupStories($groupPublicId, $limit = null, $offset = null, string $contentType = self::contentTypes['listGroupStories'][0])
    {
        list($response) = $this->listGroupStoriesWithHttpInfo($groupPublicId, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listGroupStoriesWithHttpInfo
     *
     * List Group Stories
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  int|null $limit The maximum number of results to return. (Defaults to 1000, max 1000) (optional)
     * @param  int|null $offset The offset at which to begin returning results. (Defaults to 0) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroupStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listGroupStoriesWithHttpInfo($groupPublicId, $limit = null, $offset = null, string $contentType = self::contentTypes['listGroupStories'][0])
    {
        $request = $this->listGroupStoriesRequest($groupPublicId, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listGroupStoriesAsync
     *
     * List Group Stories
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  int|null $limit The maximum number of results to return. (Defaults to 1000, max 1000) (optional)
     * @param  int|null $offset The offset at which to begin returning results. (Defaults to 0) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroupStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGroupStoriesAsync($groupPublicId, $limit = null, $offset = null, string $contentType = self::contentTypes['listGroupStories'][0])
    {
        return $this->listGroupStoriesAsyncWithHttpInfo($groupPublicId, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGroupStoriesAsyncWithHttpInfo
     *
     * List Group Stories
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  int|null $limit The maximum number of results to return. (Defaults to 1000, max 1000) (optional)
     * @param  int|null $offset The offset at which to begin returning results. (Defaults to 0) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroupStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGroupStoriesAsyncWithHttpInfo($groupPublicId, $limit = null, $offset = null, string $contentType = self::contentTypes['listGroupStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listGroupStoriesRequest($groupPublicId, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGroupStories'
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  int|null $limit The maximum number of results to return. (Defaults to 1000, max 1000) (optional)
     * @param  int|null $offset The offset at which to begin returning results. (Defaults to 0) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroupStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGroupStoriesRequest($groupPublicId, $limit = null, $offset = null, string $contentType = self::contentTypes['listGroupStories'][0])
    {

        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling listGroupStories'
            );
        }




        $resourcePath = '/api/v3/groups/{group-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGroups
     *
     * List Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroups'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Group[]
     */
    public function listGroups(string $contentType = self::contentTypes['listGroups'][0])
    {
        list($response) = $this->listGroupsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listGroupsWithHttpInfo
     *
     * List Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroups'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listGroupsWithHttpInfo(string $contentType = self::contentTypes['listGroups'][0])
    {
        $request = $this->listGroupsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Group[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Group[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listGroupsAsync
     *
     * List Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGroupsAsync(string $contentType = self::contentTypes['listGroups'][0])
    {
        return $this->listGroupsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGroupsAsyncWithHttpInfo
     *
     * List Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listGroupsAsyncWithHttpInfo(string $contentType = self::contentTypes['listGroups'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group[]';
        $request = $this->listGroupsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGroups'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGroupsRequest(string $contentType = self::contentTypes['listGroups'][0])
    {


        $resourcePath = '/api/v3/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIterationStories
     *
     * List Iteration Stories
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterationStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function listIterationStories($iterationPublicId, $includesDescription = null, string $contentType = self::contentTypes['listIterationStories'][0])
    {
        list($response) = $this->listIterationStoriesWithHttpInfo($iterationPublicId, $includesDescription, $contentType);
        return $response;
    }

    /**
     * Operation listIterationStoriesWithHttpInfo
     *
     * List Iteration Stories
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterationStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listIterationStoriesWithHttpInfo($iterationPublicId, $includesDescription = null, string $contentType = self::contentTypes['listIterationStories'][0])
    {
        $request = $this->listIterationStoriesRequest($iterationPublicId, $includesDescription, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listIterationStoriesAsync
     *
     * List Iteration Stories
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterationStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIterationStoriesAsync($iterationPublicId, $includesDescription = null, string $contentType = self::contentTypes['listIterationStories'][0])
    {
        return $this->listIterationStoriesAsyncWithHttpInfo($iterationPublicId, $includesDescription, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIterationStoriesAsyncWithHttpInfo
     *
     * List Iteration Stories
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterationStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIterationStoriesAsyncWithHttpInfo($iterationPublicId, $includesDescription = null, string $contentType = self::contentTypes['listIterationStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listIterationStoriesRequest($iterationPublicId, $includesDescription, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIterationStories'
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterationStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listIterationStoriesRequest($iterationPublicId, $includesDescription = null, string $contentType = self::contentTypes['listIterationStories'][0])
    {

        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling listIterationStories'
            );
        }



        $resourcePath = '/api/v3/iterations/{iteration-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIterations
     *
     * List Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\IterationSlim[]
     */
    public function listIterations(string $contentType = self::contentTypes['listIterations'][0])
    {
        list($response) = $this->listIterationsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listIterationsWithHttpInfo
     *
     * List Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\IterationSlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listIterationsWithHttpInfo(string $contentType = self::contentTypes['listIterations'][0])
    {
        $request = $this->listIterationsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\IterationSlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\IterationSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\IterationSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listIterationsAsync
     *
     * List Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIterationsAsync(string $contentType = self::contentTypes['listIterations'][0])
    {
        return $this->listIterationsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIterationsAsyncWithHttpInfo
     *
     * List Iterations
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIterationsAsyncWithHttpInfo(string $contentType = self::contentTypes['listIterations'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSlim[]';
        $request = $this->listIterationsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIterations'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listIterationsRequest(string $contentType = self::contentTypes['listIterations'][0])
    {


        $resourcePath = '/api/v3/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabelEpics
     *
     * List Label Epics
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicSlim[]
     */
    public function listLabelEpics($labelPublicId, string $contentType = self::contentTypes['listLabelEpics'][0])
    {
        list($response) = $this->listLabelEpicsWithHttpInfo($labelPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listLabelEpicsWithHttpInfo
     *
     * List Label Epics
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLabelEpicsWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['listLabelEpics'][0])
    {
        $request = $this->listLabelEpicsRequest($labelPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listLabelEpicsAsync
     *
     * List Label Epics
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelEpicsAsync($labelPublicId, string $contentType = self::contentTypes['listLabelEpics'][0])
    {
        return $this->listLabelEpicsAsyncWithHttpInfo($labelPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelEpicsAsyncWithHttpInfo
     *
     * List Label Epics
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelEpicsAsyncWithHttpInfo($labelPublicId, string $contentType = self::contentTypes['listLabelEpics'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listLabelEpicsRequest($labelPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLabelEpics'
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLabelEpicsRequest($labelPublicId, string $contentType = self::contentTypes['listLabelEpics'][0])
    {

        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling listLabelEpics'
            );
        }


        $resourcePath = '/api/v3/labels/{label-public-id}/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabelStories
     *
     * List Label Stories
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function listLabelStories($labelPublicId, $includesDescription = null, string $contentType = self::contentTypes['listLabelStories'][0])
    {
        list($response) = $this->listLabelStoriesWithHttpInfo($labelPublicId, $includesDescription, $contentType);
        return $response;
    }

    /**
     * Operation listLabelStoriesWithHttpInfo
     *
     * List Label Stories
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLabelStoriesWithHttpInfo($labelPublicId, $includesDescription = null, string $contentType = self::contentTypes['listLabelStories'][0])
    {
        $request = $this->listLabelStoriesRequest($labelPublicId, $includesDescription, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listLabelStoriesAsync
     *
     * List Label Stories
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelStoriesAsync($labelPublicId, $includesDescription = null, string $contentType = self::contentTypes['listLabelStories'][0])
    {
        return $this->listLabelStoriesAsyncWithHttpInfo($labelPublicId, $includesDescription, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelStoriesAsyncWithHttpInfo
     *
     * List Label Stories
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelStoriesAsyncWithHttpInfo($labelPublicId, $includesDescription = null, string $contentType = self::contentTypes['listLabelStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listLabelStoriesRequest($labelPublicId, $includesDescription, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLabelStories'
     *
     * @param  int $labelPublicId The unique ID of the Label. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabelStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLabelStoriesRequest($labelPublicId, $includesDescription = null, string $contentType = self::contentTypes['listLabelStories'][0])
    {

        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling listLabelStories'
            );
        }



        $resourcePath = '/api/v3/labels/{label-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLabels
     *
     * List Labels
     *
     * @param  bool|null $slim A true/false boolean indicating if the slim versions of the Label should be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabels'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Label[]
     */
    public function listLabels($slim = null, string $contentType = self::contentTypes['listLabels'][0])
    {
        list($response) = $this->listLabelsWithHttpInfo($slim, $contentType);
        return $response;
    }

    /**
     * Operation listLabelsWithHttpInfo
     *
     * List Labels
     *
     * @param  bool|null $slim A true/false boolean indicating if the slim versions of the Label should be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabels'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLabelsWithHttpInfo($slim = null, string $contentType = self::contentTypes['listLabels'][0])
    {
        $request = $this->listLabelsRequest($slim, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Label[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Label[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listLabelsAsync
     *
     * List Labels
     *
     * @param  bool|null $slim A true/false boolean indicating if the slim versions of the Label should be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelsAsync($slim = null, string $contentType = self::contentTypes['listLabels'][0])
    {
        return $this->listLabelsAsyncWithHttpInfo($slim, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLabelsAsyncWithHttpInfo
     *
     * List Labels
     *
     * @param  bool|null $slim A true/false boolean indicating if the slim versions of the Label should be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLabelsAsyncWithHttpInfo($slim = null, string $contentType = self::contentTypes['listLabels'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label[]';
        $request = $this->listLabelsRequest($slim, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLabels'
     *
     * @param  bool|null $slim A true/false boolean indicating if the slim versions of the Label should be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLabels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLabelsRequest($slim = null, string $contentType = self::contentTypes['listLabels'][0])
    {



        $resourcePath = '/api/v3/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slim,
            'slim', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLinkedFiles
     *
     * List Linked Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLinkedFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\LinkedFile[]
     */
    public function listLinkedFiles(string $contentType = self::contentTypes['listLinkedFiles'][0])
    {
        list($response) = $this->listLinkedFilesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listLinkedFilesWithHttpInfo
     *
     * List Linked Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLinkedFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLinkedFilesWithHttpInfo(string $contentType = self::contentTypes['listLinkedFiles'][0])
    {
        $request = $this->listLinkedFilesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\LinkedFile[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\LinkedFile[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listLinkedFilesAsync
     *
     * List Linked Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLinkedFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLinkedFilesAsync(string $contentType = self::contentTypes['listLinkedFiles'][0])
    {
        return $this->listLinkedFilesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLinkedFilesAsyncWithHttpInfo
     *
     * List Linked Files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLinkedFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLinkedFilesAsyncWithHttpInfo(string $contentType = self::contentTypes['listLinkedFiles'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile[]';
        $request = $this->listLinkedFilesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLinkedFiles'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLinkedFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLinkedFilesRequest(string $contentType = self::contentTypes['listLinkedFiles'][0])
    {


        $resourcePath = '/api/v3/linked-files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMembers
     *
     * List Members
     *
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the list to. (optional)
     * @param  bool|null $disabled Filter members by their disabled state. If true, return only disabled members. If false, return only enabled members. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Member[]
     */
    public function listMembers($orgPublicId = null, $disabled = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        list($response) = $this->listMembersWithHttpInfo($orgPublicId, $disabled, $contentType);
        return $response;
    }

    /**
     * Operation listMembersWithHttpInfo
     *
     * List Members
     *
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the list to. (optional)
     * @param  bool|null $disabled Filter members by their disabled state. If true, return only disabled members. If false, return only enabled members. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Member[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMembersWithHttpInfo($orgPublicId = null, $disabled = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        $request = $this->listMembersRequest($orgPublicId, $disabled, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Member[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Member[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Member[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMembersAsync
     *
     * List Members
     *
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the list to. (optional)
     * @param  bool|null $disabled Filter members by their disabled state. If true, return only disabled members. If false, return only enabled members. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsync($orgPublicId = null, $disabled = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        return $this->listMembersAsyncWithHttpInfo($orgPublicId, $disabled, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMembersAsyncWithHttpInfo
     *
     * List Members
     *
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the list to. (optional)
     * @param  bool|null $disabled Filter members by their disabled state. If true, return only disabled members. If false, return only enabled members. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMembersAsyncWithHttpInfo($orgPublicId = null, $disabled = null, string $contentType = self::contentTypes['listMembers'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Member[]';
        $request = $this->listMembersRequest($orgPublicId, $disabled, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMembers'
     *
     * @param  string|null $orgPublicId The unique ID of the Organization to limit the list to. (optional)
     * @param  bool|null $disabled Filter members by their disabled state. If true, return only disabled members. If false, return only enabled members. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMembersRequest($orgPublicId = null, $disabled = null, string $contentType = self::contentTypes['listMembers'][0])
    {




        $resourcePath = '/api/v3/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orgPublicId,
            'org-public-id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disabled,
            'disabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMilestoneEpics
     *
     * List Milestone Epics
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestoneEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicSlim[]
     */
    public function listMilestoneEpics($milestonePublicId, string $contentType = self::contentTypes['listMilestoneEpics'][0])
    {
        list($response) = $this->listMilestoneEpicsWithHttpInfo($milestonePublicId, $contentType);
        return $response;
    }

    /**
     * Operation listMilestoneEpicsWithHttpInfo
     *
     * List Milestone Epics
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestoneEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMilestoneEpicsWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['listMilestoneEpics'][0])
    {
        $request = $this->listMilestoneEpicsRequest($milestonePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMilestoneEpicsAsync
     *
     * List Milestone Epics
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestoneEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMilestoneEpicsAsync($milestonePublicId, string $contentType = self::contentTypes['listMilestoneEpics'][0])
    {
        return $this->listMilestoneEpicsAsyncWithHttpInfo($milestonePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMilestoneEpicsAsyncWithHttpInfo
     *
     * List Milestone Epics
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestoneEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMilestoneEpicsAsyncWithHttpInfo($milestonePublicId, string $contentType = self::contentTypes['listMilestoneEpics'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listMilestoneEpicsRequest($milestonePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMilestoneEpics'
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestoneEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMilestoneEpicsRequest($milestonePublicId, string $contentType = self::contentTypes['listMilestoneEpics'][0])
    {

        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling listMilestoneEpics'
            );
        }


        $resourcePath = '/api/v3/milestones/{milestone-public-id}/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMilestones
     *
     * List Milestones
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone[]
     */
    public function listMilestones(string $contentType = self::contentTypes['listMilestones'][0])
    {
        list($response) = $this->listMilestonesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listMilestonesWithHttpInfo
     *
     * List Milestones
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMilestonesWithHttpInfo(string $contentType = self::contentTypes['listMilestones'][0])
    {
        $request = $this->listMilestonesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMilestonesAsync
     *
     * List Milestones
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMilestonesAsync(string $contentType = self::contentTypes['listMilestones'][0])
    {
        return $this->listMilestonesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMilestonesAsyncWithHttpInfo
     *
     * List Milestones
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMilestonesAsyncWithHttpInfo(string $contentType = self::contentTypes['listMilestones'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone[]';
        $request = $this->listMilestonesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMilestones'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMilestonesRequest(string $contentType = self::contentTypes['listMilestones'][0])
    {


        $resourcePath = '/api/v3/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listObjectiveEpics
     *
     * List Objective Epics
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectiveEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicSlim[]
     */
    public function listObjectiveEpics($objectivePublicId, string $contentType = self::contentTypes['listObjectiveEpics'][0])
    {
        list($response) = $this->listObjectiveEpicsWithHttpInfo($objectivePublicId, $contentType);
        return $response;
    }

    /**
     * Operation listObjectiveEpicsWithHttpInfo
     *
     * List Objective Epics
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectiveEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicSlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listObjectiveEpicsWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['listObjectiveEpics'][0])
    {
        $request = $this->listObjectiveEpicsRequest($objectivePublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicSlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listObjectiveEpicsAsync
     *
     * List Objective Epics
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectiveEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listObjectiveEpicsAsync($objectivePublicId, string $contentType = self::contentTypes['listObjectiveEpics'][0])
    {
        return $this->listObjectiveEpicsAsyncWithHttpInfo($objectivePublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listObjectiveEpicsAsyncWithHttpInfo
     *
     * List Objective Epics
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectiveEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listObjectiveEpicsAsyncWithHttpInfo($objectivePublicId, string $contentType = self::contentTypes['listObjectiveEpics'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSlim[]';
        $request = $this->listObjectiveEpicsRequest($objectivePublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listObjectiveEpics'
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectiveEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listObjectiveEpicsRequest($objectivePublicId, string $contentType = self::contentTypes['listObjectiveEpics'][0])
    {

        // verify the required parameter 'objectivePublicId' is set
        if ($objectivePublicId === null || (is_array($objectivePublicId) && count($objectivePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectivePublicId when calling listObjectiveEpics'
            );
        }


        $resourcePath = '/api/v3/objectives/{objective-public-id}/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($objectivePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'objective-public-id' . '}',
                ObjectSerializer::toPathValue($objectivePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listObjectives
     *
     * List Objectives
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Objective[]
     */
    public function listObjectives(string $contentType = self::contentTypes['listObjectives'][0])
    {
        list($response) = $this->listObjectivesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listObjectivesWithHttpInfo
     *
     * List Objectives
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Objective[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listObjectivesWithHttpInfo(string $contentType = self::contentTypes['listObjectives'][0])
    {
        $request = $this->listObjectivesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Objective[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Objective[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Objective[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listObjectivesAsync
     *
     * List Objectives
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listObjectivesAsync(string $contentType = self::contentTypes['listObjectives'][0])
    {
        return $this->listObjectivesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listObjectivesAsyncWithHttpInfo
     *
     * List Objectives
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listObjectivesAsyncWithHttpInfo(string $contentType = self::contentTypes['listObjectives'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Objective[]';
        $request = $this->listObjectivesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listObjectives'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listObjectivesRequest(string $contentType = self::contentTypes['listObjectives'][0])
    {


        $resourcePath = '/api/v3/objectives';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProjects
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Project[]
     */
    public function listProjects(string $contentType = self::contentTypes['listProjects'][0])
    {
        list($response) = $this->listProjectsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listProjectsWithHttpInfo
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Project[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listProjectsWithHttpInfo(string $contentType = self::contentTypes['listProjects'][0])
    {
        $request = $this->listProjectsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Project[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Project[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listProjectsAsync
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProjectsAsync(string $contentType = self::contentTypes['listProjects'][0])
    {
        return $this->listProjectsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProjectsAsyncWithHttpInfo
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProjectsAsyncWithHttpInfo(string $contentType = self::contentTypes['listProjects'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project[]';
        $request = $this->listProjectsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProjects'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listProjectsRequest(string $contentType = self::contentTypes['listProjects'][0])
    {


        $resourcePath = '/api/v3/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRepositories
     *
     * List Repositories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRepositories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Repository[]
     */
    public function listRepositories(string $contentType = self::contentTypes['listRepositories'][0])
    {
        list($response) = $this->listRepositoriesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listRepositoriesWithHttpInfo
     *
     * List Repositories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRepositories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Repository[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listRepositoriesWithHttpInfo(string $contentType = self::contentTypes['listRepositories'][0])
    {
        $request = $this->listRepositoriesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Repository[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Repository[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Repository[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listRepositoriesAsync
     *
     * List Repositories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRepositories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRepositoriesAsync(string $contentType = self::contentTypes['listRepositories'][0])
    {
        return $this->listRepositoriesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRepositoriesAsyncWithHttpInfo
     *
     * List Repositories
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRepositories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRepositoriesAsyncWithHttpInfo(string $contentType = self::contentTypes['listRepositories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Repository[]';
        $request = $this->listRepositoriesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRepositories'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRepositories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listRepositoriesRequest(string $contentType = self::contentTypes['listRepositories'][0])
    {


        $resourcePath = '/api/v3/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStories
     *
     * List Stories
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function listStories($projectPublicId, $includesDescription = null, string $contentType = self::contentTypes['listStories'][0])
    {
        list($response) = $this->listStoriesWithHttpInfo($projectPublicId, $includesDescription, $contentType);
        return $response;
    }

    /**
     * Operation listStoriesWithHttpInfo
     *
     * List Stories
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listStoriesWithHttpInfo($projectPublicId, $includesDescription = null, string $contentType = self::contentTypes['listStories'][0])
    {
        $request = $this->listStoriesRequest($projectPublicId, $includesDescription, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listStoriesAsync
     *
     * List Stories
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStoriesAsync($projectPublicId, $includesDescription = null, string $contentType = self::contentTypes['listStories'][0])
    {
        return $this->listStoriesAsyncWithHttpInfo($projectPublicId, $includesDescription, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStoriesAsyncWithHttpInfo
     *
     * List Stories
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStoriesAsyncWithHttpInfo($projectPublicId, $includesDescription = null, string $contentType = self::contentTypes['listStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->listStoriesRequest($projectPublicId, $includesDescription, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStories'
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  bool|null $includesDescription A true/false boolean indicating whether to return Stories with their descriptions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStoriesRequest($projectPublicId, $includesDescription = null, string $contentType = self::contentTypes['listStories'][0])
    {

        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling listStories'
            );
        }



        $resourcePath = '/api/v3/projects/{project-public-id}/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includesDescription,
            'includes_description', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStoryComment
     *
     * List Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryComment[]
     */
    public function listStoryComment($storyPublicId, string $contentType = self::contentTypes['listStoryComment'][0])
    {
        list($response) = $this->listStoryCommentWithHttpInfo($storyPublicId, $contentType);
        return $response;
    }

    /**
     * Operation listStoryCommentWithHttpInfo
     *
     * List Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryComment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listStoryCommentWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['listStoryComment'][0])
    {
        $request = $this->listStoryCommentRequest($storyPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryComment[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryComment[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listStoryCommentAsync
     *
     * List Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStoryCommentAsync($storyPublicId, string $contentType = self::contentTypes['listStoryComment'][0])
    {
        return $this->listStoryCommentAsyncWithHttpInfo($storyPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStoryCommentAsyncWithHttpInfo
     *
     * List Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStoryCommentAsyncWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['listStoryComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment[]';
        $request = $this->listStoryCommentRequest($storyPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStoryComment'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStoryCommentRequest($storyPublicId, string $contentType = self::contentTypes['listStoryComment'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling listStoryComment'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWorkflows
     *
     * List Workflows
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkflows'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Workflow[]
     */
    public function listWorkflows(string $contentType = self::contentTypes['listWorkflows'][0])
    {
        list($response) = $this->listWorkflowsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listWorkflowsWithHttpInfo
     *
     * List Workflows
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkflows'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Workflow[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listWorkflowsWithHttpInfo(string $contentType = self::contentTypes['listWorkflows'][0])
    {
        $request = $this->listWorkflowsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Workflow[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Workflow[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Workflow[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listWorkflowsAsync
     *
     * List Workflows
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWorkflowsAsync(string $contentType = self::contentTypes['listWorkflows'][0])
    {
        return $this->listWorkflowsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWorkflowsAsyncWithHttpInfo
     *
     * List Workflows
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWorkflowsAsyncWithHttpInfo(string $contentType = self::contentTypes['listWorkflows'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Workflow[]';
        $request = $this->listWorkflowsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWorkflows'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWorkflowsRequest(string $contentType = self::contentTypes['listWorkflows'][0])
    {


        $resourcePath = '/api/v3/workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\SearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function search($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['search'][0])
    {
        list($response) = $this->searchWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\SearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['search'][0])
    {
        $request = $this->searchRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\SearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\SearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\SearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['search'][0])
    {
        return $this->searchAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['search'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\SearchResults';
        $request = $this->searchRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['search'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['search'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling search'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.search, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchEpics
     *
     * Search Epics
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EpicSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function searchEpics($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchEpics'][0])
    {
        list($response) = $this->searchEpicsWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchEpicsWithHttpInfo
     *
     * Search Epics
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchEpics'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EpicSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchEpicsWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchEpics'][0])
    {
        $request = $this->searchEpicsRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EpicSearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EpicSearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EpicSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchEpicsAsync
     *
     * Search Epics
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchEpicsAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchEpics'][0])
    {
        return $this->searchEpicsAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchEpicsAsyncWithHttpInfo
     *
     * Search Epics
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchEpicsAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchEpics'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EpicSearchResults';
        $request = $this->searchEpicsRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchEpics'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchEpics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchEpicsRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchEpics'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchEpics'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.searchEpics, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search/epics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchIterations
     *
     * Search Iterations
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\IterationSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function searchIterations($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchIterations'][0])
    {
        list($response) = $this->searchIterationsWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchIterationsWithHttpInfo
     *
     * Search Iterations
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIterations'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\IterationSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchIterationsWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchIterations'][0])
    {
        $request = $this->searchIterationsRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\IterationSearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\IterationSearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\IterationSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchIterationsAsync
     *
     * Search Iterations
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchIterationsAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchIterations'][0])
    {
        return $this->searchIterationsAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchIterationsAsyncWithHttpInfo
     *
     * Search Iterations
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchIterationsAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchIterations'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\IterationSearchResults';
        $request = $this->searchIterationsRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchIterations'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIterations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchIterationsRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchIterations'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchIterations'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.searchIterations, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search/iterations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMilestones
     *
     * Search Milestones
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ObjectiveSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function searchMilestones($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchMilestones'][0])
    {
        list($response) = $this->searchMilestonesWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchMilestonesWithHttpInfo
     *
     * Search Milestones
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMilestones'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ObjectiveSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMilestonesWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchMilestones'][0])
    {
        $request = $this->searchMilestonesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchMilestonesAsync
     *
     * Search Milestones
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMilestonesAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchMilestones'][0])
    {
        return $this->searchMilestonesAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMilestonesAsyncWithHttpInfo
     *
     * Search Milestones
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMilestonesAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchMilestones'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ObjectiveSearchResults';
        $request = $this->searchMilestonesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMilestones'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMilestones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchMilestonesRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchMilestones'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchMilestones'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.searchMilestones, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchObjectives
     *
     * Search Objectives
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ObjectiveSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function searchObjectives($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchObjectives'][0])
    {
        list($response) = $this->searchObjectivesWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchObjectivesWithHttpInfo
     *
     * Search Objectives
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchObjectives'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ObjectiveSearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchObjectivesWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchObjectives'][0])
    {
        $request = $this->searchObjectivesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ObjectiveSearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchObjectivesAsync
     *
     * Search Objectives
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchObjectivesAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchObjectives'][0])
    {
        return $this->searchObjectivesAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchObjectivesAsyncWithHttpInfo
     *
     * Search Objectives
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchObjectivesAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchObjectives'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ObjectiveSearchResults';
        $request = $this->searchObjectivesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchObjectives'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchObjectives'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchObjectivesRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchObjectives'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchObjectives'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.searchObjectives, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search/objectives';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStories
     *
     * Search Stories
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError
     */
    public function searchStories($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchStories'][0])
    {
        list($response) = $this->searchStoriesWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType);
        return $response;
    }

    /**
     * Operation searchStoriesWithHttpInfo
     *
     * Search Stories
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySearchResults|\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchStoriesWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchStories'][0])
    {
        $request = $this->searchStoriesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySearchResults',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySearchResults',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySearchResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\MaxSearchResultsExceededError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchStoriesAsync
     *
     * Search Stories
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStoriesAsync($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchStories'][0])
    {
        return $this->searchStoriesAsyncWithHttpInfo($query, $pageSize, $detail, $next, $entityTypes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStoriesAsyncWithHttpInfo
     *
     * Search Stories
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStoriesAsyncWithHttpInfo($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySearchResults';
        $request = $this->searchStoriesRequest($query, $pageSize, $detail, $next, $entityTypes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchStories'
     *
     * @param  string $query See our help center article on [search operators](https://help.shortcut.com/hc/en-us/articles/360000046646-Search-Operators) (required)
     * @param  int|null $pageSize The number of search results to include in a page. Minimum of 1 and maximum of 250. (optional)
     * @param  string|null $detail The amount of detail included in each result item.    \&quot;full\&quot; will include all descriptions and comments and more fields on    related items such as pull requests, branches and tasks.    \&quot;slim\&quot; omits larger fulltext fields such as descriptions and comments    and only references related items by id.    The default is \&quot;full\&quot;. (optional)
     * @param  string|null $next The next page token. (optional)
     * @param  string[]|null $entityTypes A collection of entity_types to search. Defaults to story and epic. Supports: epic, iteration, objective, story. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchStoriesRequest($query, $pageSize = null, $detail = null, $next = null, $entityTypes = null, string $contentType = self::contentTypes['searchStories'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchStories'
            );
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling DefaultApi.searchStories, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/v3/search/stories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageSize,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entityTypes,
            'entity_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStoriesOld
     *
     * Search Stories (Old)
     *
     * @param  \Timetoreply\Shortcut\Model\SearchStories $searchStories searchStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStoriesOld'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function searchStoriesOld($searchStories, string $contentType = self::contentTypes['searchStoriesOld'][0])
    {
        list($response) = $this->searchStoriesOldWithHttpInfo($searchStories, $contentType);
        return $response;
    }

    /**
     * Operation searchStoriesOldWithHttpInfo
     *
     * Search Stories (Old)
     *
     * @param  \Timetoreply\Shortcut\Model\SearchStories $searchStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStoriesOld'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchStoriesOldWithHttpInfo($searchStories, string $contentType = self::contentTypes['searchStoriesOld'][0])
    {
        $request = $this->searchStoriesOldRequest($searchStories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchStoriesOldAsync
     *
     * Search Stories (Old)
     *
     * @param  \Timetoreply\Shortcut\Model\SearchStories $searchStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStoriesOld'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStoriesOldAsync($searchStories, string $contentType = self::contentTypes['searchStoriesOld'][0])
    {
        return $this->searchStoriesOldAsyncWithHttpInfo($searchStories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStoriesOldAsyncWithHttpInfo
     *
     * Search Stories (Old)
     *
     * @param  \Timetoreply\Shortcut\Model\SearchStories $searchStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStoriesOld'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStoriesOldAsyncWithHttpInfo($searchStories, string $contentType = self::contentTypes['searchStoriesOld'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->searchStoriesOldRequest($searchStories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchStoriesOld'
     *
     * @param  \Timetoreply\Shortcut\Model\SearchStories $searchStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchStoriesOld'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchStoriesOldRequest($searchStories, string $contentType = self::contentTypes['searchStoriesOld'][0])
    {

        // verify the required parameter 'searchStories' is set
        if ($searchStories === null || (is_array($searchStories) && count($searchStories) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchStories when calling searchStoriesOld'
            );
        }


        $resourcePath = '/api/v3/stories/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($searchStories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($searchStories));
            } else {
                $httpBody = $searchStories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storyHistory
     *
     * Story History
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storyHistory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\History[]
     */
    public function storyHistory($storyPublicId, string $contentType = self::contentTypes['storyHistory'][0])
    {
        list($response) = $this->storyHistoryWithHttpInfo($storyPublicId, $contentType);
        return $response;
    }

    /**
     * Operation storyHistoryWithHttpInfo
     *
     * Story History
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storyHistory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\History[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storyHistoryWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['storyHistory'][0])
    {
        $request = $this->storyHistoryRequest($storyPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\History[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\History[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\History[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storyHistoryAsync
     *
     * Story History
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storyHistoryAsync($storyPublicId, string $contentType = self::contentTypes['storyHistory'][0])
    {
        return $this->storyHistoryAsyncWithHttpInfo($storyPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storyHistoryAsyncWithHttpInfo
     *
     * Story History
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storyHistoryAsyncWithHttpInfo($storyPublicId, string $contentType = self::contentTypes['storyHistory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\History[]';
        $request = $this->storyHistoryRequest($storyPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storyHistory'
     *
     * @param  int $storyPublicId The ID of the Story. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storyHistoryRequest($storyPublicId, string $contentType = self::contentTypes['storyHistory'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling storyHistory'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkCommentThreadFromSlack
     *
     * Unlink Comment thread from Slack
     *
     * @param  int $storyPublicId The ID of the Story to unlink. (required)
     * @param  int $commentPublicId The ID of the Comment to unlink. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkCommentThreadFromSlack'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryComment
     */
    public function unlinkCommentThreadFromSlack($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['unlinkCommentThreadFromSlack'][0])
    {
        list($response) = $this->unlinkCommentThreadFromSlackWithHttpInfo($storyPublicId, $commentPublicId, $contentType);
        return $response;
    }

    /**
     * Operation unlinkCommentThreadFromSlackWithHttpInfo
     *
     * Unlink Comment thread from Slack
     *
     * @param  int $storyPublicId The ID of the Story to unlink. (required)
     * @param  int $commentPublicId The ID of the Comment to unlink. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkCommentThreadFromSlack'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkCommentThreadFromSlackWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['unlinkCommentThreadFromSlack'][0])
    {
        $request = $this->unlinkCommentThreadFromSlackRequest($storyPublicId, $commentPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unlinkCommentThreadFromSlackAsync
     *
     * Unlink Comment thread from Slack
     *
     * @param  int $storyPublicId The ID of the Story to unlink. (required)
     * @param  int $commentPublicId The ID of the Comment to unlink. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkCommentThreadFromSlack'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkCommentThreadFromSlackAsync($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['unlinkCommentThreadFromSlack'][0])
    {
        return $this->unlinkCommentThreadFromSlackAsyncWithHttpInfo($storyPublicId, $commentPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkCommentThreadFromSlackAsyncWithHttpInfo
     *
     * Unlink Comment thread from Slack
     *
     * @param  int $storyPublicId The ID of the Story to unlink. (required)
     * @param  int $commentPublicId The ID of the Comment to unlink. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkCommentThreadFromSlack'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkCommentThreadFromSlackAsyncWithHttpInfo($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['unlinkCommentThreadFromSlack'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->unlinkCommentThreadFromSlackRequest($storyPublicId, $commentPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkCommentThreadFromSlack'
     *
     * @param  int $storyPublicId The ID of the Story to unlink. (required)
     * @param  int $commentPublicId The ID of the Comment to unlink. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkCommentThreadFromSlack'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkCommentThreadFromSlackRequest($storyPublicId, $commentPublicId, string $contentType = self::contentTypes['unlinkCommentThreadFromSlack'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling unlinkCommentThreadFromSlack'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling unlinkCommentThreadFromSlack'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}/unlink-from-slack';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkProductboardFromEpic
     *
     * Unlink Productboard from Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkProductboardFromEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unlinkProductboardFromEpic($epicPublicId, string $contentType = self::contentTypes['unlinkProductboardFromEpic'][0])
    {
        $this->unlinkProductboardFromEpicWithHttpInfo($epicPublicId, $contentType);
    }

    /**
     * Operation unlinkProductboardFromEpicWithHttpInfo
     *
     * Unlink Productboard from Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkProductboardFromEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkProductboardFromEpicWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['unlinkProductboardFromEpic'][0])
    {
        $request = $this->unlinkProductboardFromEpicRequest($epicPublicId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation unlinkProductboardFromEpicAsync
     *
     * Unlink Productboard from Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkProductboardFromEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkProductboardFromEpicAsync($epicPublicId, string $contentType = self::contentTypes['unlinkProductboardFromEpic'][0])
    {
        return $this->unlinkProductboardFromEpicAsyncWithHttpInfo($epicPublicId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkProductboardFromEpicAsyncWithHttpInfo
     *
     * Unlink Productboard from Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkProductboardFromEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkProductboardFromEpicAsyncWithHttpInfo($epicPublicId, string $contentType = self::contentTypes['unlinkProductboardFromEpic'][0])
    {
        $returnType = '';
        $request = $this->unlinkProductboardFromEpicRequest($epicPublicId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkProductboardFromEpic'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkProductboardFromEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkProductboardFromEpicRequest($epicPublicId, string $contentType = self::contentTypes['unlinkProductboardFromEpic'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling unlinkProductboardFromEpic'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/unlink-productboard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCategory
     *
     * Update Category
     *
     * @param  int $categoryPublicId The unique ID of the Category you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCategory $updateCategory updateCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Category
     */
    public function updateCategory($categoryPublicId, $updateCategory, string $contentType = self::contentTypes['updateCategory'][0])
    {
        list($response) = $this->updateCategoryWithHttpInfo($categoryPublicId, $updateCategory, $contentType);
        return $response;
    }

    /**
     * Operation updateCategoryWithHttpInfo
     *
     * Update Category
     *
     * @param  int $categoryPublicId The unique ID of the Category you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCategory $updateCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCategoryWithHttpInfo($categoryPublicId, $updateCategory, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $request = $this->updateCategoryRequest($categoryPublicId, $updateCategory, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Category',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Category',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCategoryAsync
     *
     * Update Category
     *
     * @param  int $categoryPublicId The unique ID of the Category you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCategory $updateCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsync($categoryPublicId, $updateCategory, string $contentType = self::contentTypes['updateCategory'][0])
    {
        return $this->updateCategoryAsyncWithHttpInfo($categoryPublicId, $updateCategory, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCategoryAsyncWithHttpInfo
     *
     * Update Category
     *
     * @param  int $categoryPublicId The unique ID of the Category you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCategory $updateCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsyncWithHttpInfo($categoryPublicId, $updateCategory, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Category';
        $request = $this->updateCategoryRequest($categoryPublicId, $updateCategory, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCategory'
     *
     * @param  int $categoryPublicId The unique ID of the Category you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCategory $updateCategory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCategoryRequest($categoryPublicId, $updateCategory, string $contentType = self::contentTypes['updateCategory'][0])
    {

        // verify the required parameter 'categoryPublicId' is set
        if ($categoryPublicId === null || (is_array($categoryPublicId) && count($categoryPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categoryPublicId when calling updateCategory'
            );
        }

        // verify the required parameter 'updateCategory' is set
        if ($updateCategory === null || (is_array($updateCategory) && count($updateCategory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCategory when calling updateCategory'
            );
        }


        $resourcePath = '/api/v3/categories/{category-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($categoryPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'category-public-id' . '}',
                ObjectSerializer::toPathValue($categoryPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCategory)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCategory));
            } else {
                $httpBody = $updateCategory;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomField
     *
     * Update Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCustomField $updateCustomField updateCustomField (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\CustomField|\Timetoreply\Shortcut\Model\DataConflictError
     */
    public function updateCustomField($customFieldPublicId, $updateCustomField, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        list($response) = $this->updateCustomFieldWithHttpInfo($customFieldPublicId, $updateCustomField, $contentType);
        return $response;
    }

    /**
     * Operation updateCustomFieldWithHttpInfo
     *
     * Update Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCustomField $updateCustomField (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\CustomField|\Timetoreply\Shortcut\Model\DataConflictError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomFieldWithHttpInfo($customFieldPublicId, $updateCustomField, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        $request = $this->updateCustomFieldRequest($customFieldPublicId, $updateCustomField, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $request,
                        $response,
                    );
                case 409:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\DataConflictError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\CustomField',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\CustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\DataConflictError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCustomFieldAsync
     *
     * Update Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCustomField $updateCustomField (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldAsync($customFieldPublicId, $updateCustomField, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        return $this->updateCustomFieldAsyncWithHttpInfo($customFieldPublicId, $updateCustomField, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomFieldAsyncWithHttpInfo
     *
     * Update Custom Field
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCustomField $updateCustomField (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomFieldAsyncWithHttpInfo($customFieldPublicId, $updateCustomField, string $contentType = self::contentTypes['updateCustomField'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\CustomField';
        $request = $this->updateCustomFieldRequest($customFieldPublicId, $updateCustomField, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomField'
     *
     * @param  string $customFieldPublicId The unique ID of the CustomField. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateCustomField $updateCustomField (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCustomFieldRequest($customFieldPublicId, $updateCustomField, string $contentType = self::contentTypes['updateCustomField'][0])
    {

        // verify the required parameter 'customFieldPublicId' is set
        if ($customFieldPublicId === null || (is_array($customFieldPublicId) && count($customFieldPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customFieldPublicId when calling updateCustomField'
            );
        }

        // verify the required parameter 'updateCustomField' is set
        if ($updateCustomField === null || (is_array($updateCustomField) && count($updateCustomField) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateCustomField when calling updateCustomField'
            );
        }


        $resourcePath = '/api/v3/custom-fields/{custom-field-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customFieldPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'custom-field-public-id' . '}',
                ObjectSerializer::toPathValue($customFieldPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateCustomField)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateCustomField));
            } else {
                $httpBody = $updateCustomField;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEntityTemplate
     *
     * Update Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEntityTemplate $updateEntityTemplate Request parameters for changing either a template&#39;s name or any of   the attributes it is designed to pre-populate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\EntityTemplate
     */
    public function updateEntityTemplate($entityTemplatePublicId, $updateEntityTemplate, string $contentType = self::contentTypes['updateEntityTemplate'][0])
    {
        list($response) = $this->updateEntityTemplateWithHttpInfo($entityTemplatePublicId, $updateEntityTemplate, $contentType);
        return $response;
    }

    /**
     * Operation updateEntityTemplateWithHttpInfo
     *
     * Update Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEntityTemplate $updateEntityTemplate Request parameters for changing either a template&#39;s name or any of   the attributes it is designed to pre-populate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEntityTemplate'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\EntityTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEntityTemplateWithHttpInfo($entityTemplatePublicId, $updateEntityTemplate, string $contentType = self::contentTypes['updateEntityTemplate'][0])
    {
        $request = $this->updateEntityTemplateRequest($entityTemplatePublicId, $updateEntityTemplate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\EntityTemplate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\EntityTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateEntityTemplateAsync
     *
     * Update Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEntityTemplate $updateEntityTemplate Request parameters for changing either a template&#39;s name or any of   the attributes it is designed to pre-populate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEntityTemplateAsync($entityTemplatePublicId, $updateEntityTemplate, string $contentType = self::contentTypes['updateEntityTemplate'][0])
    {
        return $this->updateEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, $updateEntityTemplate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEntityTemplateAsyncWithHttpInfo
     *
     * Update Entity Template
     *
     * @param  string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEntityTemplate $updateEntityTemplate Request parameters for changing either a template&#39;s name or any of   the attributes it is designed to pre-populate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEntityTemplateAsyncWithHttpInfo($entityTemplatePublicId, $updateEntityTemplate, string $contentType = self::contentTypes['updateEntityTemplate'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\EntityTemplate';
        $request = $this->updateEntityTemplateRequest($entityTemplatePublicId, $updateEntityTemplate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEntityTemplate'
     *
     * @param  string $entityTemplatePublicId The unique ID of the template to be updated. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEntityTemplate $updateEntityTemplate Request parameters for changing either a template&#39;s name or any of   the attributes it is designed to pre-populate. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEntityTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEntityTemplateRequest($entityTemplatePublicId, $updateEntityTemplate, string $contentType = self::contentTypes['updateEntityTemplate'][0])
    {

        // verify the required parameter 'entityTemplatePublicId' is set
        if ($entityTemplatePublicId === null || (is_array($entityTemplatePublicId) && count($entityTemplatePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityTemplatePublicId when calling updateEntityTemplate'
            );
        }

        // verify the required parameter 'updateEntityTemplate' is set
        if ($updateEntityTemplate === null || (is_array($updateEntityTemplate) && count($updateEntityTemplate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateEntityTemplate when calling updateEntityTemplate'
            );
        }


        $resourcePath = '/api/v3/entity-templates/{entity-template-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entityTemplatePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'entity-template-public-id' . '}',
                ObjectSerializer::toPathValue($entityTemplatePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateEntityTemplate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateEntityTemplate));
            } else {
                $httpBody = $updateEntityTemplate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEpic
     *
     * Update Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEpic $updateEpic updateEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Epic
     */
    public function updateEpic($epicPublicId, $updateEpic, string $contentType = self::contentTypes['updateEpic'][0])
    {
        list($response) = $this->updateEpicWithHttpInfo($epicPublicId, $updateEpic, $contentType);
        return $response;
    }

    /**
     * Operation updateEpicWithHttpInfo
     *
     * Update Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEpic $updateEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpic'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Epic, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEpicWithHttpInfo($epicPublicId, $updateEpic, string $contentType = self::contentTypes['updateEpic'][0])
    {
        $request = $this->updateEpicRequest($epicPublicId, $updateEpic, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Epic',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Epic',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Epic',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateEpicAsync
     *
     * Update Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEpic $updateEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEpicAsync($epicPublicId, $updateEpic, string $contentType = self::contentTypes['updateEpic'][0])
    {
        return $this->updateEpicAsyncWithHttpInfo($epicPublicId, $updateEpic, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEpicAsyncWithHttpInfo
     *
     * Update Epic
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEpic $updateEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEpicAsyncWithHttpInfo($epicPublicId, $updateEpic, string $contentType = self::contentTypes['updateEpic'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Epic';
        $request = $this->updateEpicRequest($epicPublicId, $updateEpic, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEpic'
     *
     * @param  int $epicPublicId The unique ID of the Epic. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateEpic $updateEpic (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEpicRequest($epicPublicId, $updateEpic, string $contentType = self::contentTypes['updateEpic'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling updateEpic'
            );
        }

        // verify the required parameter 'updateEpic' is set
        if ($updateEpic === null || (is_array($updateEpic) && count($updateEpic) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateEpic when calling updateEpic'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateEpic)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateEpic));
            } else {
                $httpBody = $updateEpic;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEpicComment
     *
     * Update Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateComment $updateComment updateComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\ThreadedComment
     */
    public function updateEpicComment($epicPublicId, $commentPublicId, $updateComment, string $contentType = self::contentTypes['updateEpicComment'][0])
    {
        list($response) = $this->updateEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, $updateComment, $contentType);
        return $response;
    }

    /**
     * Operation updateEpicCommentWithHttpInfo
     *
     * Update Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateComment $updateComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpicComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\ThreadedComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEpicCommentWithHttpInfo($epicPublicId, $commentPublicId, $updateComment, string $contentType = self::contentTypes['updateEpicComment'][0])
    {
        $request = $this->updateEpicCommentRequest($epicPublicId, $commentPublicId, $updateComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\ThreadedComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\ThreadedComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateEpicCommentAsync
     *
     * Update Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateComment $updateComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEpicCommentAsync($epicPublicId, $commentPublicId, $updateComment, string $contentType = self::contentTypes['updateEpicComment'][0])
    {
        return $this->updateEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $updateComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEpicCommentAsyncWithHttpInfo
     *
     * Update Epic Comment
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateComment $updateComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEpicCommentAsyncWithHttpInfo($epicPublicId, $commentPublicId, $updateComment, string $contentType = self::contentTypes['updateEpicComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\ThreadedComment';
        $request = $this->updateEpicCommentRequest($epicPublicId, $commentPublicId, $updateComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEpicComment'
     *
     * @param  int $epicPublicId The ID of the associated Epic. (required)
     * @param  int $commentPublicId The ID of the Comment. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateComment $updateComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEpicComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEpicCommentRequest($epicPublicId, $commentPublicId, $updateComment, string $contentType = self::contentTypes['updateEpicComment'][0])
    {

        // verify the required parameter 'epicPublicId' is set
        if ($epicPublicId === null || (is_array($epicPublicId) && count($epicPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $epicPublicId when calling updateEpicComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling updateEpicComment'
            );
        }

        // verify the required parameter 'updateComment' is set
        if ($updateComment === null || (is_array($updateComment) && count($updateComment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateComment when calling updateEpicComment'
            );
        }


        $resourcePath = '/api/v3/epics/{epic-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($epicPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'epic-public-id' . '}',
                ObjectSerializer::toPathValue($epicPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateComment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateComment));
            } else {
                $httpBody = $updateComment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFile
     *
     * Update File
     *
     * @param  int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateFile $updateFile updateFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\UploadedFile
     */
    public function updateFile($filePublicId, $updateFile, string $contentType = self::contentTypes['updateFile'][0])
    {
        list($response) = $this->updateFileWithHttpInfo($filePublicId, $updateFile, $contentType);
        return $response;
    }

    /**
     * Operation updateFileWithHttpInfo
     *
     * Update File
     *
     * @param  int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateFile $updateFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFileWithHttpInfo($filePublicId, $updateFile, string $contentType = self::contentTypes['updateFile'][0])
    {
        $request = $this->updateFileRequest($filePublicId, $updateFile, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\UploadedFile',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFileAsync
     *
     * Update File
     *
     * @param  int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateFile $updateFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsync($filePublicId, $updateFile, string $contentType = self::contentTypes['updateFile'][0])
    {
        return $this->updateFileAsyncWithHttpInfo($filePublicId, $updateFile, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileAsyncWithHttpInfo
     *
     * Update File
     *
     * @param  int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateFile $updateFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsyncWithHttpInfo($filePublicId, $updateFile, string $contentType = self::contentTypes['updateFile'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile';
        $request = $this->updateFileRequest($filePublicId, $updateFile, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFile'
     *
     * @param  int $filePublicId The unique ID assigned to the file in Shortcut. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateFile $updateFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFileRequest($filePublicId, $updateFile, string $contentType = self::contentTypes['updateFile'][0])
    {

        // verify the required parameter 'filePublicId' is set
        if ($filePublicId === null || (is_array($filePublicId) && count($filePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePublicId when calling updateFile'
            );
        }

        // verify the required parameter 'updateFile' is set
        if ($updateFile === null || (is_array($updateFile) && count($updateFile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateFile when calling updateFile'
            );
        }


        $resourcePath = '/api/v3/files/{file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($filePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'file-public-id' . '}',
                ObjectSerializer::toPathValue($filePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateFile)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateFile));
            } else {
                $httpBody = $updateFile;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGroup
     *
     * Update Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateGroup $updateGroup updateGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Group|\Timetoreply\Shortcut\Model\UnusableEntitlementError
     */
    public function updateGroup($groupPublicId, $updateGroup, string $contentType = self::contentTypes['updateGroup'][0])
    {
        list($response) = $this->updateGroupWithHttpInfo($groupPublicId, $updateGroup, $contentType);
        return $response;
    }

    /**
     * Operation updateGroupWithHttpInfo
     *
     * Update Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateGroup $updateGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGroup'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Group|\Timetoreply\Shortcut\Model\UnusableEntitlementError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGroupWithHttpInfo($groupPublicId, $updateGroup, string $contentType = self::contentTypes['updateGroup'][0])
    {
        $request = $this->updateGroupRequest($groupPublicId, $updateGroup, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Group',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Group',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Group',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UnusableEntitlementError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateGroupAsync
     *
     * Update Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateGroup $updateGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGroupAsync($groupPublicId, $updateGroup, string $contentType = self::contentTypes['updateGroup'][0])
    {
        return $this->updateGroupAsyncWithHttpInfo($groupPublicId, $updateGroup, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGroupAsyncWithHttpInfo
     *
     * Update Group
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateGroup $updateGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGroupAsyncWithHttpInfo($groupPublicId, $updateGroup, string $contentType = self::contentTypes['updateGroup'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Group';
        $request = $this->updateGroupRequest($groupPublicId, $updateGroup, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGroup'
     *
     * @param  string $groupPublicId The unique ID of the Group. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateGroup $updateGroup (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGroupRequest($groupPublicId, $updateGroup, string $contentType = self::contentTypes['updateGroup'][0])
    {

        // verify the required parameter 'groupPublicId' is set
        if ($groupPublicId === null || (is_array($groupPublicId) && count($groupPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupPublicId when calling updateGroup'
            );
        }

        // verify the required parameter 'updateGroup' is set
        if ($updateGroup === null || (is_array($updateGroup) && count($updateGroup) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateGroup when calling updateGroup'
            );
        }


        $resourcePath = '/api/v3/groups/{group-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'group-public-id' . '}',
                ObjectSerializer::toPathValue($groupPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateGroup)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateGroup));
            } else {
                $httpBody = $updateGroup;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHealth
     *
     * Update Health
     *
     * @param  string $healthPublicId The unique ID of the Health record. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateHealth $updateHealth updateHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Health
     */
    public function updateHealth($healthPublicId, $updateHealth, string $contentType = self::contentTypes['updateHealth'][0])
    {
        list($response) = $this->updateHealthWithHttpInfo($healthPublicId, $updateHealth, $contentType);
        return $response;
    }

    /**
     * Operation updateHealthWithHttpInfo
     *
     * Update Health
     *
     * @param  string $healthPublicId The unique ID of the Health record. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateHealth $updateHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHealth'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Health, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHealthWithHttpInfo($healthPublicId, $updateHealth, string $contentType = self::contentTypes['updateHealth'][0])
    {
        $request = $this->updateHealthRequest($healthPublicId, $updateHealth, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Health',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Health',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Health',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateHealthAsync
     *
     * Update Health
     *
     * @param  string $healthPublicId The unique ID of the Health record. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateHealth $updateHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHealthAsync($healthPublicId, $updateHealth, string $contentType = self::contentTypes['updateHealth'][0])
    {
        return $this->updateHealthAsyncWithHttpInfo($healthPublicId, $updateHealth, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHealthAsyncWithHttpInfo
     *
     * Update Health
     *
     * @param  string $healthPublicId The unique ID of the Health record. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateHealth $updateHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHealthAsyncWithHttpInfo($healthPublicId, $updateHealth, string $contentType = self::contentTypes['updateHealth'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Health';
        $request = $this->updateHealthRequest($healthPublicId, $updateHealth, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHealth'
     *
     * @param  string $healthPublicId The unique ID of the Health record. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateHealth $updateHealth (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHealth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateHealthRequest($healthPublicId, $updateHealth, string $contentType = self::contentTypes['updateHealth'][0])
    {

        // verify the required parameter 'healthPublicId' is set
        if ($healthPublicId === null || (is_array($healthPublicId) && count($healthPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $healthPublicId when calling updateHealth'
            );
        }

        // verify the required parameter 'updateHealth' is set
        if ($updateHealth === null || (is_array($updateHealth) && count($updateHealth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateHealth when calling updateHealth'
            );
        }


        $resourcePath = '/api/v3/health/{health-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($healthPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'health-public-id' . '}',
                ObjectSerializer::toPathValue($healthPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateHealth)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateHealth));
            } else {
                $httpBody = $updateHealth;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateIteration
     *
     * Update Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateIteration $updateIteration updateIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Iteration
     */
    public function updateIteration($iterationPublicId, $updateIteration, string $contentType = self::contentTypes['updateIteration'][0])
    {
        list($response) = $this->updateIterationWithHttpInfo($iterationPublicId, $updateIteration, $contentType);
        return $response;
    }

    /**
     * Operation updateIterationWithHttpInfo
     *
     * Update Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateIteration $updateIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateIteration'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Iteration, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateIterationWithHttpInfo($iterationPublicId, $updateIteration, string $contentType = self::contentTypes['updateIteration'][0])
    {
        $request = $this->updateIterationRequest($iterationPublicId, $updateIteration, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Iteration',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Iteration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateIterationAsync
     *
     * Update Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateIteration $updateIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateIterationAsync($iterationPublicId, $updateIteration, string $contentType = self::contentTypes['updateIteration'][0])
    {
        return $this->updateIterationAsyncWithHttpInfo($iterationPublicId, $updateIteration, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateIterationAsyncWithHttpInfo
     *
     * Update Iteration
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateIteration $updateIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateIterationAsyncWithHttpInfo($iterationPublicId, $updateIteration, string $contentType = self::contentTypes['updateIteration'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Iteration';
        $request = $this->updateIterationRequest($iterationPublicId, $updateIteration, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateIteration'
     *
     * @param  int $iterationPublicId The unique ID of the Iteration. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateIteration $updateIteration (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateIteration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateIterationRequest($iterationPublicId, $updateIteration, string $contentType = self::contentTypes['updateIteration'][0])
    {

        // verify the required parameter 'iterationPublicId' is set
        if ($iterationPublicId === null || (is_array($iterationPublicId) && count($iterationPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iterationPublicId when calling updateIteration'
            );
        }

        // verify the required parameter 'updateIteration' is set
        if ($updateIteration === null || (is_array($updateIteration) && count($updateIteration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateIteration when calling updateIteration'
            );
        }


        $resourcePath = '/api/v3/iterations/{iteration-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($iterationPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'iteration-public-id' . '}',
                ObjectSerializer::toPathValue($iterationPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateIteration)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateIteration));
            } else {
                $httpBody = $updateIteration;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateKeyResult
     *
     * Update Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateKeyResult $updateKeyResult updateKeyResult (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateKeyResult'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\KeyResult
     */
    public function updateKeyResult($keyResultPublicId, $updateKeyResult, string $contentType = self::contentTypes['updateKeyResult'][0])
    {
        list($response) = $this->updateKeyResultWithHttpInfo($keyResultPublicId, $updateKeyResult, $contentType);
        return $response;
    }

    /**
     * Operation updateKeyResultWithHttpInfo
     *
     * Update Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateKeyResult $updateKeyResult (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateKeyResult'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\KeyResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateKeyResultWithHttpInfo($keyResultPublicId, $updateKeyResult, string $contentType = self::contentTypes['updateKeyResult'][0])
    {
        $request = $this->updateKeyResultRequest($keyResultPublicId, $updateKeyResult, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\KeyResult',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\KeyResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\KeyResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateKeyResultAsync
     *
     * Update Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateKeyResult $updateKeyResult (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKeyResultAsync($keyResultPublicId, $updateKeyResult, string $contentType = self::contentTypes['updateKeyResult'][0])
    {
        return $this->updateKeyResultAsyncWithHttpInfo($keyResultPublicId, $updateKeyResult, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateKeyResultAsyncWithHttpInfo
     *
     * Update Key Result
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateKeyResult $updateKeyResult (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateKeyResultAsyncWithHttpInfo($keyResultPublicId, $updateKeyResult, string $contentType = self::contentTypes['updateKeyResult'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\KeyResult';
        $request = $this->updateKeyResultRequest($keyResultPublicId, $updateKeyResult, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateKeyResult'
     *
     * @param  string $keyResultPublicId The ID of the Key Result. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateKeyResult $updateKeyResult (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateKeyResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateKeyResultRequest($keyResultPublicId, $updateKeyResult, string $contentType = self::contentTypes['updateKeyResult'][0])
    {

        // verify the required parameter 'keyResultPublicId' is set
        if ($keyResultPublicId === null || (is_array($keyResultPublicId) && count($keyResultPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyResultPublicId when calling updateKeyResult'
            );
        }

        // verify the required parameter 'updateKeyResult' is set
        if ($updateKeyResult === null || (is_array($updateKeyResult) && count($updateKeyResult) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateKeyResult when calling updateKeyResult'
            );
        }


        $resourcePath = '/api/v3/key-results/{key-result-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($keyResultPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'key-result-public-id' . '}',
                ObjectSerializer::toPathValue($keyResultPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateKeyResult)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateKeyResult));
            } else {
                $httpBody = $updateKeyResult;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLabel
     *
     * Update Label
     *
     * @param  int $labelPublicId The unique ID of the Label you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLabel $updateLabel updateLabel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Label
     */
    public function updateLabel($labelPublicId, $updateLabel, string $contentType = self::contentTypes['updateLabel'][0])
    {
        list($response) = $this->updateLabelWithHttpInfo($labelPublicId, $updateLabel, $contentType);
        return $response;
    }

    /**
     * Operation updateLabelWithHttpInfo
     *
     * Update Label
     *
     * @param  int $labelPublicId The unique ID of the Label you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLabel $updateLabel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLabel'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLabelWithHttpInfo($labelPublicId, $updateLabel, string $contentType = self::contentTypes['updateLabel'][0])
    {
        $request = $this->updateLabelRequest($labelPublicId, $updateLabel, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Label',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Label',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateLabelAsync
     *
     * Update Label
     *
     * @param  int $labelPublicId The unique ID of the Label you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLabel $updateLabel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLabelAsync($labelPublicId, $updateLabel, string $contentType = self::contentTypes['updateLabel'][0])
    {
        return $this->updateLabelAsyncWithHttpInfo($labelPublicId, $updateLabel, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLabelAsyncWithHttpInfo
     *
     * Update Label
     *
     * @param  int $labelPublicId The unique ID of the Label you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLabel $updateLabel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLabelAsyncWithHttpInfo($labelPublicId, $updateLabel, string $contentType = self::contentTypes['updateLabel'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Label';
        $request = $this->updateLabelRequest($labelPublicId, $updateLabel, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLabel'
     *
     * @param  int $labelPublicId The unique ID of the Label you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLabel $updateLabel (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateLabelRequest($labelPublicId, $updateLabel, string $contentType = self::contentTypes['updateLabel'][0])
    {

        // verify the required parameter 'labelPublicId' is set
        if ($labelPublicId === null || (is_array($labelPublicId) && count($labelPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelPublicId when calling updateLabel'
            );
        }

        // verify the required parameter 'updateLabel' is set
        if ($updateLabel === null || (is_array($updateLabel) && count($updateLabel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateLabel when calling updateLabel'
            );
        }


        $resourcePath = '/api/v3/labels/{label-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($labelPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'label-public-id' . '}',
                ObjectSerializer::toPathValue($labelPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateLabel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateLabel));
            } else {
                $httpBody = $updateLabel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLinkedFile
     *
     * Update Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLinkedFile $updateLinkedFile updateLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\LinkedFile
     */
    public function updateLinkedFile($linkedFilePublicId, $updateLinkedFile, string $contentType = self::contentTypes['updateLinkedFile'][0])
    {
        list($response) = $this->updateLinkedFileWithHttpInfo($linkedFilePublicId, $updateLinkedFile, $contentType);
        return $response;
    }

    /**
     * Operation updateLinkedFileWithHttpInfo
     *
     * Update Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLinkedFile $updateLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLinkedFile'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\LinkedFile, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLinkedFileWithHttpInfo($linkedFilePublicId, $updateLinkedFile, string $contentType = self::contentTypes['updateLinkedFile'][0])
    {
        $request = $this->updateLinkedFileRequest($linkedFilePublicId, $updateLinkedFile, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\LinkedFile',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\LinkedFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateLinkedFileAsync
     *
     * Update Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLinkedFile $updateLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLinkedFileAsync($linkedFilePublicId, $updateLinkedFile, string $contentType = self::contentTypes['updateLinkedFile'][0])
    {
        return $this->updateLinkedFileAsyncWithHttpInfo($linkedFilePublicId, $updateLinkedFile, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLinkedFileAsyncWithHttpInfo
     *
     * Update Linked File
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLinkedFile $updateLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLinkedFileAsyncWithHttpInfo($linkedFilePublicId, $updateLinkedFile, string $contentType = self::contentTypes['updateLinkedFile'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\LinkedFile';
        $request = $this->updateLinkedFileRequest($linkedFilePublicId, $updateLinkedFile, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLinkedFile'
     *
     * @param  int $linkedFilePublicId The unique identifier of the linked file. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateLinkedFile $updateLinkedFile (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateLinkedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateLinkedFileRequest($linkedFilePublicId, $updateLinkedFile, string $contentType = self::contentTypes['updateLinkedFile'][0])
    {

        // verify the required parameter 'linkedFilePublicId' is set
        if ($linkedFilePublicId === null || (is_array($linkedFilePublicId) && count($linkedFilePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedFilePublicId when calling updateLinkedFile'
            );
        }

        // verify the required parameter 'updateLinkedFile' is set
        if ($updateLinkedFile === null || (is_array($updateLinkedFile) && count($updateLinkedFile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateLinkedFile when calling updateLinkedFile'
            );
        }


        $resourcePath = '/api/v3/linked-files/{linked-file-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($linkedFilePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'linked-file-public-id' . '}',
                ObjectSerializer::toPathValue($linkedFilePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateLinkedFile)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateLinkedFile));
            } else {
                $httpBody = $updateLinkedFile;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMilestone
     *
     * Update Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateMilestone $updateMilestone updateMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Milestone
     */
    public function updateMilestone($milestonePublicId, $updateMilestone, string $contentType = self::contentTypes['updateMilestone'][0])
    {
        list($response) = $this->updateMilestoneWithHttpInfo($milestonePublicId, $updateMilestone, $contentType);
        return $response;
    }

    /**
     * Operation updateMilestoneWithHttpInfo
     *
     * Update Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateMilestone $updateMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMilestone'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMilestoneWithHttpInfo($milestonePublicId, $updateMilestone, string $contentType = self::contentTypes['updateMilestone'][0])
    {
        $request = $this->updateMilestoneRequest($milestonePublicId, $updateMilestone, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Milestone',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateMilestoneAsync
     *
     * Update Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateMilestone $updateMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMilestoneAsync($milestonePublicId, $updateMilestone, string $contentType = self::contentTypes['updateMilestone'][0])
    {
        return $this->updateMilestoneAsyncWithHttpInfo($milestonePublicId, $updateMilestone, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMilestoneAsyncWithHttpInfo
     *
     * Update Milestone
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateMilestone $updateMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMilestoneAsyncWithHttpInfo($milestonePublicId, $updateMilestone, string $contentType = self::contentTypes['updateMilestone'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Milestone';
        $request = $this->updateMilestoneRequest($milestonePublicId, $updateMilestone, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMilestone'
     *
     * @param  int $milestonePublicId The ID of the Milestone. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateMilestone $updateMilestone (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMilestone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMilestoneRequest($milestonePublicId, $updateMilestone, string $contentType = self::contentTypes['updateMilestone'][0])
    {

        // verify the required parameter 'milestonePublicId' is set
        if ($milestonePublicId === null || (is_array($milestonePublicId) && count($milestonePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestonePublicId when calling updateMilestone'
            );
        }

        // verify the required parameter 'updateMilestone' is set
        if ($updateMilestone === null || (is_array($updateMilestone) && count($updateMilestone) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateMilestone when calling updateMilestone'
            );
        }


        $resourcePath = '/api/v3/milestones/{milestone-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($milestonePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'milestone-public-id' . '}',
                ObjectSerializer::toPathValue($milestonePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateMilestone)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateMilestone));
            } else {
                $httpBody = $updateMilestone;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMultipleStories
     *
     * Update Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\UpdateStories $updateStories updateStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StorySlim[]
     */
    public function updateMultipleStories($updateStories, string $contentType = self::contentTypes['updateMultipleStories'][0])
    {
        list($response) = $this->updateMultipleStoriesWithHttpInfo($updateStories, $contentType);
        return $response;
    }

    /**
     * Operation updateMultipleStoriesWithHttpInfo
     *
     * Update Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\UpdateStories $updateStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMultipleStories'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StorySlim[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMultipleStoriesWithHttpInfo($updateStories, string $contentType = self::contentTypes['updateMultipleStories'][0])
    {
        $request = $this->updateMultipleStoriesRequest($updateStories, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StorySlim[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StorySlim[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateMultipleStoriesAsync
     *
     * Update Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\UpdateStories $updateStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMultipleStoriesAsync($updateStories, string $contentType = self::contentTypes['updateMultipleStories'][0])
    {
        return $this->updateMultipleStoriesAsyncWithHttpInfo($updateStories, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMultipleStoriesAsyncWithHttpInfo
     *
     * Update Multiple Stories
     *
     * @param  \Timetoreply\Shortcut\Model\UpdateStories $updateStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMultipleStoriesAsyncWithHttpInfo($updateStories, string $contentType = self::contentTypes['updateMultipleStories'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StorySlim[]';
        $request = $this->updateMultipleStoriesRequest($updateStories, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMultipleStories'
     *
     * @param  \Timetoreply\Shortcut\Model\UpdateStories $updateStories (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMultipleStories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMultipleStoriesRequest($updateStories, string $contentType = self::contentTypes['updateMultipleStories'][0])
    {

        // verify the required parameter 'updateStories' is set
        if ($updateStories === null || (is_array($updateStories) && count($updateStories) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateStories when calling updateMultipleStories'
            );
        }


        $resourcePath = '/api/v3/stories/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateStories)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateStories));
            } else {
                $httpBody = $updateStories;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateObjective
     *
     * Update Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateObjective $updateObjective updateObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Objective
     */
    public function updateObjective($objectivePublicId, $updateObjective, string $contentType = self::contentTypes['updateObjective'][0])
    {
        list($response) = $this->updateObjectiveWithHttpInfo($objectivePublicId, $updateObjective, $contentType);
        return $response;
    }

    /**
     * Operation updateObjectiveWithHttpInfo
     *
     * Update Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateObjective $updateObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateObjective'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Objective, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateObjectiveWithHttpInfo($objectivePublicId, $updateObjective, string $contentType = self::contentTypes['updateObjective'][0])
    {
        $request = $this->updateObjectiveRequest($objectivePublicId, $updateObjective, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Objective',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Objective',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Objective',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateObjectiveAsync
     *
     * Update Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateObjective $updateObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateObjectiveAsync($objectivePublicId, $updateObjective, string $contentType = self::contentTypes['updateObjective'][0])
    {
        return $this->updateObjectiveAsyncWithHttpInfo($objectivePublicId, $updateObjective, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateObjectiveAsyncWithHttpInfo
     *
     * Update Objective
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateObjective $updateObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateObjectiveAsyncWithHttpInfo($objectivePublicId, $updateObjective, string $contentType = self::contentTypes['updateObjective'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Objective';
        $request = $this->updateObjectiveRequest($objectivePublicId, $updateObjective, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateObjective'
     *
     * @param  int $objectivePublicId The ID of the Objective. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateObjective $updateObjective (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateObjective'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateObjectiveRequest($objectivePublicId, $updateObjective, string $contentType = self::contentTypes['updateObjective'][0])
    {

        // verify the required parameter 'objectivePublicId' is set
        if ($objectivePublicId === null || (is_array($objectivePublicId) && count($objectivePublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectivePublicId when calling updateObjective'
            );
        }

        // verify the required parameter 'updateObjective' is set
        if ($updateObjective === null || (is_array($updateObjective) && count($updateObjective) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateObjective when calling updateObjective'
            );
        }


        $resourcePath = '/api/v3/objectives/{objective-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($objectivePublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'objective-public-id' . '}',
                ObjectSerializer::toPathValue($objectivePublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateObjective)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateObjective));
            } else {
                $httpBody = $updateObjective;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProject
     *
     * Update Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateProject $updateProject updateProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Project
     */
    public function updateProject($projectPublicId, $updateProject, string $contentType = self::contentTypes['updateProject'][0])
    {
        list($response) = $this->updateProjectWithHttpInfo($projectPublicId, $updateProject, $contentType);
        return $response;
    }

    /**
     * Operation updateProjectWithHttpInfo
     *
     * Update Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateProject $updateProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Project, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProjectWithHttpInfo($projectPublicId, $updateProject, string $contentType = self::contentTypes['updateProject'][0])
    {
        $request = $this->updateProjectRequest($projectPublicId, $updateProject, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Project',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Project',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Project',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateProjectAsync
     *
     * Update Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateProject $updateProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProjectAsync($projectPublicId, $updateProject, string $contentType = self::contentTypes['updateProject'][0])
    {
        return $this->updateProjectAsyncWithHttpInfo($projectPublicId, $updateProject, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProjectAsyncWithHttpInfo
     *
     * Update Project
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateProject $updateProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProjectAsyncWithHttpInfo($projectPublicId, $updateProject, string $contentType = self::contentTypes['updateProject'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Project';
        $request = $this->updateProjectRequest($projectPublicId, $updateProject, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProject'
     *
     * @param  int $projectPublicId The unique ID of the Project. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateProject $updateProject (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateProjectRequest($projectPublicId, $updateProject, string $contentType = self::contentTypes['updateProject'][0])
    {

        // verify the required parameter 'projectPublicId' is set
        if ($projectPublicId === null || (is_array($projectPublicId) && count($projectPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectPublicId when calling updateProject'
            );
        }

        // verify the required parameter 'updateProject' is set
        if ($updateProject === null || (is_array($updateProject) && count($updateProject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateProject when calling updateProject'
            );
        }


        $resourcePath = '/api/v3/projects/{project-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'project-public-id' . '}',
                ObjectSerializer::toPathValue($projectPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateProject)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateProject));
            } else {
                $httpBody = $updateProject;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStory
     *
     * Update Story
     *
     * @param  int $storyPublicId The unique identifier of this story. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStory $updateStory updateStory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Story
     */
    public function updateStory($storyPublicId, $updateStory, string $contentType = self::contentTypes['updateStory'][0])
    {
        list($response) = $this->updateStoryWithHttpInfo($storyPublicId, $updateStory, $contentType);
        return $response;
    }

    /**
     * Operation updateStoryWithHttpInfo
     *
     * Update Story
     *
     * @param  int $storyPublicId The unique identifier of this story. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStory $updateStory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStory'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Story, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStoryWithHttpInfo($storyPublicId, $updateStory, string $contentType = self::contentTypes['updateStory'][0])
    {
        $request = $this->updateStoryRequest($storyPublicId, $updateStory, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Story',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Story',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Story',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateStoryAsync
     *
     * Update Story
     *
     * @param  int $storyPublicId The unique identifier of this story. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStory $updateStory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryAsync($storyPublicId, $updateStory, string $contentType = self::contentTypes['updateStory'][0])
    {
        return $this->updateStoryAsyncWithHttpInfo($storyPublicId, $updateStory, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryAsyncWithHttpInfo
     *
     * Update Story
     *
     * @param  int $storyPublicId The unique identifier of this story. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStory $updateStory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryAsyncWithHttpInfo($storyPublicId, $updateStory, string $contentType = self::contentTypes['updateStory'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Story';
        $request = $this->updateStoryRequest($storyPublicId, $updateStory, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStory'
     *
     * @param  int $storyPublicId The unique identifier of this story. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStory $updateStory (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateStoryRequest($storyPublicId, $updateStory, string $contentType = self::contentTypes['updateStory'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateStory'
            );
        }

        // verify the required parameter 'updateStory' is set
        if ($updateStory === null || (is_array($updateStory) && count($updateStory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateStory when calling updateStory'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateStory)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateStory));
            } else {
                $httpBody = $updateStory;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStoryComment
     *
     * Update Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryComment $updateStoryComment updateStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryComment
     */
    public function updateStoryComment($storyPublicId, $commentPublicId, $updateStoryComment, string $contentType = self::contentTypes['updateStoryComment'][0])
    {
        list($response) = $this->updateStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, $updateStoryComment, $contentType);
        return $response;
    }

    /**
     * Operation updateStoryCommentWithHttpInfo
     *
     * Update Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryComment $updateStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryComment'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStoryCommentWithHttpInfo($storyPublicId, $commentPublicId, $updateStoryComment, string $contentType = self::contentTypes['updateStoryComment'][0])
    {
        $request = $this->updateStoryCommentRequest($storyPublicId, $commentPublicId, $updateStoryComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryComment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateStoryCommentAsync
     *
     * Update Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryComment $updateStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryCommentAsync($storyPublicId, $commentPublicId, $updateStoryComment, string $contentType = self::contentTypes['updateStoryComment'][0])
    {
        return $this->updateStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, $updateStoryComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryCommentAsyncWithHttpInfo
     *
     * Update Story Comment
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryComment $updateStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryCommentAsyncWithHttpInfo($storyPublicId, $commentPublicId, $updateStoryComment, string $contentType = self::contentTypes['updateStoryComment'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryComment';
        $request = $this->updateStoryCommentRequest($storyPublicId, $commentPublicId, $updateStoryComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStoryComment'
     *
     * @param  int $storyPublicId The ID of the Story that the Comment is in. (required)
     * @param  int $commentPublicId The ID of the Comment (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryComment $updateStoryComment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateStoryCommentRequest($storyPublicId, $commentPublicId, $updateStoryComment, string $contentType = self::contentTypes['updateStoryComment'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateStoryComment'
            );
        }

        // verify the required parameter 'commentPublicId' is set
        if ($commentPublicId === null || (is_array($commentPublicId) && count($commentPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commentPublicId when calling updateStoryComment'
            );
        }

        // verify the required parameter 'updateStoryComment' is set
        if ($updateStoryComment === null || (is_array($updateStoryComment) && count($updateStoryComment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateStoryComment when calling updateStoryComment'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/comments/{comment-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($commentPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'comment-public-id' . '}',
                ObjectSerializer::toPathValue($commentPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateStoryComment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateStoryComment));
            } else {
                $httpBody = $updateStoryComment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStoryLink
     *
     * Update Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryLink $updateStoryLink updateStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\StoryLink
     */
    public function updateStoryLink($storyLinkPublicId, $updateStoryLink, string $contentType = self::contentTypes['updateStoryLink'][0])
    {
        list($response) = $this->updateStoryLinkWithHttpInfo($storyLinkPublicId, $updateStoryLink, $contentType);
        return $response;
    }

    /**
     * Operation updateStoryLinkWithHttpInfo
     *
     * Update Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryLink $updateStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryLink'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\StoryLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStoryLinkWithHttpInfo($storyLinkPublicId, $updateStoryLink, string $contentType = self::contentTypes['updateStoryLink'][0])
    {
        $request = $this->updateStoryLinkRequest($storyLinkPublicId, $updateStoryLink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\StoryLink',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\StoryLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateStoryLinkAsync
     *
     * Update Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryLink $updateStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryLinkAsync($storyLinkPublicId, $updateStoryLink, string $contentType = self::contentTypes['updateStoryLink'][0])
    {
        return $this->updateStoryLinkAsyncWithHttpInfo($storyLinkPublicId, $updateStoryLink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStoryLinkAsyncWithHttpInfo
     *
     * Update Story Link
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryLink $updateStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStoryLinkAsyncWithHttpInfo($storyLinkPublicId, $updateStoryLink, string $contentType = self::contentTypes['updateStoryLink'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\StoryLink';
        $request = $this->updateStoryLinkRequest($storyLinkPublicId, $updateStoryLink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStoryLink'
     *
     * @param  int $storyLinkPublicId The unique ID of the Story Link. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateStoryLink $updateStoryLink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStoryLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateStoryLinkRequest($storyLinkPublicId, $updateStoryLink, string $contentType = self::contentTypes['updateStoryLink'][0])
    {

        // verify the required parameter 'storyLinkPublicId' is set
        if ($storyLinkPublicId === null || (is_array($storyLinkPublicId) && count($storyLinkPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyLinkPublicId when calling updateStoryLink'
            );
        }

        // verify the required parameter 'updateStoryLink' is set
        if ($updateStoryLink === null || (is_array($updateStoryLink) && count($updateStoryLink) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateStoryLink when calling updateStoryLink'
            );
        }


        $resourcePath = '/api/v3/story-links/{story-link-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyLinkPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-link-public-id' . '}',
                ObjectSerializer::toPathValue($storyLinkPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateStoryLink)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateStoryLink));
            } else {
                $httpBody = $updateStoryLink;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTask
     *
     * Update Task
     *
     * @param  int $storyPublicId The unique identifier of the parent Story. (required)
     * @param  int $taskPublicId The unique identifier of the Task you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateTask $updateTask updateTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\Task
     */
    public function updateTask($storyPublicId, $taskPublicId, $updateTask, string $contentType = self::contentTypes['updateTask'][0])
    {
        list($response) = $this->updateTaskWithHttpInfo($storyPublicId, $taskPublicId, $updateTask, $contentType);
        return $response;
    }

    /**
     * Operation updateTaskWithHttpInfo
     *
     * Update Task
     *
     * @param  int $storyPublicId The unique identifier of the parent Story. (required)
     * @param  int $taskPublicId The unique identifier of the Task you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateTask $updateTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTask'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\Task, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaskWithHttpInfo($storyPublicId, $taskPublicId, $updateTask, string $contentType = self::contentTypes['updateTask'][0])
    {
        $request = $this->updateTaskRequest($storyPublicId, $taskPublicId, $updateTask, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\Task',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\Task',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\Task',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTaskAsync
     *
     * Update Task
     *
     * @param  int $storyPublicId The unique identifier of the parent Story. (required)
     * @param  int $taskPublicId The unique identifier of the Task you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateTask $updateTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsync($storyPublicId, $taskPublicId, $updateTask, string $contentType = self::contentTypes['updateTask'][0])
    {
        return $this->updateTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, $updateTask, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskAsyncWithHttpInfo
     *
     * Update Task
     *
     * @param  int $storyPublicId The unique identifier of the parent Story. (required)
     * @param  int $taskPublicId The unique identifier of the Task you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateTask $updateTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsyncWithHttpInfo($storyPublicId, $taskPublicId, $updateTask, string $contentType = self::contentTypes['updateTask'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\Task';
        $request = $this->updateTaskRequest($storyPublicId, $taskPublicId, $updateTask, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTask'
     *
     * @param  int $storyPublicId The unique identifier of the parent Story. (required)
     * @param  int $taskPublicId The unique identifier of the Task you wish to update. (required)
     * @param  \Timetoreply\Shortcut\Model\UpdateTask $updateTask (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTaskRequest($storyPublicId, $taskPublicId, $updateTask, string $contentType = self::contentTypes['updateTask'][0])
    {

        // verify the required parameter 'storyPublicId' is set
        if ($storyPublicId === null || (is_array($storyPublicId) && count($storyPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $storyPublicId when calling updateTask'
            );
        }

        // verify the required parameter 'taskPublicId' is set
        if ($taskPublicId === null || (is_array($taskPublicId) && count($taskPublicId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskPublicId when calling updateTask'
            );
        }

        // verify the required parameter 'updateTask' is set
        if ($updateTask === null || (is_array($updateTask) && count($updateTask) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateTask when calling updateTask'
            );
        }


        $resourcePath = '/api/v3/stories/{story-public-id}/tasks/{task-public-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($storyPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'story-public-id' . '}',
                ObjectSerializer::toPathValue($storyPublicId),
                $resourcePath
            );
        }
        // path params
        if ($taskPublicId !== null) {
            $resourcePath = str_replace(
                '{' . 'task-public-id' . '}',
                ObjectSerializer::toPathValue($taskPublicId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateTask)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateTask));
            } else {
                $httpBody = $updateTask;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFiles
     *
     * Upload Files
     *
     * @param  \SplFileObject $file0 A file upload. At least one is required. (required)
     * @param  int|null $storyId The story ID that these files will be associated with. (optional)
     * @param  \SplFileObject|null $file1 Optional additional files. (optional)
     * @param  \SplFileObject|null $file2 Optional additional files. (optional)
     * @param  \SplFileObject|null $file3 Optional additional files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Timetoreply\Shortcut\Model\UploadedFile[]
     */
    public function uploadFiles($file0, $storyId = null, $file1 = null, $file2 = null, $file3 = null, string $contentType = self::contentTypes['uploadFiles'][0])
    {
        list($response) = $this->uploadFilesWithHttpInfo($file0, $storyId, $file1, $file2, $file3, $contentType);
        return $response;
    }

    /**
     * Operation uploadFilesWithHttpInfo
     *
     * Upload Files
     *
     * @param  \SplFileObject $file0 A file upload. At least one is required. (required)
     * @param  int|null $storyId The story ID that these files will be associated with. (optional)
     * @param  \SplFileObject|null $file1 Optional additional files. (optional)
     * @param  \SplFileObject|null $file2 Optional additional files. (optional)
     * @param  \SplFileObject|null $file3 Optional additional files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFiles'] to see the possible values for this operation
     *
     * @throws \Timetoreply\Shortcut\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Timetoreply\Shortcut\Model\UploadedFile[], HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFilesWithHttpInfo($file0, $storyId = null, $file1 = null, $file2 = null, $file3 = null, string $contentType = self::contentTypes['uploadFiles'][0])
    {
        $request = $this->uploadFilesRequest($file0, $storyId, $file1, $file2, $file3, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Timetoreply\Shortcut\Model\UploadedFile[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Timetoreply\Shortcut\Model\UploadedFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadFilesAsync
     *
     * Upload Files
     *
     * @param  \SplFileObject $file0 A file upload. At least one is required. (required)
     * @param  int|null $storyId The story ID that these files will be associated with. (optional)
     * @param  \SplFileObject|null $file1 Optional additional files. (optional)
     * @param  \SplFileObject|null $file2 Optional additional files. (optional)
     * @param  \SplFileObject|null $file3 Optional additional files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFilesAsync($file0, $storyId = null, $file1 = null, $file2 = null, $file3 = null, string $contentType = self::contentTypes['uploadFiles'][0])
    {
        return $this->uploadFilesAsyncWithHttpInfo($file0, $storyId, $file1, $file2, $file3, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFilesAsyncWithHttpInfo
     *
     * Upload Files
     *
     * @param  \SplFileObject $file0 A file upload. At least one is required. (required)
     * @param  int|null $storyId The story ID that these files will be associated with. (optional)
     * @param  \SplFileObject|null $file1 Optional additional files. (optional)
     * @param  \SplFileObject|null $file2 Optional additional files. (optional)
     * @param  \SplFileObject|null $file3 Optional additional files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFilesAsyncWithHttpInfo($file0, $storyId = null, $file1 = null, $file2 = null, $file3 = null, string $contentType = self::contentTypes['uploadFiles'][0])
    {
        $returnType = '\Timetoreply\Shortcut\Model\UploadedFile[]';
        $request = $this->uploadFilesRequest($file0, $storyId, $file1, $file2, $file3, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFiles'
     *
     * @param  \SplFileObject $file0 A file upload. At least one is required. (required)
     * @param  int|null $storyId The story ID that these files will be associated with. (optional)
     * @param  \SplFileObject|null $file1 Optional additional files. (optional)
     * @param  \SplFileObject|null $file2 Optional additional files. (optional)
     * @param  \SplFileObject|null $file3 Optional additional files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadFilesRequest($file0, $storyId = null, $file1 = null, $file2 = null, $file3 = null, string $contentType = self::contentTypes['uploadFiles'][0])
    {

        // verify the required parameter 'file0' is set
        if ($file0 === null || (is_array($file0) && count($file0) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file0 when calling uploadFiles'
            );
        }






        $resourcePath = '/api/v3/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'storyId' => $storyId,
            'file0' => $file0,
            'file1' => $file1,
            'file2' => $file2,
            'file3' => $file3,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Shortcut-Token');
        if ($apiKey !== null) {
            $headers['Shortcut-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
